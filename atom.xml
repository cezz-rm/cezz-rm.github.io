<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://zcej.github.io/atom.xml" rel="self"/>
  
  <link href="https://zcej.github.io/"/>
  <updated>2023-02-05T16:53:01.597Z</updated>
  <id>https://zcej.github.io/</id>
  
  <author>
    <name>CeJ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记一次oracle数据备份还原的操作</title>
    <link href="https://zcej.github.io/2022/10/20/%E5%85%B6%E4%BB%96/%E8%AE%B0%E4%B8%80%E6%AC%A1oracle%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%E8%BF%98%E5%8E%9F%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    <id>https://zcej.github.io/2022/10/20/%E5%85%B6%E4%BB%96/%E8%AE%B0%E4%B8%80%E6%AC%A1oracle%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%E8%BF%98%E5%8E%9F%E7%9A%84%E6%93%8D%E4%BD%9C/</id>
    <published>2022-10-20T15:01:43.000Z</published>
    <updated>2023-02-05T16:53:01.597Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul><li>oracle版本：12.2.0</li><li>目的：将一个用户的表结构和数据复制到另一个用户下(全量备份)</li><li>当前环境为虚拟机，已提前做好快照，避免中途出现问题</li><li>如果对oracle不熟，最好还是了解下用户，表空间和表之间的关系</li><li>数据备份和数据还原下仅列出主要命令，调试用到的命令见其他<h2 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h2><h4 id="1-管理员登录"><a href="#1-管理员登录" class="headerlink" title="1. 管理员登录"></a>1. 管理员登录</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlplus sys<span class="operator">/</span><span class="number">123456</span><span class="variable">@orcl</span> <span class="keyword">as</span> sysdba;</span><br></pre></td></tr></table></figure><h4 id="2-创建备份目录"><a href="#2-创建备份目录" class="headerlink" title="2. 创建备份目录"></a>2. 创建备份目录</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dba_directories;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> directory backup <span class="keyword">as</span> <span class="string">&#x27;d:\backup&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="3-赋于要导出数据表所属用户权限"><a href="#3-赋于要导出数据表所属用户权限" class="headerlink" title="3. 赋于要导出数据表所属用户权限"></a>3. 赋于要导出数据表所属用户权限</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> read,write <span class="keyword">on</span> directory backup <span class="keyword">to</span> C##USER1;</span><br></pre></td></tr></table></figure><h4 id="4-数据备份"><a href="#4-数据备份" class="headerlink" title="4. 数据备份"></a>4. 数据备份</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expdp C##USER1<span class="operator">/</span><span class="number">123456</span><span class="variable">@orcl</span> directory<span class="operator">=</span>backup dumpfile<span class="operator">=</span>backup.dmp logfile<span class="operator">=</span>export.log</span><br></pre></td></tr></table></figure>数据备份并没有遇到多大的阻碍，一路执行就成功了，这里贴出导出成功的日志文件：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">;;; </span><br><span class="line">Export: Release 12.2.0.1.0 - Production on 星期一 10月 31 10:54:38 2022</span><br><span class="line"></span><br><span class="line">Copyright (c) 1982, 2017, Oracle and/or its affiliates.  All rights reserved.</span><br><span class="line">;;; </span><br><span class="line">连接到: Oracle Database 12c Enterprise Edition Release 12.2.0.1.0 - 64bit Production</span><br><span class="line">启动 &quot;C##LEGACY&quot;.&quot;SYS_EXPORT_SCHEMA_01&quot;:  C##LEGACY/********@orcl directory=bpdata1 dumpfile=backup.dmp logfile=export.log </span><br><span class="line">处理对象类型 SCHEMA_EXPORT/TABLE/TABLE_DATA</span><br><span class="line">处理对象类型 SCHEMA_EXPORT/TABLE/INDEX/STATISTICS/INDEX_STATISTICS</span><br><span class="line">处理对象类型 SCHEMA_EXPORT/TABLE/STATISTICS/TABLE_STATISTICS</span><br><span class="line">处理对象类型 SCHEMA_EXPORT/STATISTICS/MARKER</span><br><span class="line">处理对象类型 SCHEMA_EXPORT/SYSTEM_GRANT</span><br><span class="line">处理对象类型 SCHEMA_EXPORT/ROLE_GRANT</span><br><span class="line">处理对象类型 SCHEMA_EXPORT/DEFAULT_ROLE</span><br><span class="line">处理对象类型 SCHEMA_EXPORT/PRE_SCHEMA/PROCACT_SCHEMA</span><br><span class="line">处理对象类型 SCHEMA_EXPORT/TABLE/TABLE</span><br><span class="line">处理对象类型 SCHEMA_EXPORT/TABLE/COMMENT</span><br><span class="line">处理对象类型 SCHEMA_EXPORT/TABLE/IDENTITY_COLUMN</span><br><span class="line">处理对象类型 SCHEMA_EXPORT/TABLE/INDEX/INDEX</span><br><span class="line">处理对象类型 SCHEMA_EXPORT/TABLE/CONSTRAINT/CONSTRAINT</span><br><span class="line">处理对象类型 SCHEMA_EXPORT/TABLE/CONSTRAINT/REF_CONSTRAINT</span><br><span class="line">. . 导出了 &quot;C##LEGACY&quot;.&quot;MSC_HUA_HISTORY&quot;               14.58 GB 71276923 行</span><br><span class="line">. . 导出了 &quot;C##LEGACY&quot;.&quot;ROSHAN_CUSTOMERS_ARCHIVE&quot;      2.877 GB 20218000 行</span><br><span class="line">. . 导出了 &quot;C##LEGACY&quot;.&quot;CELL_TOWERS&quot;                   1.080 GB 16865669 行</span><br><span class="line">. . 导出了 &quot;C##LEGACY&quot;.&quot;NEW_CELL_IDS&quot;                  2.318 MB   14745 行</span><br><span class="line">. . 导出了 &quot;C##LEGACY&quot;.&quot;MSC_DATA&quot;                      124.4 KB     246 行</span><br><span class="line">. . 导出了 &quot;C##LEGACY&quot;.&quot;MCC_MNC_OPERATOR&quot;              158.0 KB    1511 行</span><br><span class="line">. . 导出了 &quot;C##LEGACY&quot;.&quot;DJANGO_ADMIN_LOG&quot;              41.49 KB     145 行</span><br><span class="line">. . 导出了 &quot;C##LEGACY&quot;.&quot;DJANGO_SESSION&quot;                21.28 KB      14 行</span><br><span class="line">. . 导出了 &quot;C##LEGACY&quot;.&quot;AUTH_USER&quot;                     10.00 KB       2 行</span><br><span class="line">. . 导出了 &quot;C##LEGACY&quot;.&quot;QUERY_TASK&quot;                    9.156 KB       1 行</span><br><span class="line">. . 导出了 &quot;C##LEGACY&quot;.&quot;AUTH_PERMISSION&quot;               8.781 KB      32 行</span><br><span class="line">. . 导出了 &quot;C##LEGACY&quot;.&quot;DJANGO_MIGRATIONS&quot;             8.437 KB      25 行</span><br><span class="line">. . 导出了 &quot;C##LEGACY&quot;.&quot;DJANGO_CONTENT_TYPE&quot;           6.257 KB       8 行</span><br><span class="line">. . 导出了 &quot;C##LEGACY&quot;.&quot;AUTH_GROUP&quot;                        0 KB       0 行</span><br><span class="line">. . 导出了 &quot;C##LEGACY&quot;.&quot;AUTH_GROUP_PERMISSIONS&quot;            0 KB       0 行</span><br><span class="line">. . 导出了 &quot;C##LEGACY&quot;.&quot;AUTH_USER_GROUPS&quot;                  0 KB       0 行</span><br><span class="line">. . 导出了 &quot;C##LEGACY&quot;.&quot;AUTH_USER_USER_PERMISSIONS&quot;        0 KB       0 行</span><br><span class="line">已成功加载/卸载了主表 &quot;C##LEGACY&quot;.&quot;SYS_EXPORT_SCHEMA_01&quot; </span><br><span class="line">******************************************************************************</span><br><span class="line">C##LEGACY.SYS_EXPORT_SCHEMA_01 的转储文件集为:</span><br><span class="line">  C:\BACKUP\BACKUP.DMP</span><br><span class="line">作业 &quot;C##LEGACY&quot;.&quot;SYS_EXPORT_SCHEMA_01&quot; 已于 星期一 10月 31 10:56:19 2022 elapsed 0 00:01:38 成功完成</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="数据还原"><a href="#数据还原" class="headerlink" title="数据还原"></a>数据还原</h2><blockquote><p>注：下述sql命令均在sys账号下执行</p></blockquote></li></ul><h4 id="1-新建表空间"><a href="#1-新建表空间" class="headerlink" title="1. 新建表空间"></a>1. 新建表空间</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span>space bp</span><br><span class="line">datafile <span class="string">&#x27;C:/backup/bp.DBF&#x27;</span></span><br><span class="line">size <span class="number">100</span>M autoextend <span class="keyword">on</span> next <span class="number">50</span>M maxsize unlimited;</span><br></pre></td></tr></table></figure><h4 id="2-创建用户并赋权"><a href="#2-创建用户并赋权" class="headerlink" title="2. 创建用户并赋权"></a>2. 创建用户并赋权</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> C##USER2 </span><br><span class="line">identified <span class="keyword">by</span> &quot;123456&quot;</span><br><span class="line"><span class="keyword">default</span> tablespace bp</span><br><span class="line">profile <span class="keyword">DEFAULT</span></span><br><span class="line">ACCOUNT UNLOCK;</span><br><span class="line"></span><br><span class="line"><span class="keyword">grant</span> dba <span class="keyword">to</span> C##USER2;</span><br><span class="line"><span class="keyword">grant</span> resource <span class="keyword">to</span> C##USER2;</span><br></pre></td></tr></table></figure><h4 id="3-数据还原"><a href="#3-数据还原" class="headerlink" title="3.数据还原"></a>3.数据还原</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">impdp C##USER2<span class="operator">/</span><span class="number">123456</span><span class="variable">@orcl</span> directory<span class="operator">=</span>backup dumpfile<span class="operator">=</span>backup.dmp remap_schema<span class="operator">=</span>C##LEGACY:C##WYX logfile<span class="operator">=</span>import.log</span><br></pre></td></tr></table></figure><p>若已有相同的数据表(此时会报ORA-39151错误)，则添加下述参数：<br><code>table_exists_action=replace</code></p><ul><li>skip：跳过并处理下一个对象</li><li>append：为表增加数据</li><li>truncate：清空表，然后为其增加数据</li><li>replace：删除已存在表，重新建表并追加数据</li></ul><p>本以为到此应该能够成功进行还原了，没想到报了一个数据文件无法扩展的问题，找了下资料发现oracle里一个数据文件最大为32G，故根据提示在对应的表空间新增数据文件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span>space &quot;USERS&quot; <span class="keyword">add</span> datafile <span class="string">&#x27;C:\APP\ORACLE\ORADATA\ORCL\USERS02.DBF&#x27;</span> size <span class="number">100</span>m autoextend <span class="keyword">on</span> next <span class="number">100</span>m maxsize unlimited;</span><br></pre></td></tr></table></figure><p>至此，已经能成功导入还原了：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">;;; </span><br><span class="line">Import: <span class="keyword">Release</span> <span class="number">12.2</span><span class="number">.0</span><span class="number">.1</span><span class="number">.0</span> <span class="operator">-</span> Production <span class="keyword">on</span> 星期一 <span class="number">10</span>月 <span class="number">31</span> <span class="number">18</span>:<span class="number">51</span>:<span class="number">06</span> <span class="number">2022</span></span><br><span class="line"></span><br><span class="line">Copyright (c) <span class="number">1982</span>, <span class="number">2017</span>, Oracle <span class="keyword">and</span><span class="operator">/</span><span class="keyword">or</span> its affiliates.  <span class="keyword">All</span> rights reserved.</span><br><span class="line">;;; </span><br><span class="line">连接到: Oracle Database <span class="number">12</span>c Enterprise Edition <span class="keyword">Release</span> <span class="number">12.2</span><span class="number">.0</span><span class="number">.1</span><span class="number">.0</span> <span class="operator">-</span> <span class="number">64</span>bit Production</span><br><span class="line">已成功加载<span class="operator">/</span>卸载了主表 &quot;C##LEGACY&quot;.&quot;SYS_IMPORT_FULL_01&quot; </span><br><span class="line">ORA<span class="number">-39146</span>: 方案 &quot;C##WYX2&quot; 不存在</span><br><span class="line">启动 &quot;C##LEGACY&quot;.&quot;SYS_IMPORT_FULL_01&quot;:  C##WYX<span class="comment">/********@orcl directory=bpdata1 dumpfile=backup.dmp remap_schema=C##WYX2:C##LEGACY logfile=import.log </span></span><br><span class="line"><span class="comment">处理对象类型 SCHEMA_EXPORT/SYSTEM_GRANT</span></span><br><span class="line"><span class="comment">处理对象类型 SCHEMA_EXPORT/ROLE_GRANT</span></span><br><span class="line"><span class="comment">处理对象类型 SCHEMA_EXPORT/DEFAULT_ROLE</span></span><br><span class="line"><span class="comment">处理对象类型 SCHEMA_EXPORT/PRE_SCHEMA/PROCACT_SCHEMA</span></span><br><span class="line"><span class="comment">处理对象类型 SCHEMA_EXPORT/TABLE/TABLE</span></span><br><span class="line"><span class="comment">处理对象类型 SCHEMA_EXPORT/TABLE/TABLE_DATA</span></span><br><span class="line"><span class="comment">. . 导入了 &quot;C##WYX&quot;.&quot;MSC_HUA_HISTORY&quot;               14.58 GB 71276923 行</span></span><br><span class="line"><span class="comment">. . 导入了 &quot;C##WYX&quot;.&quot;ROSHAN_CUSTOMERS_ARCHIVE&quot;      2.877 GB 20218000 行</span></span><br><span class="line"><span class="comment">. . 导入了 &quot;C##WYX&quot;.&quot;CELL_TOWERS&quot;                   1.080 GB 16865669 行</span></span><br><span class="line"><span class="comment">. . 导入了 &quot;C##WYX&quot;.&quot;NEW_CELL_IDS&quot;                  2.318 MB   14745 行</span></span><br><span class="line"><span class="comment">. . 导入了 &quot;C##WYX&quot;.&quot;MSC_DATA&quot;                      124.4 KB     246 行</span></span><br><span class="line"><span class="comment">. . 导入了 &quot;C##WYX&quot;.&quot;MCC_MNC_OPERATOR&quot;              158.0 KB    1511 行</span></span><br><span class="line"><span class="comment">. . 导入了 &quot;C##WYX&quot;.&quot;DJANGO_ADMIN_LOG&quot;              41.49 KB     145 行</span></span><br><span class="line"><span class="comment">. . 导入了 &quot;C##WYX&quot;.&quot;DJANGO_SESSION&quot;                21.28 KB      14 行</span></span><br><span class="line"><span class="comment">. . 导入了 &quot;C##WYX&quot;.&quot;AUTH_USER&quot;                     10.00 KB       2 行</span></span><br><span class="line"><span class="comment">. . 导入了 &quot;C##WYX&quot;.&quot;QUERY_TASK&quot;                    9.156 KB       1 行</span></span><br><span class="line"><span class="comment">. . 导入了 &quot;C##WYX&quot;.&quot;AUTH_PERMISSION&quot;               8.781 KB      32 行</span></span><br><span class="line"><span class="comment">. . 导入了 &quot;C##WYX&quot;.&quot;DJANGO_MIGRATIONS&quot;             8.437 KB      25 行</span></span><br><span class="line"><span class="comment">. . 导入了 &quot;C##WYX&quot;.&quot;DJANGO_CONTENT_TYPE&quot;           6.257 KB       8 行</span></span><br><span class="line"><span class="comment">. . 导入了 &quot;C##WYX&quot;.&quot;AUTH_GROUP&quot;                        0 KB       0 行</span></span><br><span class="line"><span class="comment">. . 导入了 &quot;C##WYX&quot;.&quot;AUTH_GROUP_PERMISSIONS&quot;            0 KB       0 行</span></span><br><span class="line"><span class="comment">. . 导入了 &quot;C##WYX&quot;.&quot;AUTH_USER_GROUPS&quot;                  0 KB       0 行</span></span><br><span class="line"><span class="comment">. . 导入了 &quot;C##WYX&quot;.&quot;AUTH_USER_USER_PERMISSIONS&quot;        0 KB       0 行</span></span><br><span class="line"><span class="comment">处理对象类型 SCHEMA_EXPORT/TABLE/COMMENT</span></span><br><span class="line"><span class="comment">处理对象类型 SCHEMA_EXPORT/TABLE/IDENTITY_COLUMN</span></span><br><span class="line"><span class="comment">处理对象类型 SCHEMA_EXPORT/TABLE/INDEX/INDEX</span></span><br><span class="line"><span class="comment">处理对象类型 SCHEMA_EXPORT/TABLE/CONSTRAINT/CONSTRAINT</span></span><br><span class="line"><span class="comment">处理对象类型 SCHEMA_EXPORT/TABLE/INDEX/STATISTICS/INDEX_STATISTICS</span></span><br><span class="line"><span class="comment">处理对象类型 SCHEMA_EXPORT/TABLE/CONSTRAINT/REF_CONSTRAINT</span></span><br><span class="line"><span class="comment">处理对象类型 SCHEMA_EXPORT/TABLE/STATISTICS/TABLE_STATISTICS</span></span><br><span class="line"><span class="comment">处理对象类型 SCHEMA_EXPORT/STATISTICS/MARKER</span></span><br><span class="line"><span class="comment">作业 &quot;C##LEGACY&quot;.&quot;SYS_IMPORT_FULL_01&quot; 已于 星期一 10月 31 19:00:59 2022 elapsed 0 00:09:49 成功完成</span></span><br><span class="line"><span class="comment"></span></span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dba_directories;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dba_tablespaces;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dba_data_files;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dba_users;</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span>space &quot;USERS&quot; <span class="keyword">drop</span> datafile <span class="number">23</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> T.TABLESPACE_NAME,D.FILE_NAME,D.AUTOEXTENSIBLE,D.BYTES,D.MAXBYTES,D.STATUS</span><br><span class="line"><span class="keyword">FROM</span> DBA_TABLESPACES T,DBA_DATA_FILES D</span><br><span class="line"><span class="keyword">WHERE</span> T.TABLESPACE_NAME <span class="operator">=</span>D.TABLESPACE_NAME</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> TABLESPACE_NAME,FILE_NAME;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> a.tablespace_name &quot;表空间名&quot;, </span><br><span class="line">total &quot;表空间大小&quot;, </span><br><span class="line"><span class="keyword">free</span> &quot;表空间剩余大小&quot;, </span><br><span class="line">(total <span class="operator">-</span> <span class="keyword">free</span>) &quot;表空间使用大小&quot;, </span><br><span class="line">total <span class="operator">/</span> (<span class="number">1024</span> <span class="operator">*</span> <span class="number">1024</span> <span class="operator">*</span> <span class="number">1024</span>) &quot;表空间大小(G)&quot;, </span><br><span class="line"><span class="keyword">free</span> <span class="operator">/</span> (<span class="number">1024</span> <span class="operator">*</span> <span class="number">1024</span> <span class="operator">*</span> <span class="number">1024</span>) &quot;表空间剩余大小(G)&quot;, </span><br><span class="line">(total <span class="operator">-</span> <span class="keyword">free</span>) <span class="operator">/</span> (<span class="number">1024</span> <span class="operator">*</span> <span class="number">1024</span> <span class="operator">*</span> <span class="number">1024</span>) &quot;表空间使用大小(G)&quot;, </span><br><span class="line">round((total <span class="operator">-</span> <span class="keyword">free</span>) <span class="operator">/</span> total, <span class="number">4</span>) <span class="operator">*</span> <span class="number">100</span> &quot;使用率 %&quot; </span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> tablespace_name, <span class="built_in">SUM</span>(bytes) <span class="keyword">free</span> </span><br><span class="line"><span class="keyword">FROM</span> dba_free_space </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> tablespace_name) a, </span><br><span class="line">(<span class="keyword">SELECT</span> tablespace_name, <span class="built_in">SUM</span>(bytes) total </span><br><span class="line"><span class="keyword">FROM</span> dba_data_files </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> tablespace_name) b </span><br><span class="line"><span class="keyword">WHERE</span> a.tablespace_name <span class="operator">=</span> b.tablespace_name;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;oracle版本：12.2.0&lt;/li&gt;
&lt;li&gt;目的：将一个用户的表结构和数据复制到另一个用户下(全量备份)&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    <category term="其他" scheme="https://zcej.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>如何控制并发速率2.0</title>
    <link href="https://zcej.github.io/2022/10/06/go/%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91%E9%80%9F%E7%8E%872.0/"/>
    <id>https://zcej.github.io/2022/10/06/go/%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91%E9%80%9F%E7%8E%872.0/</id>
    <published>2022-10-06T05:11:03.000Z</published>
    <updated>2023-02-05T16:54:32.191Z</updated>
    
    <content type="html"><![CDATA[<p>之前有记录过在go中如何控制并发速率，要么就是通过带缓冲的channel，要么就是通过协程池。不论是通过什么方式，选择最适合在当前场景使用的即可，下面记录下学习过程中发现的开源项目中不同的实现方式。</p><h2 id="ratelimit"><a href="#ratelimit" class="headerlink" title="ratelimit"></a>ratelimit</h2><ul><li><p>来自<code>projectdiscovery/ratelimit</code></p></li><li><p>个人理解该项目的特点是能控制的是每隔一段时间(自己定义)，起多少个并发，之前起的goroutine还在执行的话也没有影响，故如果goroutine执行的若是比较耗时的操作，那么会不会存在goroutine的数量一直在增加，消耗完所有内存，导致程序崩溃的情况。</p></li><li><p>不过这主要还是和使用方式有关，排除上述疑问的话，这个实现速率控制的方式也非常值得学习</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Limiter <span class="keyword">struct</span> &#123;</span><br><span class="line">maxCount <span class="type">int64</span>            <span class="comment">// 定义的最大并发数</span></span><br><span class="line">count    <span class="type">int64</span>            <span class="comment">// 当前剩余的令牌数(token)</span></span><br><span class="line">ticker   *time.Ticker     <span class="comment">// 定时器，执行定时任务(标准库)</span></span><br><span class="line">tokens   <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;    <span class="comment">// 无缓冲channel，用于获取令牌</span></span><br><span class="line">ctx      context.Context  <span class="comment">// 上下文，终止定时器及创建的子协程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(limiter *Limiter)</span></span> run() &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 当剩余的令牌数小于等于零时，等待设置的时间间隔后，重置剩余令牌数</span></span><br><span class="line"><span class="keyword">if</span> limiter.count &lt;= <span class="number">0</span> &#123;</span><br><span class="line">&lt;-limiter.ticker.C</span><br><span class="line">limiter.count = limiter.maxCount</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="comment">// 接收退出信号，关闭定时器并返回</span></span><br><span class="line"><span class="keyword">case</span> &lt;-limiter.ctx.Done():</span><br><span class="line">limiter.ticker.Stop()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">        <span class="comment">// 获取</span></span><br><span class="line"><span class="keyword">case</span> limiter.tokens &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line">limiter.count--</span><br><span class="line">        <span class="comment">// 每过一段时间(设置的时间间隔)，重置剩余令牌数</span></span><br><span class="line">        <span class="comment">// 与其他case是否执行无关，当其他case执行的时间小于该间隔，则其他case不会被执行</span></span><br><span class="line"><span class="keyword">case</span> &lt;-limiter.ticker.C:</span><br><span class="line">limiter.count = limiter.maxCount</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Take one token from the bucket</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rateLimiter *Limiter)</span></span> Take() &#123;</span><br><span class="line">&lt;-rateLimiter.tokens</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>官方示例中还有两个新建<code>Limiter</code>的方法，一个是控制并发速率和时间间隔的<code>New</code>，一个是不做任何控制的<code>NewUnlimited</code>，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// New creates a new limiter instance with the tokens amount and the interval</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(ctx context.Context, max <span class="type">int64</span>, duration time.Duration)</span></span> *Limiter &#123;</span><br><span class="line">limiter := &amp;Limiter&#123;</span><br><span class="line">maxCount: max,</span><br><span class="line">count:    max,</span><br><span class="line">ticker:   time.NewTicker(duration),</span><br><span class="line">tokens:   <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">ctx:      ctx,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> limiter.run()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> limiter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewUnlimited create a bucket with approximated unlimited tokens</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUnlimited</span><span class="params">(ctx context.Context)</span></span> *Limiter &#123;</span><br><span class="line">limiter := &amp;Limiter&#123;</span><br><span class="line">maxCount: math.MaxInt64,</span><br><span class="line">count:    math.MaxInt64,</span><br><span class="line">ticker:   time.NewTicker(time.Millisecond),</span><br><span class="line">tokens:   <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">ctx:      ctx,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> limiter.run()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> limiter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人写的一个使用案例如下，还是得多思考程序的一个运行流程：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">expected := <span class="number">5</span> * time.Second</span><br><span class="line">limiter := New(context.Background(), <span class="number">5</span>, expected)</span><br><span class="line">start := time.Now()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">limiter.Take()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(_i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(_i, <span class="string">&quot;+++&quot;</span>, time.Since(start))</span><br><span class="line">time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">fmt.Println(_i, <span class="string">&quot;---&quot;</span>, time.Since(start))</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">took := time.Since(start)</span><br><span class="line">fmt.Println(took)</span><br><span class="line"></span><br><span class="line">limiter.Take()</span><br><span class="line">took = time.Since(start)</span><br><span class="line">fmt.Println(took)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 部分输出结果如下：</span></span><br><span class="line"><span class="comment">// 1 +++ 0s</span></span><br><span class="line"><span class="comment">// 0 +++ 0s</span></span><br><span class="line"><span class="comment">// 3 +++ 0s</span></span><br><span class="line"><span class="comment">// 2 +++ 0s</span></span><br><span class="line"><span class="comment">// 4 +++ 0s</span></span><br><span class="line"><span class="comment">// 6 +++ 5.0139749s</span></span><br><span class="line"><span class="comment">// 5 +++ 5.0139749s</span></span><br><span class="line"><span class="comment">// 8 +++ 5.0139749s</span></span><br><span class="line"><span class="comment">// 7 +++ 5.0139749s</span></span><br><span class="line"><span class="comment">// 9 +++ 5.0139749s</span></span><br><span class="line"><span class="comment">// 4 --- 10.0149828s</span></span><br><span class="line"><span class="comment">// 10 +++ 10.0149828s</span></span><br><span class="line"><span class="comment">// 11 +++ 10.0149828s</span></span><br><span class="line"><span class="comment">// 1 --- 10.0149828s</span></span><br><span class="line"><span class="comment">// 2 --- 10.0149828s</span></span><br><span class="line"><span class="comment">// 3 --- 10.0149828s</span></span><br><span class="line"><span class="comment">// 0 --- 10.0149828s</span></span><br><span class="line"><span class="comment">// 13 +++ 10.0149828s</span></span><br><span class="line"><span class="comment">// 12 +++ 10.0149828s</span></span><br><span class="line"><span class="comment">// 14 +++ 10.0149828s</span></span><br></pre></td></tr></table></figure><h2 id="sizedwaitgroup"><a href="#sizedwaitgroup" class="headerlink" title="sizedwaitgroup"></a>sizedwaitgroup</h2></li><li><p>来自<code>remeh/sizedwaitgroup</code></p></li><li><p>这个项目是对标准库<code>sync.WaitGroup</code>进行了进一步的封装，定义了一个大小和控制并发的channel，从实现上来看还是非常简单易懂，就不做注释了</p></li><li><p>对比<code>ratelimit</code>，个人理解这个是严格控制了同一时刻goroutine的并发数</p><h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SizedWaitGroup has the same role and close to the</span></span><br><span class="line"><span class="comment">// same API as the Golang sync.WaitGroup but adds a limit of</span></span><br><span class="line"><span class="comment">// the amount of goroutines started concurrently.</span></span><br><span class="line"><span class="keyword">type</span> SizedWaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">Size <span class="type">int</span></span><br><span class="line"></span><br><span class="line">current <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">wg      sync.WaitGroup</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New creates a SizedWaitGroup.</span></span><br><span class="line"><span class="comment">// The limit parameter is the maximum amount of</span></span><br><span class="line"><span class="comment">// goroutines which can be started concurrently.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(limit <span class="type">int</span>)</span></span> SizedWaitGroup &#123;</span><br><span class="line">size := math.MaxInt32 <span class="comment">// 2^31 - 1</span></span><br><span class="line"><span class="keyword">if</span> limit &gt; <span class="number">0</span> &#123;</span><br><span class="line">size = limit</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> SizedWaitGroup&#123;</span><br><span class="line">Size: size,</span><br><span class="line"></span><br><span class="line">current: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, size),</span><br><span class="line">wg:      sync.WaitGroup&#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add increments the internal WaitGroup counter.</span></span><br><span class="line"><span class="comment">// It can be blocking if the limit of spawned goroutines</span></span><br><span class="line"><span class="comment">// has been reached. It will stop blocking when Done is</span></span><br><span class="line"><span class="comment">// been called.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// See sync.WaitGroup documentation for more information.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SizedWaitGroup)</span></span> Add() &#123;</span><br><span class="line">s.AddWithContext(context.Background())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AddWithContext increments the internal WaitGroup counter.</span></span><br><span class="line"><span class="comment">// It can be blocking if the limit of spawned goroutines</span></span><br><span class="line"><span class="comment">// has been reached. It will stop blocking when Done is</span></span><br><span class="line"><span class="comment">// been called, or when the context is canceled. Returns nil on</span></span><br><span class="line"><span class="comment">// success or an error if the context is canceled before the lock</span></span><br><span class="line"><span class="comment">// is acquired.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// See sync.WaitGroup documentation for more information.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SizedWaitGroup)</span></span> AddWithContext(ctx context.Context) <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">return</span> ctx.Err()</span><br><span class="line"><span class="keyword">case</span> s.current &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">s.wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Done decrements the SizedWaitGroup counter.</span></span><br><span class="line"><span class="comment">// See sync.WaitGroup documentation for more information.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SizedWaitGroup)</span></span> Done() &#123;</span><br><span class="line">&lt;-s.current</span><br><span class="line">s.wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait blocks until the SizedWaitGroup counter is zero.</span></span><br><span class="line"><span class="comment">// See sync.WaitGroup documentation for more information.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SizedWaitGroup)</span></span> Wait() &#123;</span><br><span class="line">s.wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用方式-1"><a href="#使用方式-1" class="headerlink" title="使用方式"></a>使用方式</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">query</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">swg := New(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">50</span>; i++ &#123;</span><br><span class="line">swg.Add()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> swg.Done()</span><br><span class="line">query(i)</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 部分输出如下</span></span><br><span class="line"><span class="comment">// 0 5.0046797s</span></span><br><span class="line"><span class="comment">// 1 5.0046797s</span></span><br><span class="line"><span class="comment">// 2 5.0048117s</span></span><br><span class="line"><span class="comment">// 3 5.0046797s</span></span><br><span class="line"><span class="comment">// 4 5.0048117s</span></span><br><span class="line"><span class="comment">// 6 10.020529s</span></span><br><span class="line"><span class="comment">// 8 10.020529s</span></span><br><span class="line"><span class="comment">// 9 10.020529s</span></span><br><span class="line"><span class="comment">// 7 10.020529s</span></span><br><span class="line"><span class="comment">// 5 10.020529s</span></span><br><span class="line"><span class="comment">// 14 15.0282816s</span></span><br><span class="line"><span class="comment">// 12 15.0283974s</span></span><br><span class="line"><span class="comment">// 11 15.0283974s</span></span><br><span class="line"><span class="comment">// 10 15.0283974s</span></span><br><span class="line"><span class="comment">// 13 15.0283974s</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上述案例可以发现，不论是通过哪种方式去控制并发速率，它们都是通过channel去进行控制的，区别在于<code>ratelimit</code>是使用的无缓冲的channel，而<code>sizedwaitgroup</code>使用的是有缓冲的channel。故回归到本质，熟练掌握基础，深刻理解底层实现才是后期不断进阶的基石。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前有记录过在go中如何控制并发速率，要么就是通过带缓冲的channel，要么就是通过协程池。不论是通过什么方式，选择最适合在当前场景使用的即可，下面记录下学习过程中发现的开源项目中不同的实现方式。&lt;/p&gt;
&lt;h2 id=&quot;ratelimit&quot;&gt;&lt;a href=&quot;#rate</summary>
      
    
    
    
    <category term="go" scheme="https://zcej.github.io/categories/go/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux常用命令之--ldd</title>
    <link href="https://zcej.github.io/2022/10/02/%E5%85%B6%E4%BB%96/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B9%8B%E2%80%94%E2%80%94ldd/"/>
    <id>https://zcej.github.io/2022/10/02/%E5%85%B6%E4%BB%96/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B9%8B%E2%80%94%E2%80%94ldd/</id>
    <published>2022-10-02T03:08:31.000Z</published>
    <updated>2023-02-05T16:51:23.520Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>ldd是用于查看可执行文件的动态链接库依赖。(也可使用pmap进行查看)<br>Q：什么是动态链接呢？</p><ul><li>有动态链接就有静态链接。静态链接是把依赖的第三方库函数打包到一起，其最后生成的可执行文件非常大。动态链接并不将那些库文件直接拿过来，而是在运行时，发现用到某些库中的某些函数时，再从第三方库中读取自己所需的方法。</li><li>动态链接库，linux下的后缀为so(Shared Object)，windows下的后缀为dll(Dynamic Link Libaray)。<blockquote><p>注：更多动态链接相关内容可参考下述文章：<br><a href="https://zhuanlan.zhihu.com/p/235551437">https://zhuanlan.zhihu.com/p/235551437</a></p></blockquote></li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>可以使用<code>ldd</code>查看文件的动态链接依赖，如查看ls依赖的结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(venvStudy) [root@node1 build_so]<span class="comment"># ldd /bin/ls</span></span><br><span class="line">        linux-vdso.so.1 =&gt;  (0x00007ffef8adb000)</span><br><span class="line">        libselinux.so.1 =&gt; /lib64/libselinux.so.1 (0x00007f3809d7d000)</span><br><span class="line">        libcap.so.2 =&gt; /lib64/libcap.so.2 (0x00007f3809b78000)</span><br><span class="line">        libacl.so.1 =&gt; /lib64/libacl.so.1 (0x00007f380996f000)</span><br><span class="line">        libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f38095a1000)</span><br><span class="line">        libpcre.so.1 =&gt; /lib64/libpcre.so.1 (0x00007f380933f000)</span><br><span class="line">        libdl.so.2 =&gt; /lib64/libdl.so.2 (0x00007f380913b000)</span><br><span class="line">        /lib64/ld-linux-x86-64.so.2 (0x00007f3809fa4000)</span><br><span class="line">        libattr.so.1 =&gt; /lib64/libattr.so.1 (0x00007f3808f36000)</span><br><span class="line">        libpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x00007f3808d1a000)</span><br></pre></td></tr></table></figure><p>通常安装某软件若是报错缺失某个依赖文件时，再结合<code>apt-file</code>查看文件所在包，然后使用<code>apt</code>进行安装。</p><blockquote><p>注：Ubuntu下使用<code>apt-file</code>涉及到的命令如下：</p><ul><li><code>apt install apt-file</code></li><li><code>apt-file update</code></li><li><code>apt-file search libpthread.so.0</code></li></ul></blockquote><p>CentOS下使用命令<code>yum provides libpthread.so.0</code></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>在技术交流群看到其他人为了防止python代码泄露，有把python代码打包成动态链接库so的，自己不知道还可以这样操作，在此进行记录下。需要先安装<code>Cython</code>，该库是通过类似python的语法去编写c扩展并可以被python调用。其即具备了python快速开发的特点，又可以让代码运行起来像c一样快，同时还可以方便的调用c library。安装命令如下：<br><code>pip install Cython -i [https://pypi.mirrors.ustc.edu.cn/simple](https://pypi.mirrors.ustc.edu.cn/simple)</code></p><h3 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h3><p>新建文件<code>hello.py</code>，该文件为被打包的目标文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;hello, <span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>新建文件<code>setup.py</code>，该文件是调用<code>Cython</code>进行打包的文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> setup</span><br><span class="line"><span class="keyword">from</span> Cython.Build <span class="keyword">import</span> cythonize</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    file_name = <span class="string">&#x27;hello.py&#x27;</span>  <span class="comment"># 文件名</span></span><br><span class="line">    build_dir = <span class="string">&#x27;&#x27;</span>  <span class="comment"># 文件目录</span></span><br><span class="line">    build_tmp_dir = <span class="string">&#x27;temp&#x27;</span>  <span class="comment"># 编译的临时文件目录</span></span><br><span class="line">    setup(ext_modules=cythonize(file_name), script_args=[<span class="string">&quot;build_ext&quot;</span>, <span class="string">&quot;-b&quot;</span>, build_dir, <span class="string">&quot;-t&quot;</span>, build_tmp_dir])</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来直接执行<code>python setup.py</code>，可以看到打包编译的过程，如果没有报错的话结果输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(venvStudy) [root@node1 build_so]<span class="comment"># ll</span></span><br><span class="line">total 284</span><br><span class="line">drwxr-xr-x 3 root root   4096 Oct 2 11:53 build</span><br><span class="line">-rw-r--r-- 1 root root 140877 Oct 2 11:53 hello.c</span><br><span class="line">-rwxr-xr-x 1 root root 130968 Oct 2 11:53 hello.cpython-37m-x86_64-linux-gnu.so</span><br><span class="line">-rw-r--r-- 1 root root     46 Oct 2 11:40 hello.py</span><br><span class="line">-rw-r--r-- 1 root root    428 Oct 2 11:53 setup.py</span><br><span class="line">-rw-r--r-- 1 root root     37 Oct 2 11:38 test.py</span><br></pre></td></tr></table></figure><p>此时已经生成了动态链接库so文件，可以将<code>hello.py</code>删除，也可以正常调用hello，<code>build</code>目录下是生成的临时文件。到这里只是大概了解了如何将python代码打包为so文件，想要更好的工程实践见下一部分内容。</p><h3 id="工程实践"><a href="#工程实践" class="headerlink" title="工程实践"></a>工程实践</h3><p>可使用下述代码进行打包，来自<code>[https://github.com/ArvinMei/py2so/blob/master/py2so.py](https://github.com/ArvinMei/py2so/blob/master/py2so.py)</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys, os, shutil, time</span><br><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> setup</span><br><span class="line"><span class="keyword">from</span> Cython.Build <span class="keyword">import</span> cythonize</span><br><span class="line"></span><br><span class="line">starttime = time.time()</span><br><span class="line">setupfile= os.path.join(os.path.abspath(<span class="string">&#x27;.&#x27;</span>), __file__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getpy</span>(<span class="params">basepath=os.path.abspath(<span class="params"><span class="string">&#x27;.&#x27;</span></span>), parentpath=<span class="string">&#x27;&#x27;</span>, name=<span class="string">&#x27;&#x27;</span>, build_dir=<span class="string">&quot;build&quot;</span>, </span></span><br><span class="line"><span class="params">          excepts=(<span class="params"></span>), copyOther=<span class="literal">False</span>, delC=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    获取py文件的路径</span></span><br><span class="line"><span class="string">    :param basepath: 根路径</span></span><br><span class="line"><span class="string">    :param parentpath: 父路径</span></span><br><span class="line"><span class="string">    :param name: 文件/夹</span></span><br><span class="line"><span class="string">    :param excepts: 排除文件</span></span><br><span class="line"><span class="string">    :param copy: 是否copy其他文件</span></span><br><span class="line"><span class="string">    :return: py文件的迭代器</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    fullpath = os.path.join(basepath, parentpath, name)</span><br><span class="line">    <span class="keyword">for</span> fname <span class="keyword">in</span> os.listdir(fullpath):</span><br><span class="line">        ffile = os.path.join(fullpath, fname)</span><br><span class="line">        <span class="keyword">if</span> os.path.isdir(ffile) <span class="keyword">and</span> ffile != os.path.join(basepath, build_dir) <span class="keyword">and</span> <span class="keyword">not</span> fname.startswith(<span class="string">&#x27;.&#x27;</span>):</span><br><span class="line">            <span class="keyword">for</span> f <span class="keyword">in</span> getpy(basepath, os.path.join(parentpath, name), fname, build_dir, excepts, copyOther, delC):</span><br><span class="line">                <span class="keyword">yield</span> f</span><br><span class="line">        <span class="keyword">elif</span> os.path.isfile(ffile):</span><br><span class="line">            <span class="comment"># print(&quot;\t&quot;, basepath, parentpath, name, ffile)</span></span><br><span class="line">            ext = os.path.splitext(fname)[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> ext == <span class="string">&quot;.c&quot;</span>:</span><br><span class="line">                <span class="keyword">if</span> delC <span class="keyword">and</span> os.stat(ffile).st_mtime &gt; starttime:</span><br><span class="line">                    os.remove(ffile)</span><br><span class="line">            <span class="keyword">elif</span> ffile <span class="keyword">not</span> <span class="keyword">in</span> excepts <span class="keyword">and</span> ext <span class="keyword">not</span> <span class="keyword">in</span>(<span class="string">&#x27;.pyc&#x27;</span>, <span class="string">&#x27;.pyx&#x27;</span>):</span><br><span class="line">                <span class="comment"># print(&quot;\t\t&quot;, basepath, parentpath, name, ffile)</span></span><br><span class="line">                <span class="keyword">if</span> ext <span class="keyword">in</span>(<span class="string">&#x27;.py&#x27;</span>, <span class="string">&#x27;.pyx&#x27;</span>) <span class="keyword">and</span> <span class="keyword">not</span> fname.startswith(<span class="string">&#x27;__&#x27;</span>):</span><br><span class="line">                    <span class="keyword">yield</span> os.path.join(parentpath, name, fname)</span><br><span class="line">                <span class="keyword">elif</span> copyOther:</span><br><span class="line">                        dstdir = os.path.join(basepath, build_dir, parentpath, name)</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(dstdir): os.makedirs(dstdir)</span><br><span class="line">                        shutil.copyfile(ffile, os.path.join(dstdir, fname))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    currdir = os.path.abspath(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    parentpath = sys.argv[<span class="number">1</span>] <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv)&gt;<span class="number">1</span> <span class="keyword">else</span> <span class="string">&quot;.&quot;</span></span><br><span class="line"></span><br><span class="line">    currdir, parentpath = os.path.split(currdir <span class="keyword">if</span> parentpath == <span class="string">&quot;.&quot;</span> <span class="keyword">else</span> os.path.abspath(parentpath))</span><br><span class="line">    build_dir = os.path.join(parentpath, <span class="string">&quot;build&quot;</span>)</span><br><span class="line">    build_tmp_dir = os.path.join(build_dir, <span class="string">&quot;temp&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;start:&quot;</span>, currdir, parentpath, build_dir)</span><br><span class="line">    os.chdir(currdir)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment">#获取py列表</span></span><br><span class="line">        module_list = <span class="built_in">list</span>(getpy(basepath=currdir,parentpath=parentpath, build_dir=build_dir, excepts=(setupfile)))</span><br><span class="line">        <span class="built_in">print</span>(module_list)</span><br><span class="line">        setup(ext_modules = cythonize(module_list),script_args=[<span class="string">&quot;build_ext&quot;</span>, <span class="string">&quot;-b&quot;</span>, build_dir, <span class="string">&quot;-t&quot;</span>, build_tmp_dir])</span><br><span class="line">        module_list = <span class="built_in">list</span>(getpy(basepath=currdir, parentpath=parentpath, build_dir=build_dir, excepts=(setupfile), copyOther=<span class="literal">True</span>))</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> ex:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;error! &quot;</span>, ex)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;cleaning...&quot;</span>)</span><br><span class="line">        module_list = <span class="built_in">list</span>(getpy(basepath=currdir, parentpath=parentpath, build_dir=build_dir, excepts=(setupfile), delC=<span class="literal">True</span>))</span><br><span class="line">        <span class="keyword">if</span> os.path.exists(build_tmp_dir): shutil.rmtree(build_tmp_dir)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;complate! time:&quot;</span>, time.time()-starttime, <span class="string">&#x27;s&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;ldd是用于查看可执行文件的动态链接库依赖。(也可使用pmap进行查看)&lt;br&gt;Q：什么是动态链接呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有动态链接</summary>
      
    
    
    
    <category term="其他" scheme="https://zcej.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux常用命令之--sar</title>
    <link href="https://zcej.github.io/2022/09/28/%E5%85%B6%E4%BB%96/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B9%8B%E2%80%94%E2%80%94sar/"/>
    <id>https://zcej.github.io/2022/09/28/%E5%85%B6%E4%BB%96/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B9%8B%E2%80%94%E2%80%94sar/</id>
    <published>2022-09-28T11:53:13.000Z</published>
    <updated>2023-02-05T16:50:05.252Z</updated>
    
    <content type="html"><![CDATA[<p>sar(system activity reporter 系统活动情况报告)，用于提取在一段时间内系统的性能分析报告，包括：文件的读写情况，系统调用的使用情况，磁盘I&#x2F;O，CPU效率，内存使用状况，进程活动及IPC有关的活动。</p><h3 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h3><ol><li><code>yum install sysstat</code>&#x2F;<code>apt-get install sysstat</code></li><li>修改文件<code>/etc/default/sysstat</code>中的内容为<code>ENANBLED=&quot;true&quot;</code></li><li>重启服务<code>systemctl restart sysstat</code><h3 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h3><code>sar -h</code>的输出见下，使用方式及参数说明都挺直观。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">Usage: sar [ options ] [ &lt;interval&gt; [ &lt;count&gt; ] ]</span><br><span class="line">Main options and reports:</span><br><span class="line">        -b      I/O and transfer rate statistics</span><br><span class="line">        -B      Paging statistics</span><br><span class="line">        -d      Block device statistics</span><br><span class="line">        -F [ MOUNT ]</span><br><span class="line">                Filesystems statistics</span><br><span class="line">        -H      Hugepages utilization statistics</span><br><span class="line">        -I &#123; &lt;int&gt; | SUM | ALL | XALL &#125;</span><br><span class="line">                Interrupts statistics</span><br><span class="line">        -m &#123; &lt;keyword&gt; [,...] | ALL &#125;</span><br><span class="line">                Power management statistics</span><br><span class="line">                Keywords are:</span><br><span class="line">                CPU     CPU instantaneous clock frequency</span><br><span class="line">                FAN     Fans speed</span><br><span class="line">                FREQ    CPU average clock frequency</span><br><span class="line">                IN      Voltage inputs</span><br><span class="line">                TEMP    Devices temperature</span><br><span class="line">                USB     USB devices plugged into the system</span><br><span class="line">        -n &#123; &lt;keyword&gt; [,...] | ALL &#125;</span><br><span class="line">                Network statistics</span><br><span class="line">                Keywords are:</span><br><span class="line">                DEV     Network interfaces</span><br><span class="line">                EDEV    Network interfaces (errors)</span><br><span class="line">                NFS     NFS client</span><br><span class="line">                NFSD    NFS server</span><br><span class="line">                SOCK    Sockets (v4)</span><br><span class="line">                IP      IP traffic      (v4)</span><br><span class="line">                EIP     IP traffic      (v4) (errors)</span><br><span class="line">                ICMP    ICMP traffic    (v4)</span><br><span class="line">                EICMP   ICMP traffic    (v4) (errors)</span><br><span class="line">                TCP     TCP traffic     (v4)</span><br><span class="line">                ETCP    TCP traffic     (v4) (errors)</span><br><span class="line">                UDP     UDP traffic     (v4)</span><br><span class="line">                SOCK6   Sockets (v6)</span><br><span class="line">                IP6     IP traffic      (v6)</span><br><span class="line">                EIP6    IP traffic      (v6) (errors)</span><br><span class="line">                ICMP6   ICMP traffic    (v6)</span><br><span class="line">                EICMP6  ICMP traffic    (v6) (errors)</span><br><span class="line">                UDP6    UDP traffic     (v6)</span><br><span class="line">        -q      Queue length and load average statistics</span><br><span class="line">        -r      Memory utilization statistics</span><br><span class="line">        -R      Memory statistics</span><br><span class="line">        -S      Swap space utilization statistics</span><br><span class="line">        -u [ ALL ]</span><br><span class="line">                CPU utilization statistics</span><br><span class="line">        -v      Kernel table statistics</span><br><span class="line">        -w      Task creation and system switching statistics</span><br><span class="line">        -W      Swapping statistics</span><br><span class="line">        -y      TTY device statistics</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="查看CPU使用率"><a href="#查看CPU使用率" class="headerlink" title="查看CPU使用率"></a>查看CPU使用率</h4><code>sar 1 3</code>默认显示的是cpu使用率信息，等同于<code>sar -u 1 3</code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Linux 4.15.0-173-generic (zw)   10/03/2022      _x86_64_        (16 CPU)</span><br><span class="line"></span><br><span class="line">08:07:19 AM     CPU     %user     %<span class="built_in">nice</span>   %system   %iowait    %steal     %idle</span><br><span class="line">08:07:20 AM     all     17.87      0.00      2.05      0.00      0.00     80.07</span><br><span class="line">08:07:21 AM     all     15.10      0.00      0.94      0.00      0.00     83.96</span><br><span class="line">08:07:22 AM     all     16.56      0.00      1.69      0.00      0.00     81.74</span><br><span class="line">Average:        all     16.51      0.00      1.56      0.00      0.00     81.92</span><br></pre></td></tr></table></figure></li></ol><ul><li>%user：用户模式下消耗的CPU时间比例</li><li>%nice：通过nice改变了进程调度优先级的进程，在用户模式下消耗的CPU时间比例</li><li>%system：系统模式下消耗的CPU时间比例</li><li>%iowait：CPU等待磁盘I&#x2F;O导致空闲状态消耗的时间比例</li><li>%steal：利用xen等操作系统虚拟化技术，等待其他虚拟CPU计算占用的时间比例</li><li>%idle：CPU空闲时间比例<blockquote><ol><li>若%iowait的值过高，表示磁盘存在I&#x2F;O瓶颈</li><li>若%idle的值高但系统响应慢时，可能是CPU等待分配内存，此时应加大内存容量</li><li>若%idle的值持续低于1，则系统CPU的处理能力相对较低，考虑CPU的资源</li></ol></blockquote></li></ul><h4 id="I-x2F-O和传输速率统计"><a href="#I-x2F-O和传输速率统计" class="headerlink" title="I&#x2F;O和传输速率统计"></a>I&#x2F;O和传输速率统计</h4><p><code>sar -b 1 3</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Linux 4.15.0-173-generic (zw)   10/03/2022      _x86_64_        (16 CPU)</span><br><span class="line"></span><br><span class="line">08:20:24 AM       tps      rtps      wtps   bread/s   bwrtn/s</span><br><span class="line">08:20:25 AM      6.00      0.00      6.00      0.00     80.00</span><br><span class="line">08:20:26 AM      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">08:20:27 AM      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">Average:         2.00      0.00      2.00      0.00     26.67</span><br></pre></td></tr></table></figure><ul><li><p>tps：每秒钟物理设备的I&#x2F;O传输总量</p></li><li><p>rtps：每秒钟从物理设备读入的数据总量</p></li><li><p>wtps：每秒钟向物理设备写入的数据总量</p></li><li><p>bread&#x2F;s：每秒钟从物理设备读入的数据量，单位为：块&#x2F;s</p></li><li><p>bwrtn&#x2F;s：每秒钟向物理设备写入的数据量，单位为：块&#x2F;s</p><h4 id="内存利用率"><a href="#内存利用率" class="headerlink" title="内存利用率"></a>内存利用率</h4><p><code>sar -r 1 3</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Linux 4.15.0-173-generic (zw)   10/03/2022      _x86_64_        (16 CPU)</span><br><span class="line"></span><br><span class="line">08:27:46 AM kbmemfree   kbavail kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty</span><br><span class="line">08:27:47 AM   3897560  65082240  94987480     96.06  11224640  47914160 120160988    120.74  40025904  50646580      1808</span><br><span class="line">08:27:48 AM   3404600  64589496  95480440     96.56  11224640  47914440 120226200    120.81  40517296  50646796      2084</span><br><span class="line">08:27:49 AM   3465888  64650784  95419152     96.50  11224640  47914440 120163888    120.74  40456772  50646796      2084</span><br><span class="line">Average:      3589349  64774173  95295691     96.37  11224640  47914347 120183692    120.76  40333324  50646724      1992</span><br></pre></td></tr></table></figure></li><li><p>kbmemfree：基本等同于<code>free</code>中的值free，不包括buffer和cache的空间</p></li><li><p>kbmemused：基本等同于<code>free</code>中的值used，包括buffer和cache的空间</p></li><li><p>%memused：物理内存总量，是kbmemused和内存总量的(不包括swap)的百分比</p></li><li><p>kbbuffers和kbcached：就是<code>free</code>中的buffer和cache</p></li><li><p>kbcommit：保证当前系统所需的内存，即为了确保不溢出而需要的内存(RAM + swap)</p></li><li><p>%commit：是kbcommit与内存总量(包括swap)的百分比</p><h3 id="排查技巧"><a href="#排查技巧" class="headerlink" title="排查技巧"></a>排查技巧</h3></li><li><p>怀疑CPU存在瓶颈，可用<code>sar -u</code>和<code>sar -q</code>等查看</p></li><li><p>怀疑内存存在瓶颈，可用<code>sar -B</code>、<code>sar -r</code>和<code>sar -W</code>等查看</p></li><li><p>怀疑I&#x2F;O存在瓶颈，可用<code>sar -b</code>、<code>sar -u</code>和<code>sar -d</code>等查看</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;sar(system activity reporter 系统活动情况报告)，用于提取在一段时间内系统的性能分析报告，包括：文件的读写情况，系统调用的使用情况，磁盘I&amp;#x2F;O，CPU效率，内存使用状况，进程活动及IPC有关的活动。&lt;/p&gt;
&lt;h3 id=&quot;安装使用&quot;&gt;</summary>
      
    
    
    
    <category term="其他" scheme="https://zcej.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>Django Admin自定义按钮取消强制选择对象</title>
    <link href="https://zcej.github.io/2022/09/11/django/Django%20Admin%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%89%E9%92%AE%E5%8F%96%E6%B6%88%E5%BC%BA%E5%88%B6%E9%80%89%E6%8B%A9%E5%AF%B9%E8%B1%A1/"/>
    <id>https://zcej.github.io/2022/09/11/django/Django%20Admin%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%89%E9%92%AE%E5%8F%96%E6%B6%88%E5%BC%BA%E5%88%B6%E9%80%89%E6%8B%A9%E5%AF%B9%E8%B1%A1/</id>
    <published>2022-09-11T14:03:11.000Z</published>
    <updated>2023-02-05T16:12:28.224Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>当创建自定义按钮，点击时默认至少需要选择一个选项。若要取消该选择，当只使用django原生admin的时候只需要重写<code>changelist_view</code>即可，而若使用了其他组件如simpleui时，则还需要修改其他东西。本文记录在使用了simpleui的情况下，如何取消点击自定义按钮时的强制选择。</p></blockquote><h2 id="1-默认情况下创建自定义按钮如下"><a href="#1-默认情况下创建自定义按钮如下" class="headerlink" title="1. 默认情况下创建自定义按钮如下"></a>1. 默认情况下创建自定义按钮如下</h2><img src="/2022/09/11/django/Django%20Admin%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%89%E9%92%AE%E5%8F%96%E6%B6%88%E5%BC%BA%E5%88%B6%E9%80%89%E6%8B%A9%E5%AF%B9%E8%B1%A1/django_admin.png" class="" title="django_admin"><h2 id="2-修改simpleui的actions-html"><a href="#2-修改simpleui的actions-html" class="headerlink" title="2. 修改simpleui的actions.html"></a>2. 修改simpleui的<code>actions.html</code></h2><p>路径如下：<br><code>\venv\Lib\site-packages\simpleui\templates\admin\actions.html</code><br>来到第413行，可能因simpleui版本不同而具体行数不一样，添加修改后如下：</p><blockquote><p>这里只是加了一个判断，自定义按钮的名字以<code>fc_</code>开头的话则直接调用点击事件</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TODO 需要做国际化</span></span><br><span class="line"><span class="keyword">if</span> (data_name.<span class="title function_">substr</span>(<span class="number">0</span>, <span class="number">3</span>) == <span class="string">&quot;fc_&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 强制运行，不用选择数据，按钮名data_name必须以&quot;fc_&quot;开头</span></span><br><span class="line">    done.<span class="title function_">call</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (checkbox_checked == <span class="number">0</span> &amp;&amp; data_name != <span class="string">&quot;add_item&quot;</span> &amp;&amp; !_action.<span class="property">customButton</span>[data_name].<span class="property">action_url</span>) &#123;</span><br><span class="line">    _vue.$alert(<span class="title function_">getLanuage</span>(<span class="string">&quot;Please select at least one option!&quot;</span>), <span class="string">&#x27;&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;warning&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (confirm) &#123;</span><br><span class="line">    _vue.$confirm(confirm, <span class="string">&#x27;提示&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">confirmButtonText</span>: <span class="string">&#x27;确定&#x27;</span>,</span><br><span class="line">        <span class="attr">cancelButtonText</span>: <span class="string">&#x27;取消&#x27;</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;warning&#x27;</span></span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> done.<span class="title function_">call</span>(<span class="variable language_">this</span>));</span><br><span class="line">  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    done.<span class="title function_">call</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-重写changelist-view方法"><a href="#3-重写changelist-view方法" class="headerlink" title="3. 重写changelist_view方法"></a>3. 重写<code>changelist_view</code>方法</h2><p>首先按钮定义如下，为一个简单的跳转操作，需要注意新增了一个动态属性<code>acts_on_all</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fc_prev</span>(<span class="params">self, request, queryset</span>):</span><br><span class="line">    <span class="keyword">return</span> HttpResponseRedirect(<span class="string">&quot;/admin/data/querytask/&quot;</span>)</span><br><span class="line">fc_prev.short_description = <span class="string">&quot;返回查询任务页&quot;</span></span><br><span class="line">fc_prev.<span class="built_in">type</span> = <span class="string">&quot;primary&quot;</span></span><br><span class="line">fc_prev.acts_on_all = <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>然后重写<code>changelist_view</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">changelist_view</span>(<span class="params">self, request, extra_context=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        action = self.get_actions(request)[request.POST[<span class="string">&quot;action&quot;</span>]][<span class="number">0</span>]</span><br><span class="line">        action_acts_on_all = action.acts_on_all</span><br><span class="line">    <span class="keyword">except</span> (KeyError, AttributeError):</span><br><span class="line">        action_acts_on_all = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> action_acts_on_all:</span><br><span class="line">        post = request.POST.copy()</span><br><span class="line">        post.setlist(ACTION_CHECKBOX_NAME, self.model.objects.<span class="built_in">all</span>()[:<span class="number">1</span>].values_list(<span class="string">&quot;id&quot;</span>, flat=<span class="literal">True</span>))</span><br><span class="line">        request.POST = post</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>(MscHuaHistoryAdmin, self).changelist_view(request, extra_context)</span><br></pre></td></tr></table></figure><p>到此，已经实现了取消自定义按钮强制选择对象的情况了，代码比较简单，主要也是参考了Stack Overflow上的回答，链接如下。</p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2><p><a href="https://stackoverflow.com/questions/4500924/django-admin-action-without-selecting-objects">https://stackoverflow.com/questions/4500924/django-admin-action-without-selecting-objects</a><br><a href="https://blog.csdn.net/qq_42761569/article/details/121495074">https://blog.csdn.net/qq_42761569&#x2F;article&#x2F;details&#x2F;121495074</a><br><a href="https://gitee.com/bode135/bddjango/blob/master/bddjango/adminclass">https://gitee.com/bode135/bddjango/blob/master/bddjango/adminclass</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;当创建自定义按钮，点击时默认至少需要选择一个选项。若要取消该选择，当只使用django原生admin的时候只需要重写&lt;code&gt;changelist_view&lt;/code&gt;即可，而若使用了其他组件如simpleui时，则还需要修改其他东西。本文记录</summary>
      
    
    
    
    <category term="django" scheme="https://zcej.github.io/categories/django/"/>
    
    
  </entry>
  
  <entry>
    <title>Django静态文件404</title>
    <link href="https://zcej.github.io/2022/09/03/django/Django%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6404/"/>
    <id>https://zcej.github.io/2022/09/03/django/Django%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6404/</id>
    <published>2022-09-03T05:46:51.000Z</published>
    <updated>2023-01-30T15:40:16.969Z</updated>
    
    <content type="html"><![CDATA[<p>首先明白一点，在django中把<code>debug</code>改为<code>false</code>的话，django将不再为我们处理静态文件，我们需要使用web服务器进行代理静态资源，这时就需要去设置静态文件的路径，下面介绍如何设置</p><blockquote><p>注：可以参考Stack Overflow上的回答<br><a href="https://stackoverflow.com/questions/5836674/why-does-debug-false-setting-make-my-django-static-files-access-fail">https://stackoverflow.com/questions/5836674/why-does-debug-false-setting-make-my-django-static-files-access-fail</a></p></blockquote><h3 id="1-settings修改"><a href="#1-settings修改" class="headerlink" title="1. settings修改"></a>1. settings修改</h3><p>新增静态文件目录配置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STATIC_ROOT = os.path.join(BASE_DIR, <span class="string">&#x27;static&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="2-静态文件收集"><a href="#2-静态文件收集" class="headerlink" title="2. 静态文件收集"></a>2. 静态文件收集</h3><p>执行下述命令，将静态文件会收集到第一步设置的目录中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py collectstatic</span><br></pre></td></tr></table></figure><h3 id="3-配置路由url"><a href="#3-配置路由url" class="headerlink" title="3. 配置路由url"></a>3. 配置路由url</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.views <span class="keyword">import</span> static</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> re_path</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    re_path(<span class="string">&#x27;^static/(?P&lt;path&gt;.*)&#x27;</span>, static.serve, &#123;<span class="string">&#x27;document_root&#x27;</span>: settings.STATIC_ROOT&#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="4-web服务器配置"><a href="#4-web服务器配置" class="headerlink" title="4. web服务器配置"></a>4. web服务器配置</h3><p>下面简单给出nginx的配置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /static &#123;</span><br><span class="line">  <span class="attribute">alias</span> /data/wwwroot/project/static;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先明白一点，在django中把&lt;code&gt;debug&lt;/code&gt;改为&lt;code&gt;false&lt;/code&gt;的话，django将不再为我们处理静态文件，我们需要使用web服务器进行代理静态资源，这时就需要去设置静态文件的路径，下面介绍如何设置&lt;/p&gt;
&lt;blockquote</summary>
      
    
    
    
    <category term="django" scheme="https://zcej.github.io/categories/django/"/>
    
    
  </entry>
  
  <entry>
    <title>Django中QuerySet的两大特性</title>
    <link href="https://zcej.github.io/2022/08/30/django/Django%E4%B8%ADQuerySet%E7%9A%84%E4%B8%A4%E5%A4%A7%E7%89%B9%E6%80%A7/"/>
    <id>https://zcej.github.io/2022/08/30/django/Django%E4%B8%ADQuerySet%E7%9A%84%E4%B8%A4%E5%A4%A7%E7%89%B9%E6%80%A7/</id>
    <published>2022-08-30T12:08:33.000Z</published>
    <updated>2023-01-30T15:36:51.880Z</updated>
    
    <content type="html"><![CDATA[<h2 id="查询集"><a href="#查询集" class="headerlink" title="查询集"></a>查询集</h2><p>查询集也称查询结果集，QuerySet，表示从数据库中获取的对象集合，在管理器上调用某些过滤器方法会返回查询集，查询集可以含有零个，一个或多个过滤器。<br>当调用如下过滤器方法时，Django会返回查询集(而不是简单的列表)：</p><ul><li>all()：返回所有数据</li><li>filter()：返回满足条件的数据</li><li>exclude()：返回满足条件之外的数据</li><li>order_by()：对结果进行排序</li></ul><p>返回单个值的过滤器如下：</p><ul><li>get()：返回单个满足条件的对象<ul><li>若未找到会抛出<code>DoesNotExist</code>异常</li><li>若找到多条会抛出<code>MultipleObjectsReturned</code>异常</li></ul></li><li>count()：返回当前查询结果的总条数</li><li>aggregate()：聚合，返回一个字典</li></ul><blockquote><p>注：判断某一个查询集中是否有数据可以使用<code>exists()</code>方法，有则返回True，反之返回False</p></blockquote><h2 id="两大特性"><a href="#两大特性" class="headerlink" title="两大特性"></a>两大特性</h2><ul><li><p>惰性执行：创建查询集不会访问数据库，直到用数据时，才会访问数据库，调用数据的情况包括迭代、序列化、与if合用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行下面的语句数据库并不会进行查询</span></span><br><span class="line">books = BookInfo.objects.<span class="built_in">all</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只有当真正使用时，才会真正去数据库进行查询</span></span><br><span class="line"><span class="keyword">for</span> b <span class="keyword">in</span> books:</span><br><span class="line">    <span class="built_in">print</span>(b)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>缓存：使用同一个查询集，第一次使用时会发生数据库的查询，然后把结果缓存下来，再次使用查询集时会使用缓存的数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进行数据库实际查询遍历，保存结果到books，会进行数据库实际交互</span></span><br><span class="line">books = [b.<span class="built_in">id</span> <span class="keyword">for</span> b <span class="keyword">in</span> BookInfo.objects.<span class="built_in">all</span>()]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次调用books，不再进行数据库查询，而是使用缓存结果</span></span><br><span class="line"><span class="built_in">print</span>(books)</span><br></pre></td></tr></table></figure><blockquote><p>注：对查询集进行取下标或切片操作，等同于sql中的limit和offset</p></blockquote></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;查询集&quot;&gt;&lt;a href=&quot;#查询集&quot; class=&quot;headerlink&quot; title=&quot;查询集&quot;&gt;&lt;/a&gt;查询集&lt;/h2&gt;&lt;p&gt;查询集也称查询结果集，QuerySet，表示从数据库中获取的对象集合，在管理器上调用某些过滤器方法会返回查询集，查询集可以含有零个，</summary>
      
    
    
    
    <category term="django" scheme="https://zcej.github.io/categories/django/"/>
    
    
  </entry>
  
  <entry>
    <title>SSL_TLS相关内容梳理</title>
    <link href="https://zcej.github.io/2022/08/14/%E5%85%B6%E4%BB%96/SSL_TLS%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%E6%A2%B3%E7%90%86/"/>
    <id>https://zcej.github.io/2022/08/14/%E5%85%B6%E4%BB%96/SSL_TLS%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%E6%A2%B3%E7%90%86/</id>
    <published>2022-08-14T02:21:02.000Z</published>
    <updated>2023-01-29T12:51:56.522Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>证书文件格式说明：</p><ul><li>.key：私钥文件，通常使用rsa算法，私钥需要自己保存，无需提交给ca机构</li><li>.crt：证书文件，certificate的缩写</li><li>.csr：证书签名请求(证书请求文件)，含有公钥信息</li><li>.crl：证书吊销列表</li><li>.pem：用于导出，导入证书时候的证书格式，是.key和.crt的合体</li></ul></blockquote><h3 id="Q：什么是数字签名，有什么作用？"><a href="#Q：什么是数字签名，有什么作用？" class="headerlink" title="Q：什么是数字签名，有什么作用？"></a>Q：什么是数字签名，有什么作用？</h3><p>作用：验证消息的来源，以及证明消息是否被篡改</p><p>签名：用私钥对消息的哈希值进行加密称为签名，<strong>只有拥有私钥的用户可以生成签名</strong></p><blockquote><p><strong>生成签名的步骤：</strong></p><ol><li>对消息进行哈希计算，得到哈希值</li><li>利用私钥对哈希值进行加密，生成签名</li><li>将签名附加在消息后面，一起发送过去</li></ol></blockquote><p>验证签名：用公钥解密签名这一步称为验证签名，所有用户都可以验证签名（因为公钥是公开的）</p><blockquote><p><strong>验证签名的步骤：</strong></p><ol><li>收到消息后，提取消息中的签名</li><li>用公钥对签名进行解密，得到哈希值1</li><li>对消息中的正文进行哈希计算，得到哈希值2</li><li>比较哈希值1和哈希值2，如果相同，则验证成功</li></ol></blockquote><h3 id="Q：什么是证书，如何验证证书？"><a href="#Q：什么是证书，如何验证证书？" class="headerlink" title="Q：什么是证书，如何验证证书？"></a>Q：什么是证书，如何验证证书？</h3><p>证书：实际上就是公钥的数字签名，是对公钥合法性提供证明的技术。它包括公钥本身，公钥的数字签名，公钥拥有者的信息等等。</p><blockquote><p><strong>生成证书的步骤：</strong></p><ol><li>服务器将公钥A给CA（公钥是服务器的）</li><li>CA用自己的私钥B给公钥A加密，生成数字签名A</li><li>CA把公钥A，数字签名A，附加一些服务器信息整合在一起，生成证书，发回给服务器</li></ol></blockquote><p>注：私钥B是用于加密公钥A的，私钥B和公钥A并不是配对的</p><p>验证证书的数字签名需要另一个公钥，保证这个公钥的合法性则需要第三方认证机构，即CA。CA能够认定公钥确实属于此人，并能生成公钥的数字签名。CA有国际性组织和政府设立的组织，也有通过提供认证服务来盈利的组织。</p><blockquote><p><strong>验证证书的步骤：</strong></p><ol><li>客户端得到证书</li><li>客户端得到证书的公钥B（通过CA或其他途径）</li><li>客户端用公钥B对证书中的数字签名解密，得到哈希值</li><li>客户端对公钥进行哈希计算</li><li>两个哈希值对比，如果相同，则证书合法</li></ol></blockquote><p>注：公钥B和上述的私钥B是配对的，分别用于对证书的验证（解密）和生成（加密）</p><p>另外，当用户私钥丢失，被盗时，认证机构需要对证书进行作废。要作废证书，认证机构需要制作一张证书作废清单（Certificate Revocation List），检查CRL。我们在验证证书的合法性时，除了验证其是否在有效期内，还需要查询其CRL，确认证书是否有效。</p><h3 id="Q：单向认证-amp-双向认证-amp-不认证"><a href="#Q：单向认证-amp-双向认证-amp-不认证" class="headerlink" title="Q：单向认证 &amp; 双向认证 &amp; 不认证"></a>Q：单向认证 &amp; 双向认证 &amp; 不认证</h3><ul><li>单向认证：指的是只有一个对象校验对端的整数合法性，通常是客户端来校验服务器的合法性。那么client需要一个ca.crt，服务端需要server.crt、server.key，当然也可以是服务端校验客户端。</li><li>双向认证：指的是相互校验，服务器需要校验每个client证书，client也需要校验服务器证书</li><li>不认证：指的是不相互校验证书，但仍然使用TLS连接<h3 id="Q：单向认证流程？"><a href="#Q：单向认证流程？" class="headerlink" title="Q：单向认证流程？"></a>Q：单向认证流程？</h3></li></ul><ol><li>client_hello：客户端发起请求，以明文传输请求信息，包含版本信息，加密套件候选列表，压缩算法候选列表，随机数，扩展字段等信息</li><li>server_hello + server_certificate + server_hello_done<ol><li>server_hello，服务端返回协商的信息结果，包括选择使用的协议版本version，选择的加密套件cipher suite，选择的压缩算法compression method、随机数random_S等，其中随机数用于后续的密钥协商</li><li>server_certificates，服务端配置对应的证书链，用于身份验证与密钥交换</li><li>server_hello_done，通知客户端server_hello信息发送结束</li></ol></li><li>证书校验<ol><li>证书&#x2F;证书链的可信性</li><li>证书是否吊销revocation，有两类方式离线CRL与在线OCSP，不同客户端行为不同</li><li>有效期expire date，证书是否在有效时间范围</li><li>域名damain，检查证书域名是否与当前的访问域名匹配(CN字段)</li></ol></li><li>client_key_exchange + change_cipher_spec + encrypted_handshake_message<ol><li>client_key_exchange：合法性验证通过之后，客户端计算产生随机数字pre-master，并用证书公钥加密，发送给服务器</li><li>此时客户端已经获取全部的计算协商密钥需要的信息：两个明文随机数random_C和random_S与自己计算产生的pre-master，计算得到协商密钥<code>enc_key=Func(...)</code></li><li>change_cipher_spec：客户端通知服务器后续的通信都采用协商的通信密钥和加密算法进行加密通信</li><li>encrypted_handshake_message：结合之前所有通信参数的hash值与其他相关信息生成一段数据，采用协商密钥session secret与算法进行加密，然后发送给服务器用于数据与握手验证</li></ol></li><li>change_cipher_spec + encrypted_handshake_message<ol><li>服务器用私钥解密加密的pre-master数据，基于之前交换的两个明文随机数random_C和random_S，计算得到协商密钥<code>enc_key=Func(...)</code></li><li>计算之前所有接收信息的哈希值，然后解密客户端发送的change_cipher_spec以告知客户端后续的通信都采用协商的密钥与算法进行加密通信</li><li>change_cipher_spec，验证通过之后，服务器同样发送change_cipher_spec以告知客户端后续的通信都采用协商的密钥与算法进行加密通信</li><li>encrypted_handshake_message，服务器也结合所有当前的通信参数信息生成一段数据并采用协商密钥session secret与算法加密并发送到客户端</li></ol></li><li>握手结束：客户端计算所有接收信息的哈希值，并采用协商密钥解密encrypted_handshake_message，验证服务器发送的数据和密钥，验证通过则握手完成</li><li>加密通信：开始使用协商密钥与算法进行加密通信</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;证书文件格式说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;.key：私钥文件，通常使用rsa算法，私钥需要自己保存，无需提交给ca机构&lt;/li&gt;
&lt;li&gt;.crt：证书文件，certificate的缩写&lt;/li&gt;
&lt;li&gt;.csr：证书签名请求(证书请求文件)</summary>
      
    
    
    
    <category term="其他" scheme="https://zcej.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>gRPC如何做身份认证？</title>
    <link href="https://zcej.github.io/2022/08/10/grpc/gRPC%E5%A6%82%E4%BD%95%E5%81%9A%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%EF%BC%9F/"/>
    <id>https://zcej.github.io/2022/08/10/grpc/gRPC%E5%A6%82%E4%BD%95%E5%81%9A%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%EF%BC%9F/</id>
    <published>2022-08-10T14:05:51.000Z</published>
    <updated>2022-10-10T14:07:46.851Z</updated>
    
    <content type="html"><![CDATA[<p>当上线gRPC服务到生产环境的时候，首先需要考虑的就是数据的安全，那么如何保证呢，下面以python为例，进行简单介绍。</p><h2 id="RPC的认证方式"><a href="#RPC的认证方式" class="headerlink" title="RPC的认证方式"></a>RPC的认证方式</h2><p>RPC服务一般在服务内网使用，不过也有存在于外网的情况，不论是哪种RPC服务，走http2.0或是其他基于TCP实现socket的协议，在部署到生产环境的时候还是需要考虑身份认证加密的，以此来保证数据的安全。</p><h3 id="基于SSL-x2F-TLS的通道加密"><a href="#基于SSL-x2F-TLS的通道加密" class="headerlink" title="基于SSL&#x2F;TLS的通道加密"></a>基于SSL&#x2F;TLS的通道加密</h3><p>通常身份认证机制是通过SSL&#x2F;TLS对传输通道加密，以防止请求和响应消息中的敏感数据泄露。使用的场景主要有三种：</p><ul><li>后端微服务直接开放给端侧，例如手机app、tv、多屏等，没有统一的API Gateway&#x2F;SLB做安全接入和认证</li><li>后端微服务直接开放给DMZ部署的管理或者运维类Portal</li><li>后端微服务直接开放给第三方合作伙伴&#x2F;渠道</li></ul><p>除了上述常用的跨网络场景之外，对于一些安全等级要求比较高的业务场景，即便是内网通信，只要跨主机&#x2F;VM&#x2F;容器等，都强制要求对传输通道进行加密。在该场景下，即便只存在内网各模块的RPC调用，仍然需要进行加密。<br>针对敏感数据的单独加密<br>有些RPC调用并不涉及敏感数据的传输，或者敏感字段占比较低，为了最大程度的提升吞吐量，降低调用时延，通常会采用HTTP&#x2F;TCP+敏感字段单独加密的方式。既保证了敏感信息的传输安全，同时也降低了采用SSL&#x2F;TLS加密通道带来的性能损耗，对于JDK原生的SSL类库，这种性能提升尤为明显。</p><h3 id="采用该方案主要有两个缺点："><a href="#采用该方案主要有两个缺点：" class="headerlink" title="采用该方案主要有两个缺点："></a>采用该方案主要有两个缺点：</h3><ul><li>对敏感信息的识别可能存在偏差，容易遗漏或者过度保护，需要解读数据和隐私保护方面的法律法规，而且不同国家对敏感数据的定义也不同，这会为识别带来很多困难。</li><li>接口升级时容易遗漏，例如开发新增字段，忘记识别是否未敏感数据。</li></ul><h2 id="gRPC认证的的具体流程"><a href="#gRPC认证的的具体流程" class="headerlink" title="gRPC认证的的具体流程"></a>gRPC认证的的具体流程</h2><p>对于gRPC，SSL&#x2F;TLS协议也是基本的身份加密认证方法，SSL&#x2F;TLS协议采用公钥加密，客户端向服务端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。<br>SSL&#x2F;TLS分为单向认证和双向认证，在实际业务中，单向认证使用较多，即客户端认证服务端，服务端不认证客户端，认证流程如下：</p><ul><li>客户端向服务端传送客户端SSL协议的版本号，支持的加密算法种类，产生的随机数，以及其他可选信息</li><li>服务端返回握手应答，向客户端传送确认SSL协议的版本号、加密算法的种类、随机数以及其他相关信息</li><li>服务端向客户端发送自己的公钥</li><li>客户端对服务端的证书进行认证，服务端的合法性校验包括：证书是否过期、发行服务器证书的CA是否可靠、发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”、服务器证书上的域名是否和服务器的实际域名相匹配等</li><li>客户端随机生成一个用于后面通讯的“对称密码”，然后用服务端的公钥对其加密，将加密后的“预主密码”传给服务端</li><li>服务端用自己的私钥解开加密的“预主密码”，然后执行一系列步骤来产生主密码</li><li>客户端向服务端发出信息，指明后面的数据通讯将使用主密码为对称密钥，同时通知服务器客户端的握手过程结束</li><li>服务端向客户端发出信息，指明后面的数据通讯将使用主密码为对称密钥，同时通知客户端服务端的握手过程结束</li><li>SSL的握手部分结束，SSL安全通道简历，客户端和服务端开始使用相同的对称密钥对数据进行加密，然后通过socket进行传输</li></ul><h2 id="具体示例"><a href="#具体示例" class="headerlink" title="具体示例"></a>具体示例</h2><h3 id="生成证书"><a href="#生成证书" class="headerlink" title="生成证书"></a>生成证书</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -newkey rsa:2048 -nodes -keyout server.key -x509 -days 3650 -out server.crt</span><br></pre></td></tr></table></figure><p>在执行生成证书的过程中，需要填入<code>Country Name</code>、<code>State or Province Name</code>、<code>Locality Name</code>、<code>Organization Name</code>、<code>Organization Unit Name</code>、<code>Common Name</code>、<code>Email Address</code>等等，这些可以按需填入，或者留空也行。</p><blockquote><p>注：其中的<code>Common Name</code>支持在客户端连接的时候指定连接的名字，可以自己定义之后填上，否则留空的话可能自动获取不到</p></blockquote><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>下面模拟一个任务的grpc调用，服务端将流式响应任务的进度信息<br><code>proto</code>定义如下：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">service </span><span class="title class_">Task</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> StartScan(TaskInfoRequest) <span class="keyword">returns</span>(stream CommonResponse)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">TaskInfoRequest</span> &#123;</span><br><span class="line">    <span class="type">string</span> task_id = <span class="number">1</span>;</span><br><span class="line">    <span class="type">string</span> data = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">CommonResponse</span> &#123;</span><br><span class="line">    <span class="type">int32</span> code = <span class="number">1</span>;</span><br><span class="line">    <span class="type">string</span> msg = <span class="number">2</span>;</span><br><span class="line">    <span class="type">string</span> progress = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：执行下述命令生成python的proto序列化协议源代码<br><code>python -m grpc_tools.protoc --python_out=. --grpc_python_out=. -I. task.proto</code></p></blockquote><p>服务端代码<code>server.py</code>如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> grpc</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> proto <span class="keyword">import</span> task_pb2, task_pb2_grpc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskServicer</span>(task_pb2_grpc.TaskServicer):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">StartScan</span>(<span class="params">self, request, context</span>):</span><br><span class="line">        progress = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> progress &lt; <span class="number">100</span>:</span><br><span class="line">            resp = &#123;</span><br><span class="line">                <span class="string">&quot;code&quot;</span>: <span class="number">200</span>,</span><br><span class="line">                <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;succeed&quot;</span>,</span><br><span class="line">                <span class="string">&quot;progress&quot;</span>: <span class="built_in">str</span>(progress)</span><br><span class="line">            &#125;</span><br><span class="line">            feature = task_pb2.CommonResponse(**resp)</span><br><span class="line">            tmp = random.randint(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">            progress += tmp</span><br><span class="line">            time.sleep(<span class="number">5</span>)</span><br><span class="line">            <span class="keyword">yield</span> feature</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">serve</span>():</span><br><span class="line">    server = grpc.server(futures.ThreadPoolExecutor(max_workers=<span class="number">10</span>), options=[</span><br><span class="line">        <span class="comment"># (&quot;grpc.max_send_message_length&quot;, 100 * 1024 * 1024),</span></span><br><span class="line">        <span class="comment"># (&quot;grpc.max_receive_message_length&quot;, 100 * 1024 * 1024)</span></span><br><span class="line">    ])</span><br><span class="line">    task_pb2_grpc.add_TaskServicer_to_server(TaskServicer(), server)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./server.key&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        private_key = f.read()</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./server.crt&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        certificate_chain = f.read()</span><br><span class="line"></span><br><span class="line">    server_credentials = grpc.ssl_server_credentials(((private_key, certificate_chain), ))</span><br><span class="line">    server.add_secure_port(<span class="string">&quot;[::]:50051&quot;</span>, server_credentials)</span><br><span class="line"></span><br><span class="line">    server.start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;gRPC服务端已开启，端口为50051...&quot;</span>)</span><br><span class="line">    server.wait_for_termination()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    serve()</span><br></pre></td></tr></table></figure><p>客户端代码<code>client.py</code>如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> grpc</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> proto <span class="keyword">import</span> task_pb2, task_pb2_grpc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_progress</span>(<span class="params">*host</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;server.crt&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        trusted_certs = f.read()</span><br><span class="line">    credentials = grpc.ssl_channel_credentials(root_certificates=trusted_certs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> grpc.secure_channel(<span class="string">&quot;localhost:50001&quot;</span>, credentials) <span class="keyword">as</span> channel:</span><br><span class="line">        stub = task_pb2_grpc.TaskStub(channel)</span><br><span class="line">        req = &#123;</span><br><span class="line">            <span class="string">&quot;task_id&quot;</span>: <span class="string">&quot;24dsad&quot;</span>,</span><br><span class="line">            <span class="string">&quot;data&quot;</span>: <span class="string">&quot;12&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        features = stub.StartScan(task_pb2.TaskInfoRequest(**req))</span><br><span class="line">        <span class="keyword">for</span> feature <span class="keyword">in</span> features:</span><br><span class="line">            <span class="built_in">print</span>(feature.progress)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>():</span><br><span class="line">    <span class="keyword">with</span> grpc.insecure_channel(<span class="string">&quot;localhost:50001&quot;</span>) <span class="keyword">as</span> channel:</span><br><span class="line">        stub = task_pb2_grpc.TaskStub(channel)</span><br><span class="line">        req = &#123;</span><br><span class="line">            <span class="string">&quot;task_id&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">            <span class="string">&quot;data&quot;</span>: <span class="string">&quot;my test&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        features = stub.StartScan(task_pb2.TaskInfoRequest(**req))</span><br><span class="line">        <span class="keyword">for</span> feature <span class="keyword">in</span> features:</span><br><span class="line">            <span class="built_in">print</span>(feature.progress)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    run()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>按照上述实现，即完成了gRPC的认证加密。</p><h3 id="抓包分析"><a href="#抓包分析" class="headerlink" title="抓包分析"></a>抓包分析</h3><p>运行上述的代码，进行抓包如下，确认gRPC通信已通过SSL&#x2F;TLS加密认证。</p><img src="/2022/08/10/grpc/gRPC%E5%A6%82%E4%BD%95%E5%81%9A%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%EF%BC%9F/grpc-ssl.png" class="" title="grpc-ssl">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当上线gRPC服务到生产环境的时候，首先需要考虑的就是数据的安全，那么如何保证呢，下面以python为例，进行简单介绍。&lt;/p&gt;
&lt;h2 id=&quot;RPC的认证方式&quot;&gt;&lt;a href=&quot;#RPC的认证方式&quot; class=&quot;headerlink&quot; title=&quot;RPC的认证方式</summary>
      
    
    
    
    <category term="grpc" scheme="https://zcej.github.io/categories/grpc/"/>
    
    
  </entry>
  
  <entry>
    <title>什么是gRPC，什么场景下使用gRPC？</title>
    <link href="https://zcej.github.io/2022/08/06/grpc/%E4%BB%80%E4%B9%88%E6%98%AFgRPC%EF%BC%8C%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%BD%BF%E7%94%A8%EF%BC%9F/"/>
    <id>https://zcej.github.io/2022/08/06/grpc/%E4%BB%80%E4%B9%88%E6%98%AFgRPC%EF%BC%8C%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%BD%BF%E7%94%A8%EF%BC%9F/</id>
    <published>2022-08-06T01:29:10.000Z</published>
    <updated>2022-10-10T14:02:01.261Z</updated>
    
    <content type="html"><![CDATA[<h2 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h2><h3 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC"></a>什么是RPC</h3><p>RPC指的是远程过程调用（Remote Procedure Call），能在本地调用其他服务器上的函数，它的调用包含了传输协议和编码协议等，而开发人员无需额外地为这个过程进行编码。</p><h3 id="什么是gRPC"><a href="#什么是gRPC" class="headerlink" title="什么是gRPC"></a>什么是gRPC</h3><p>gRPC是一个高性能、开源和通用的RPC框架，面向移动和基于HTTP&#x2F;2设计，并且提供了多种语言的支持。</p><p>gRPC基于HTTP&#x2F;2标准设计，有着如双向流、流控、头部压缩、单TCP连接上的多路复用请求等特性。这些特性使得其在移动设备上表现更好，在一定的情况下更节省空间占用。</p><p>gRPC的接口描述语言IDL(Interface description language)使用的是protubuf，都是由google开源的。</p><h3 id="gRPC调用模型"><a href="#gRPC调用模型" class="headerlink" title="gRPC调用模型"></a>gRPC调用模型</h3><img src="/2022/08/06/grpc/%E4%BB%80%E4%B9%88%E6%98%AFgRPC%EF%BC%8C%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%BD%BF%E7%94%A8%EF%BC%9F/grpc_concept_diagram.jpg" class="" title="test"><ol><li>客户端（gRPC Stub）在程序中调用某方法，发起RPC调用</li><li>对请求信息使用protobuf进行对象序列化压缩（IDL）</li><li>服务端（gRPC Server）接收到请求后，解码请求体，进行业务逻辑处理并返回</li><li>对响应结果使用protobuf进行对象序列化压缩（IDL）</li><li>客户端接收到服务端响应，解码请求体。回调被调用的A方法，唤醒正在等待响应（阻塞）的客户端调用并返回响应结果。</li></ol><h2 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h2><h3 id="什么是Protbuf"><a href="#什么是Protbuf" class="headerlink" title="什么是Protbuf"></a>什么是Protbuf</h3><p>Protobuf Buffers（Protobuf）是一种与语言、平台无关，可扩展的序列化结构数据的数据描述语言。常用于通信协议，数据存储等，相较于JSON、XML、它更小，更快。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">service </span><span class="title class_">Greeter</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> SayHello (HelloRequest) <span class="keyword">returns</span> (HelloReply) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">HelloRequest</span> &#123;</span><br><span class="line">    <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">HelloReply</span> &#123;</span><br><span class="line">    <span class="type">string</span> message = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先需要声明使用的语法版本，不声明的话默认使用的是proto2。目前主流使用的为proto3</li><li>定义名为<code>Greeter</code>的RPC服务（Service），其包含RPC方法<code>SayHello</code>，入参为<code>HelloRequest</code>消息体，出参为<code>HelloReply</code>消息体</li><li>定义<code>HelloRequest</code>、<code>HelloReply</code>消息体，每一个消息体的字段包含三个属性：类型、字段名称、字段编号。在消息体的定义上，除类型以外均不可重复。</li></ol><p>在编写完proto文件后，一般会进行编译和生成对应语言的proto文件操作，这个时候Protobuf的编译器会根据选择的语言不同，调用的插件情况，生成相应语言的Service Interface Code和Stubs。</p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><table><thead><tr><th><strong>Proto Type</strong></th><th><strong>C++ Type</strong></th><th><strong>Java Type</strong></th><th><strong>Go Type</strong></th><th><strong>PHP Type</strong></th></tr></thead><tbody><tr><td>double</td><td>double</td><td>double</td><td>float64</td><td>float</td></tr><tr><td>float</td><td>float</td><td>float</td><td>float32</td><td>float</td></tr><tr><td>int32</td><td>int32</td><td>int</td><td>int32</td><td>integer</td></tr><tr><td>int64</td><td>int64</td><td>long</td><td>int64</td><td>integer&#x2F;string</td></tr><tr><td>uint32</td><td>uint32</td><td>int</td><td>uint32</td><td>integer</td></tr><tr><td>uint64</td><td>uint64</td><td>long</td><td>uint64</td><td>integer&#x2F;string</td></tr><tr><td>sint32</td><td>int32</td><td>int</td><td>int32</td><td>integer</td></tr><tr><td>sint64</td><td>int64</td><td>long</td><td>int64</td><td>integer&#x2F;string</td></tr><tr><td>fixed32</td><td>uint32</td><td>int</td><td>uint32</td><td>integer</td></tr><tr><td>fixed64</td><td>uint64</td><td>long</td><td>uint64</td><td>integer&#x2F;string</td></tr><tr><td>sfixed32</td><td>int32</td><td>int</td><td>int32</td><td>integer</td></tr><tr><td>sfixed64</td><td>int64</td><td>long</td><td>int64</td><td>integer&#x2F;string</td></tr><tr><td>bool</td><td>bool</td><td>boolean</td><td>bool</td><td>boolean</td></tr><tr><td>string</td><td>string</td><td>String</td><td>string</td><td>string</td></tr><tr><td>bytes</td><td>string</td><td>ByteString</td><td>[]byte</td><td>string</td></tr></tbody></table><h2 id="什么场景下使用gRPC？"><a href="#什么场景下使用gRPC？" class="headerlink" title="什么场景下使用gRPC？"></a>什么场景下使用gRPC？</h2><h3 id="gRPC与RESTful-API对比"><a href="#gRPC与RESTful-API对比" class="headerlink" title="gRPC与RESTful API对比"></a>gRPC与RESTful API对比</h3><table><thead><tr><th><strong>特性</strong></th><th><strong>gRPC</strong></th><th><strong>RESTful API</strong></th></tr></thead><tbody><tr><td>规范</td><td>必须.proto</td><td>可选OpenAPI</td></tr><tr><td>协议</td><td>HTTP&#x2F;2</td><td>任意版本的HTTP协议</td></tr><tr><td>有效载荷</td><td>Protobuf（小、二进制）</td><td>JSON（大、易读）</td></tr><tr><td>浏览器支持</td><td>否（需要grpc-web）</td><td>是</td></tr><tr><td>流传输</td><td>客户端、服务端、双向</td><td>客户端、服务端</td></tr><tr><td>代码生成</td><td>是</td><td>OpenAPI+第三方工具</td></tr></tbody></table><h3 id="使用场景分析"><a href="#使用场景分析" class="headerlink" title="使用场景分析"></a>使用场景分析</h3><ol><li>低延时，高可用的分布式系统</li><li>移动端与云服务端的通讯</li><li>使用protobuf，独立于语言的协议，支持多语言之间的通讯</li><li>可以分层扩展，如：身份验证，负载均衡，日志记录，监控等</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;gRPC&quot;&gt;&lt;a href=&quot;#gRPC&quot; class=&quot;headerlink&quot; title=&quot;gRPC&quot;&gt;&lt;/a&gt;gRPC&lt;/h2&gt;&lt;h3 id=&quot;什么是RPC&quot;&gt;&lt;a href=&quot;#什么是RPC&quot; class=&quot;headerlink&quot; title=&quot;什么是RP</summary>
      
    
    
    
    <category term="grpc" scheme="https://zcej.github.io/categories/grpc/"/>
    
    
  </entry>
  
  <entry>
    <title>让邮件变得简单-zmail</title>
    <link href="https://zcej.github.io/2022/07/02/python/%E8%AE%A9%E9%82%AE%E4%BB%B6%E5%8F%98%E5%BE%97%E7%AE%80%E5%8D%95-zmail/"/>
    <id>https://zcej.github.io/2022/07/02/python/%E8%AE%A9%E9%82%AE%E4%BB%B6%E5%8F%98%E5%BE%97%E7%AE%80%E5%8D%95-zmail/</id>
    <published>2022-07-02T03:13:38.000Z</published>
    <updated>2022-07-10T23:17:11.453Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由之前的爬虫需要获取邮箱验证码得以延伸，当时简单实现了一个支持pop3协议的邮件接收功能，但是不足点还有很多，扩展性也不强。比如支持的邮件服务商有限，功能针对性过强，换一个场景的话就无法使用了。于是整理了下思路，考虑到重复造轮子的话意义不大，现阶段不如多汲取已有轮子的优点，多进行积累未来才能造功能更强大完善的轮子。本着这样的想法，找到了一个收发邮件的第三方模块<code>[zmail](https://github.com/zhangyunhao116/zmail)</code>，目前该项目虽已不再维护，不过功能依然很强大可用，后续有需求也可进行修改升级。该模块本质上还是调用的python的标准库<code>smtplib</code>,<code>poplib</code>。</p><h2 id="简单分析"><a href="#简单分析" class="headerlink" title="简单分析"></a>简单分析</h2><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">│─ zmail</span><br><span class="line">│    __init__.py</span><br><span class="line">│    abc.py</span><br><span class="line">│    api.py</span><br><span class="line">│    compat.py</span><br><span class="line">│    exceptions.py</span><br><span class="line">│    helpers.py</span><br><span class="line">│    info.py</span><br><span class="line">│    mime.py</span><br><span class="line">│    parser.py</span><br><span class="line">│    server.py</span><br><span class="line">│    settings.py</span><br><span class="line">│    structures.py</span><br><span class="line">│    utils.py</span><br></pre></td></tr></table></figure><ul><li><code>abc.py</code><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2>下面简单列举下如何使用该模块进行收发邮件，其他详细功能可以参考作者文档或阅读源码。<h3 id="发送邮件"><a href="#发送邮件" class="headerlink" title="发送邮件"></a>发送邮件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zmail</span><br><span class="line"></span><br><span class="line">mail = &#123;</span><br><span class="line">    <span class="string">&quot;subject&quot;</span>: <span class="string">&quot;Hello&quot;</span>,  <span class="comment"># 邮件主题</span></span><br><span class="line">    <span class="string">&quot;content_text&quot;</span>: <span class="string">&quot;send message test&quot;</span>,  <span class="comment"># 邮件内容</span></span><br><span class="line">    <span class="string">&quot;attachments&quot;</span>: [<span class="string">&quot;/tmp/test.py&quot;</span>, <span class="string">&quot;/tmp/1.jpg&quot;</span>],  <span class="comment"># 附件内容(最好使用绝对路径)</span></span><br><span class="line">    <span class="string">&quot;from&quot;</span>: <span class="string">&quot;Name &lt;your email account&gt;&quot;</span>  <span class="comment"># 自定义发送者</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server = zmail.server(<span class="string">&quot;your email&quot;</span>, <span class="string">&quot;your password&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量发送</span></span><br><span class="line">server.send_mail([<span class="string">&quot;send email&quot;</span>], mail)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加抄送</span></span><br><span class="line">server.send_mail([<span class="string">&quot;send email&quot;</span>], mail, cc=[<span class="string">&quot;send email2&quot;</span>])</span><br></pre></td></tr></table></figure><h3 id="接收邮件"><a href="#接收邮件" class="headerlink" title="接收邮件"></a>接收邮件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zmail</span><br><span class="line"></span><br><span class="line">server = zamil.server(<span class="string">&quot;your email&quot;</span>, <span class="string">&quot;your password&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取最新邮件</span></span><br><span class="line">mail = server.get_latest()  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据id取邮件</span></span><br><span class="line">mail = server.get_mail(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据(subject,after,before,sender)取邮件</span></span><br><span class="line">mail = server.get_mails(subject=<span class="string">&quot;Github&quot;</span>, start_time=<span class="string">&quot;2022-6-1&quot;</span>, sender=<span class="string">&quot;github&quot;</span>, start_index=<span class="number">1</span>, end_index=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取邮箱信息</span></span><br><span class="line">mailbox_info = server.stat()</span><br></pre></td></tr></table></figure><h3 id="解析邮件"><a href="#解析邮件" class="headerlink" title="解析邮件"></a>解析邮件</h3><code>zamil</code>将接收到的邮件映射为了一个字典，可直接获取到对应字段的值。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zmail</span><br><span class="line"></span><br><span class="line">server = zamil.server(<span class="string">&quot;your email&quot;</span>, <span class="string">&quot;your password&quot;</span>)</span><br><span class="line">mail = server.get_latest()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印邮件</span></span><br><span class="line">zmail.show(mail)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看邮件所有内容</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> mail.items():</span><br><span class="line">    <span class="built_in">print</span>(k, v)</span><br></pre></td></tr></table></figure><h3 id="支持的邮件服务商"><a href="#支持的邮件服务商" class="headerlink" title="支持的邮件服务商"></a>支持的邮件服务商</h3>另外将该模块支持的邮件服务商列出，方便以后有用到的话直接进行查阅。</li></ul><table><thead><tr><th>** 服务商地址**</th><th><strong>发送邮件</strong></th><th><strong>接收邮件</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>@163.com</td><td>✓</td><td>✓</td><td>需要应用专用密码</td></tr><tr><td>@126.com</td><td>✓</td><td>✓</td><td></td></tr><tr><td>@qq.com</td><td>✓</td><td>✓</td><td>pop3需要应用专用密码</td></tr><tr><td>@yeah.net</td><td>✓</td><td>✓</td><td></td></tr><tr><td>@gmail.com</td><td>✓</td><td>✓</td><td>需要应用专用密码</td></tr><tr><td>@sina.com</td><td>✓</td><td>✓</td><td></td></tr><tr><td>@outlook</td><td>✓</td><td>✓</td><td>需要应用专用密码</td></tr><tr><td>@hotmail</td><td>✓</td><td>✓</td><td>需要额外设置</td></tr></tbody></table><p>支持的企业邮箱、</p><table><thead><tr><th>** 名称**</th><th><strong>使用示例</strong></th></tr></thead><tbody><tr><td>腾讯企业邮箱</td><td>zmail.server(‘username’,’psw’,config&#x3D;’qq’)</td></tr><tr><td>阿里企业邮箱</td><td>zmail.server(‘username’,’psw’,config&#x3D;’ali’)</td></tr><tr><td>网易企业邮箱</td><td>zmail.server(‘username’,’psw’,config&#x3D;’163’)</td></tr><tr><td>谷歌企业邮箱</td><td>zmail.server(‘username’,’psw’,config&#x3D;’google’)</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上只是简单列出<code>zmail</code>的发送和接收功能，更多详细的内容还需参考原作者的项目。<br>通过上述发送和接收邮件的案例可以看出，它为我们省去很很多繁琐的工作，例如编解码，解析及构造邮件等。很多时候我们不可避免的需要重复造轮子，通过不断的学习积累更好的第三方模块，才能使我们的轮子造的有意义。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;由之前的爬虫需要获取邮箱验证码得以延伸，当时简单实现了一个支持pop3协议的邮件接收功能，但是不足点还有很多，扩展性也不强。比如支持的邮件服</summary>
      
    
    
    
    <category term="python" scheme="https://zcej.github.io/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>爬取github的关键字搜索结果</title>
    <link href="https://zcej.github.io/2022/06/13/%E7%88%AC%E8%99%AB/%E7%88%AC%E5%8F%96github%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C/"/>
    <id>https://zcej.github.io/2022/06/13/%E7%88%AC%E8%99%AB/%E7%88%AC%E5%8F%96github%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C/</id>
    <published>2022-06-13T14:51:06.000Z</published>
    <updated>2022-07-10T23:14:14.528Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>功能：根据github搜索关键字得到的结果进行解析，提取需要的字段，整个过程均自动化。<br>思路：</p><ul><li>在页面上模拟操作，此过程中使用抓包工具<code>Fiddler</code>分析相关反爬策略</li><li>可先获取到结果页面，进行离线解析，暂不依赖网络环境，提供工作效率</li><li>补充完善抓取策略，比如并发，代理池。后续思考使用框架是不是效率更高<blockquote><p>注：github官方有提供API<code>serarch-code</code>，但是其不能在全部的公共库中搜索，故使用爬虫爬取搜索数据，官方有提供API优先考虑能否从API中获取到的需要的数据。</p></blockquote></li></ul><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p>依赖的模块有<code>requests</code>，<code>beautifulsoup4</code>以及解析器<code>lxml</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pip install requests</span><br><span class="line"></span><br><span class="line">pip install beautifulsoup4</span><br><span class="line"></span><br><span class="line">pip install lxml</span><br></pre></td></tr></table></figure><h2 id="登录认证"><a href="#登录认证" class="headerlink" title="登录认证"></a>登录认证</h2><p>首先在页面上模拟搜索关键字结果，发现type为code类型的需要登录认证，然后在页面上登录，并通过<code>Fiddler</code>抓包发现发现最终提交数据的url是<code>session</code>，且需要提交下图所示的数据，经测试提交关键信息即可。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">commit</span><span class="punctuation">: </span>Sign in</span><br><span class="line">authenticity_token: your token</span><br><span class="line"><span class="attribute">login</span><span class="punctuation">: </span>your username</span><br><span class="line"><span class="attribute">password</span><span class="punctuation">: </span>your password</span><br></pre></td></tr></table></figure><img src="/2022/06/13/%E7%88%AC%E8%99%AB/%E7%88%AC%E5%8F%96github%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C/1-1.png" class="" title="image.png"><p>上面所需要提交的数据发现<code>authenticity_token</code>不知道从哪里来，因为请求的url是<code>login</code>，而实际提交的<br>url是<code>session</code>，很有可能是在请求登录页的时候动态生成的，去页面上搜索一下token果然有该参数。</p><img src="/2022/06/13/%E7%88%AC%E8%99%AB/%E7%88%AC%E5%8F%96github%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C/1-2.png" class="" title="image.png"><p>至此，前路基本已经铺平，只需要进行实现即可，这里注意使用<code>requests</code>包中的<code>session</code>对象，该对象能够保持会话，就不用重复登录了。</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>个人认为主要分为2个部分：</p><ul><li>获取到结果前：包括登录认证，获取所有请求链接等</li><li>获取到结果后：包括页面的解析，字段提取等</li></ul><p>这里贴出多线程版本的代码，虽然优化空间还有很大，但也基本能运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">urllib3.disable_warnings()</span><br><span class="line"></span><br><span class="line">USERNAME = <span class="string">&quot;&quot;</span></span><br><span class="line">PASSWD = <span class="string">&quot;&quot;</span></span><br><span class="line">KEYWORD = <span class="string">&quot;&quot;</span></span><br><span class="line">PROXY = &#123;&#125;  <span class="comment"># https://free.kuaidaili.com/free/inha/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GithubCrawl</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, username, passwd, keyword</span>):</span><br><span class="line">        self.username = username</span><br><span class="line">        self.passwd = passwd</span><br><span class="line"></span><br><span class="line">        self.queue = Queue()</span><br><span class="line">        self.session = requests.Session()</span><br><span class="line">        self.result = []</span><br><span class="line"></span><br><span class="line">        self.threads = <span class="number">5</span></span><br><span class="line">        self.output_file = <span class="string">&quot;./temp.txt&quot;</span></span><br><span class="line">        self.login_url = <span class="string">&quot;https://github.com/login&quot;</span></span><br><span class="line">        self.post_url = <span class="string">&quot;https://github.com/session&quot;</span></span><br><span class="line">        self.search_url = <span class="string">f&quot;https://github.com/search?q=<span class="subst">&#123;keyword&#125;</span>&amp;type=code&quot;</span></span><br><span class="line">        self.headers = &#123;</span><br><span class="line">            <span class="string">&quot;Referer&quot;</span>: <span class="string">&quot;https://github.com/&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Host&quot;</span>: <span class="string">&quot;github.com&quot;</span>,</span><br><span class="line">            <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.139 Safari/537.36&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        self.proxy = PROXY</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_parse_content</span>(<span class="params">tags</span>):</span><br><span class="line">        content = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> tag <span class="keyword">in</span> tags:</span><br><span class="line">            content += tag.text</span><br><span class="line">        <span class="keyword">return</span> content</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_get_token</span>(<span class="params">self</span>):</span><br><span class="line">        resp = self.session.get(self.login_url, headers=self.headers, verify=<span class="literal">False</span>, proxies=self.proxy)</span><br><span class="line">        soup = BeautifulSoup(resp.text, <span class="string">&quot;lxml&quot;</span>)</span><br><span class="line">        token = soup.find(<span class="string">&quot;input&quot;</span>, attrs=&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;authenticity_token&quot;</span>&#125;).get(<span class="string">&quot;value&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;token is: <span class="subst">&#123;token&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> token</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">self, token</span>):</span><br><span class="line">        post_data = &#123;</span><br><span class="line">            <span class="string">&#x27;commit&#x27;</span>: <span class="string">&#x27;Sign in&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;login&#x27;</span>: self.username,</span><br><span class="line">            <span class="string">&#x27;password&#x27;</span>: self.passwd,</span><br><span class="line">            <span class="string">&#x27;authenticity_token&#x27;</span>: token</span><br><span class="line">        &#125;</span><br><span class="line">        resp = self.session.post(self.post_url, data=post_data, headers=self.headers, verify=<span class="literal">False</span>, proxies=self.proxy)</span><br><span class="line">        <span class="keyword">if</span> resp.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;successful set up a session on github...&quot;</span>)</span><br><span class="line">            self.get_urls()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_urls</span>(<span class="params">self</span>):</span><br><span class="line">        resp = self.session.get(self.search_url, headers=self.headers, verify=<span class="literal">False</span>, proxies=self.proxy)</span><br><span class="line">        soup = BeautifulSoup(resp.text, <span class="string">&quot;lxml&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> re.search(<span class="string">&quot;login&quot;</span>, soup.title.text, re.I):</span><br><span class="line">            <span class="keyword">raise</span> ConnectionError(<span class="string">&quot;the session is closed, please check network or add proxy!&quot;</span>)</span><br><span class="line">        total_pages = soup.find(attrs=&#123;<span class="string">&quot;aria-label&quot;</span>: <span class="string">&quot;Pagination&quot;</span>&#125;).text.split(<span class="string">&quot; &quot;</span>)[-<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">int</span>(total_pages) + <span class="number">1</span>):</span><br><span class="line">            _url = self.search_url + <span class="string">f&quot;&amp;p=<span class="subst">&#123;i&#125;</span>&quot;</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;add the url to queue: <span class="subst">&#123;_url&#125;</span>&quot;</span>)</span><br><span class="line">            self.queue.put(_url)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_data</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> self.queue.empty():</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            url = self.queue.get()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;get url: <span class="subst">&#123;url&#125;</span>&quot;</span>)</span><br><span class="line">            self.parse_search_page(url)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse_search_page</span>(<span class="params">self, url</span>):</span><br><span class="line">            resp = self.session.get(url, headers=self.headers, verify=<span class="literal">False</span>, proxies=self.proxy)</span><br><span class="line">            soup = BeautifulSoup(resp.text, <span class="string">&quot;lxml&quot;</span>)</span><br><span class="line">            items = soup.find_all(class_=<span class="string">&quot;code-list-item&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> items:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;not found data in the page <span class="subst">&#123;url&#125;</span>...&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;start parse url: <span class="subst">&#123;url&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">                text_small = item.find(class_=<span class="string">&quot;text-small&quot;</span>).text.strip().split(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">                lang = item.find(attrs=&#123;<span class="string">&quot;itemprop&quot;</span>: <span class="string">&quot;programmingLanguage&quot;</span>&#125;)</span><br><span class="line">                data = &#123;</span><br><span class="line">                    <span class="string">&quot;author_favicon&quot;</span>: item.find(<span class="string">&quot;img&quot;</span>).attrs[<span class="string">&quot;src&quot;</span>],</span><br><span class="line">                    <span class="string">&quot;author&quot;</span>: text_small[<span class="number">0</span>].strip(),</span><br><span class="line">                    <span class="string">&quot;repository&quot;</span>: text_small[<span class="number">1</span>].strip(),</span><br><span class="line">                    <span class="string">&quot;filename&quot;</span>: item.find(class_=<span class="string">&quot;text-normal&quot;</span>).text.strip(),</span><br><span class="line">                    <span class="string">&quot;filepath&quot;</span>: parse.urljoin(<span class="string">&quot;https://github.com&quot;</span>, item.find(class_=<span class="string">&quot;text-normal&quot;</span>).a.attrs[<span class="string">&quot;href&quot;</span>]),</span><br><span class="line">                    <span class="string">&quot;content&quot;</span>: self._parse_content(item.find_all(class_=<span class="string">&quot;blob-code&quot;</span>)),</span><br><span class="line">                    <span class="string">&quot;language&quot;</span>: lang.text <span class="keyword">if</span> lang <span class="keyword">else</span> lang,</span><br><span class="line">                    <span class="string">&quot;updated_at&quot;</span>: item.find(class_=<span class="string">&quot;updated-at&quot;</span>).find(class_=<span class="string">&quot;no-wrap&quot;</span>).attrs[<span class="string">&quot;datetime&quot;</span>]</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">print</span>(data)</span><br><span class="line">                self.result.append(json.dumps(data))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">write_to_file</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(self.output_file, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.writelines([line + <span class="string">&quot;\n&quot;</span> <span class="keyword">for</span> line <span class="keyword">in</span> self.result])</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;finished...&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;write result to file failed...&quot;</span>)</span><br><span class="line">            <span class="keyword">raise</span> e</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">self</span>):</span><br><span class="line">        token = self._get_token()</span><br><span class="line">        self.login(token)</span><br><span class="line">        t_list = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.threads):</span><br><span class="line">            t = Thread(target=self.get_data)</span><br><span class="line">            t_list.append(t)</span><br><span class="line">            t.start()</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> t_list:</span><br><span class="line">            t.join()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;all task finished...&quot;</span>)</span><br><span class="line">        self.write_to_file()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    crawler = GithubCrawl(USERNAME, PASSWD, KEYWORD)</span><br><span class="line">    crawler.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="后续追加"><a href="#后续追加" class="headerlink" title="后续追加"></a>后续追加</h2><p>本以为到此大功告成，没成想交给同事运行测试的时候发现报错了，经个人简单排查后发现github对新设备登录有认证要求，需要提供邮件的验证码，故目前还得将自动化获取验证码这一步添加上去。</p><img src="/2022/06/13/%E7%88%AC%E8%99%AB/%E7%88%AC%E5%8F%96github%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C/2-1.png" class="" title="image.png"><p>继续使用<code>Fiddler</code>进行抓包分析，发现验证设备提交的url是<code>/sessions/verified-device</code>，并需要提交下列数据。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">authentictiy_token: your token</span><br><span class="line"><span class="attribute">opt</span><span class="punctuation">: </span>your verification code</span><br></pre></td></tr></table></figure><img src="/2022/06/13/%E7%88%AC%E8%99%AB/%E7%88%AC%E5%8F%96github%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C/2-2.png" class="" title="image.png"><blockquote><p>注：这里的<code>authentictiy_token</code>不是之前&#x2F;login页面的，而是在&#x2F;sessions&#x2F;verified-device页面中新生成的</p></blockquote><p>最后，这里简单给出通过pop3协议获取邮箱验证码的代码，代码中确保了获取到的是在请求github页面后收到的验证码邮件，此外，还需在修改下上述github的<code>login</code>方法，完整代码见<a href="https://github.com/zcej/GithubCrawl/blob/master/github_crawl3.py">git</a>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># email info</span></span><br><span class="line">EMAIL_ACCOUNT = <span class="string">&quot;&quot;</span></span><br><span class="line">AUTH_CODE = <span class="string">&quot;&quot;</span>  <span class="comment"># must authorization code</span></span><br><span class="line">POP3_SSL_SERVER = <span class="string">&quot;&quot;</span></span><br><span class="line">PROTOCOL = <span class="string">&quot;pop3&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmailReceiver</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, email_account, auth_code, pop3_ssl_server, send_login_time, protocol=<span class="string">&quot;pop3&quot;</span></span>):</span><br><span class="line">        self.email_account = email_account</span><br><span class="line">        self.auth_code = auth_code</span><br><span class="line">        self.pop3_ssl_server = pop3_ssl_server</span><br><span class="line">        self.send_login_time = send_login_time</span><br><span class="line"></span><br><span class="line">        self.email_total_number = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        self.session = self.login_pop3() <span class="keyword">if</span> protocol == <span class="string">&quot;pop3&quot;</span> <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.session:</span><br><span class="line">            <span class="keyword">raise</span> ConnectionError(<span class="string">&quot;[Email Receiver] failed connect to the email server&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">login_pop3</span>(<span class="params">self</span>):</span><br><span class="line">        a = poplib.POP3_SSL(self.pop3_ssl_server)</span><br><span class="line">        a.user(self.email_account)</span><br><span class="line">        a.pass_(self.auth_code)</span><br><span class="line">        resp, mails, octets = a.<span class="built_in">list</span>()</span><br><span class="line">        self.email_total_number = <span class="built_in">len</span>(mails)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[Email Receiver] the number of email is: <span class="subst">&#123;self.email_total_number&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> a <span class="keyword">if</span> resp.decode(<span class="string">&quot;utf-8&quot;</span>) == <span class="string">&quot;+OK&quot;</span> <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">logout</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.session:</span><br><span class="line">            self.session.quit()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decode_str</span>(<span class="params">s</span>):</span><br><span class="line">        value, charset = decode_header(s)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> charset:</span><br><span class="line">            value = value.decode(charset)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_is_latest_email</span>(<span class="params">content, send_login_time</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        date = content.get(<span class="string">&quot;Received&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        ret = re.search(<span class="string">r&quot;(?:\d+:)&#123;2,&#125;?\d+&quot;</span>, date)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[Email Receiver] get the latest email recv time failed, date: <span class="subst">&#123;date&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        recv_email_time = ret.group()</span><br><span class="line">        time_diff = datetime.strptime(recv_email_time, <span class="string">&quot;%H:%M:%S&quot;</span>) - datetime.strptime(send_login_time, <span class="string">&quot;%H:%M:%S&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;recv: <span class="subst">&#123;recv_email_time&#125;</span>, login: <span class="subst">&#123;send_login_time&#125;</span>, <span class="subst">&#123;time_diff&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> time_diff.days &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[Email Receiver] the latest email received was not after logged into github&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> time_diff.days == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_is_github_verify_email</span>(<span class="params">self, content</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        subject = self.decode_str(content.get(<span class="string">&quot;Subject&quot;</span>, <span class="string">&quot;&quot;</span>))</span><br><span class="line">        from_ = self.decode_str(content.get(<span class="string">&quot;From&quot;</span>, <span class="string">&quot;&quot;</span>))</span><br><span class="line">        ret = re.search(<span class="string">r&quot;\[GitHub] Please verify your device&quot;</span>, subject)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[Email Receiver] the latest email is not from github, subject: <span class="subst">&#123;subject&#125;</span>, From: <span class="subst">&#123;from_&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_email_content</span>(<span class="params">session, total_number</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[Email Receiver] curr total_number is: <span class="subst">&#123;total_number&#125;</span>&quot;</span>)</span><br><span class="line">        resp, lines, octets = session.retr(total_number)</span><br><span class="line">        msg_content = <span class="string">b&quot;\r\n&quot;</span>.join(lines).decode(<span class="string">&quot;utf-8&quot;</span>, <span class="string">&quot;ignore&quot;</span>)</span><br><span class="line">        content = Parser().parsestr(msg_content)</span><br><span class="line">        <span class="keyword">return</span> content</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_verification_code</span>(<span class="params">self</span>):</span><br><span class="line">        content = self.get_email_content(self.session, self.email_total_number)</span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">            <span class="keyword">if</span> self._is_github_verify_email(content) <span class="keyword">and</span> self._is_latest_email(content, self.send_login_time):</span><br><span class="line">                flag = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            time.sleep(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">            temp_session = poplib.POP3_SSL(self.pop3_ssl_server)</span><br><span class="line">            temp_session.user(self.email_account)</span><br><span class="line">            temp_session.pass_(self.auth_code)</span><br><span class="line">            emails, _ = temp_session.stat()</span><br><span class="line">            <span class="keyword">if</span> emails &gt; self.email_total_number:</span><br><span class="line">                content = self.get_email_content(temp_session, emails)</span><br><span class="line">            temp_session.quit()</span><br><span class="line"></span><br><span class="line">        verification_code = re.search(<span class="string">r&quot;Verification code: (\d+)&quot;</span>, <span class="built_in">str</span>(content))</span><br><span class="line">        <span class="keyword">if</span> flag <span class="keyword">and</span> verification_code:</span><br><span class="line">            <span class="keyword">return</span> verification_code.groups()[<span class="number">0</span>]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[Email Receiver] get github verification code failed, try 5 times&quot;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>注：经个人测试，使用poplib在同一次连接中无法实时获取最新邮件，目前的解决方法是重新建立了临时的连接进行获取。后续发现有python的第三方模块zmail支持实时获取，简单研究了下，详见后续文章。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;功能：根据github搜索关键字得到的结果进行解析，提取需要的字段，整个过程均自动化。&lt;br&gt;思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在页面上模拟</summary>
      
    
    
    
    <category term="python" scheme="https://zcej.github.io/categories/python/"/>
    
    <category term="爬虫" scheme="https://zcej.github.io/categories/python/%E7%88%AC%E8%99%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>快速上手BeautifulSoup4</title>
    <link href="https://zcej.github.io/2022/06/08/%E7%88%AC%E8%99%AB/BeautifulSoup4%E8%A7%A3%E6%9E%90/"/>
    <id>https://zcej.github.io/2022/06/08/%E7%88%AC%E8%99%AB/BeautifulSoup4%E8%A7%A3%E6%9E%90/</id>
    <published>2022-06-08T13:03:11.000Z</published>
    <updated>2022-07-03T13:25:05.188Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装BeautifulSoup"><a href="#安装BeautifulSoup" class="headerlink" title="安装BeautifulSoup"></a>安装BeautifulSoup</h3><p>可通过系统的包管理工具安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install Python-bs4</span><br></pre></td></tr></table></figure><p>或者通过python的包管理工具<code>pip</code>进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install beautifulsoup4 -i http://mirrors.aliyun.com/pypi/simple/</span><br></pre></td></tr></table></figure><h3 id="安装解析器"><a href="#安装解析器" class="headerlink" title="安装解析器"></a>安装解析器</h3><p>python内置了HTML解析器，若要使用第三方的解析器，如<code>lxml</code>，则需根据操作系统和python的版本选择对应的包进行安装，若要离线安装，windows下可点击该<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/#lxml">链接</a>下载。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt-get install Python-lxml</span><br><span class="line"></span><br><span class="line">pip install lxml</span><br></pre></td></tr></table></figure><p>或纯python实现的<code>html5lib</code>，其解析方式与浏览器相同。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt-get install Python-html5lib</span><br><span class="line"></span><br><span class="line">pip install html5lib</span><br></pre></td></tr></table></figure><table><thead><tr><th>解析器</th><th>使用方法</th><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>python标准库</td><td>BeautifulSoup(html, ‘html.parser’)</td><td>python的内置标准库<br>执行速度适中<br>文档容错能力强</td><td>Python2.7.3或3.2.2前的版本中文容错能力差</td></tr><tr><td>lxml HTML解析器</td><td>BeautifulSoup(html, ‘lxml’)</td><td>速度快<br>文档容错能力强</td><td>需要安装c语言库</td></tr><tr><td>lxml XML解析器</td><td>BeautifulSoup(html, [‘lxml’, ‘xml’])</td><td>速度快<br>唯一支持XML的解析器</td><td>需要安装c语言库</td></tr><tr><td>html5lib</td><td>BeautifulSoup(html, ‘html5lib’)</td><td>最好的容错性<br>以浏览器的方式解析文档<br>生成HTML5格式的文档</td><td>速度慢<br>不依赖外部扩展</td></tr></tbody></table><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><p>假设有一个网页<code>html</code>，创建一个<code>BeautifulSoup</code>对象，并指定解析器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(html, <span class="string">&quot;lxml)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">soup.prettify() # 缩进打印</span></span><br><span class="line"><span class="string">soup.title # 获取title标签的内容</span></span><br><span class="line"><span class="string">soup.div # 获取第一个div标签的内容</span></span><br><span class="line"><span class="string">soup.find(id=&quot;</span>uq<span class="string">&quot;) # 获取id=&quot;</span>u1<span class="string">&quot;的标签</span></span><br><span class="line"><span class="string">soup.find_all(class_=&quot;</span>item<span class="string">&quot;) # 查找所有class属性有item的标签                     </span></span><br></pre></td></tr></table></figure><blockquote><p>注：灵活利用IDE的打断点进行debug可以快速调试，拿到自己需要的元素</p></blockquote><h2 id="对象种类"><a href="#对象种类" class="headerlink" title="对象种类"></a>对象种类</h2><p>~将复杂HTML文档转换成一个复杂的树形结构，每个节点都是python对象，所有对象可以归为以下四类：</p><h3 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h3><p>Tag通俗点讲就是HTML中的一个个标签，它的类型是<code>bs4.element.Tag</code>，对于Tag有两个重要的属性，是name和attrs。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每个tag都有自己的名字，通过.name来获取</span></span><br><span class="line">tag.name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个tag可能有多个属性，其操作方式与字典相同，也可以通过点的方式获取</span></span><br><span class="line">tag[<span class="string">&quot;class&quot;</span>]</span><br><span class="line">tag.attrs</span><br></pre></td></tr></table></figure><blockquote><p>注：如果标签中某个属性有多值，则解析后返回的类型是list，但是转换的文档是xml时除外。</p></blockquote><h3 id="NavigableString"><a href="#NavigableString" class="headerlink" title="NavigableString"></a>NavigableString</h3><p>用于获取标签内部的文字，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">soup.title.string</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(bs.title.string))</span><br></pre></td></tr></table></figure><h3 id="BeautifulSoup"><a href="#BeautifulSoup" class="headerlink" title="BeautifulSoup"></a>BeautifulSoup</h3><p>表示的是一个文档的全部内容，大部分时候可以将其看作为一个特殊的Tag，可通过以下方式获取其名称和属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">soup.name</span><br><span class="line">soup.attrs</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(soup))</span><br></pre></td></tr></table></figure><h3 id="Comment"><a href="#Comment" class="headerlink" title="Comment"></a>Comment</h3><p>是一个特殊类型的NavigableString对象，其输出的内容不包括注释符号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">soup.a <span class="comment"># &lt;a class=&quot;mnav&quot;&gt;&lt;!--新闻--&gt;&lt;/a&gt;</span></span><br><span class="line"></span><br><span class="line">soup.a.string <span class="comment"># 新闻</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(soup.a.string)) <span class="comment"># &lt;class &#x27;bs4.element.Comment&#x27;&gt;</span></span><br></pre></td></tr></table></figure><h2 id="遍历文档树"><a href="#遍历文档树" class="headerlink" title="遍历文档树"></a>遍历文档树</h2><h3 id="子节点"><a href="#子节点" class="headerlink" title="子节点"></a>子节点</h3><h4 id="contents和-children"><a href="#contents和-children" class="headerlink" title=".contents和.children"></a>.contents和.children</h4><ul><li><p>contents：获取Tag的所有子节点，返回一个list</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">soup.contents</span><br><span class="line"></span><br><span class="line">soup.contents[<span class="number">0</span>].name</span><br></pre></td></tr></table></figure></li><li><p>children：获取Tag的所有子节点，返回一个生成器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> soup.body.children:</span><br><span class="line">    <span class="built_in">print</span>(child)</span><br></pre></td></tr></table></figure><h4 id="descendants"><a href="#descendants" class="headerlink" title=".descendants"></a>.descendants</h4></li><li><p><code>.contents</code>和<code>.children</code>属性仅包含tag的直接子节点，<code>.descendants</code>可以对所有tag的子孙节点进行递归循环。</p><h4 id="string"><a href="#string" class="headerlink" title=".string"></a>.string</h4></li><li><p>如果tag只有一个子节点，这个tag可以使用<code>.string</code>方法获取，如果有多个子节点，则返回为None</p><h4 id="strings和-stripped-strings"><a href="#strings和-stripped-strings" class="headerlink" title=".strings和.stripped_strings"></a>.strings和.stripped_strings</h4></li><li><p>若果tag中包含多个字符串，可以使用<code>.strings</code>循环获取</p></li><li><p>如果字符串包含很多空格或空行，可以使用<code>.stripped_strings</code>去除</p><h3 id="父节点"><a href="#父节点" class="headerlink" title="父节点"></a>父节点</h3><h4 id="parent"><a href="#parent" class="headerlink" title=".parent"></a>.parent</h4></li><li><p>通过<code>.parent</code>获取某个元素的父节点</p></li><li><p>顶层节点的父节点是BeautifulSoup对象</p></li><li><p>BeautifulSoup对象的<code>.parent</code>是None</p><h4 id="parents"><a href="#parents" class="headerlink" title=".parents"></a>.parents</h4></li><li><p>通过<code>.parents</code>可以递归获取元素的所有父节点</p><h3 id="兄弟节点"><a href="#兄弟节点" class="headerlink" title="兄弟节点"></a>兄弟节点</h3><h4 id="next-sibling和-previous-sibling"><a href="#next-sibling和-previous-sibling" class="headerlink" title=".next_sibling和.previous_sibling"></a>.next_sibling和.previous_sibling</h4></li><li><p>使用 .next_sibling 和 .previous_sibling 属性来查询兄弟节点</p><h4 id="next-siblings和-previous-siblings"><a href="#next-siblings和-previous-siblings" class="headerlink" title=".next_siblings和.previous_siblings"></a>.next_siblings和.previous_siblings</h4></li><li><p>通过 .next_siblings 和 .previous_siblings 属性可以对当前节点的兄弟节点迭代输出</p><h2 id="搜索文档树"><a href="#搜索文档树" class="headerlink" title="搜索文档树"></a>搜索文档树</h2><p>这里主要列举<code>find_all</code>和<code>find</code>方法以及CSS选择器，其他方法可参考官方文档。</p><h3 id="find-all"><a href="#find-all" class="headerlink" title="find_all"></a>find_all</h3><p>find_all(name, attrs, recursive, text, **kwargs)</p><h4 id="name参数"><a href="#name参数" class="headerlink" title="name参数"></a>name参数</h4></li><li><p>字符串过滤：会查找与字符串完全匹配的内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a_list = soup.find_all(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a_list)</span><br></pre></td></tr></table></figure></li><li><p>正则表达式过滤：如果传入的是正则表达式，那么BeautifulSoup4会通过search()来匹配内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a_list = soup.find_all(re.<span class="built_in">compile</span>(<span class="string">&quot;a&quot;</span>))</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> a_list:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure></li><li><p>列表：如果传入一个列表，BeautifulSoup4将会与列表中的任一元素匹配到的节点返回</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a_list = soup.find_all([<span class="string">&quot;meta&quot;</span>, <span class="string">&quot;link&quot;</span>])</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> a_list:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure></li><li><p>方法：传入一个方法，根据方法来匹配</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def name_is_exists(tag):</span><br><span class="line">    <span class="keyword">return</span> tag.has_attr(<span class="string">&quot;name&quot;</span>)</span><br><span class="line"></span><br><span class="line">a_list = soup.find_all(name_is_exists)</span><br><span class="line"><span class="keyword">for</span> item in a_list:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure><h4 id="kwargs"><a href="#kwargs" class="headerlink" title="kwargs"></a>kwargs</h4><p>如果一个指定名字的参数不是搜索内置的参数名,搜索时会把该参数当作指定名字tag的属性来搜索</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询id=head的Tag</span></span><br><span class="line">t_list = soup.find_all(<span class="built_in">id</span>=<span class="string">&quot;head&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(t_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询href属性包含ss1.bdstatic.com的Tag</span></span><br><span class="line">t_list = soup.find_all(href=re.<span class="built_in">compile</span>(<span class="string">&quot;http://news.baidu.com&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(t_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询所有包含class的Tag(注：class要加上_进行区分)</span></span><br><span class="line">t_list = soup.find_all(class_=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> t_list:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure><h4 id="attrs"><a href="#attrs" class="headerlink" title="attrs"></a>attrs</h4><p>不是所有的属性都可以使用上面的方式进行搜索，比如HTML的data-*属性，这时可以使用attrs参数，定义一个字典来搜索包含特殊属性的tag。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t_list = soup.find_all(attrs=&#123;<span class="string">&quot;data-foo&quot;</span>:<span class="string">&quot;value&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> t_list:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure><h4 id="string-1"><a href="#string-1" class="headerlink" title="string"></a>string</h4><p>通过string参数可以搜索文档中的字符串内容，与name参数的可选值一样，string参数接收字符串，正则表达式，列表，True。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t_list = soup.find_all(string=<span class="string">&quot;Elsie&quot;</span>)</span><br><span class="line">    </span><br><span class="line">t_list = soup.find_all(string=[<span class="string">&quot;Tillie&quot;</span>, <span class="string">&quot;Elsie&quot;</span>, <span class="string">&quot;Lacie&quot;</span>])</span><br><span class="line"></span><br><span class="line">t_list = soup.find_all(string=re.<span class="built_in">compile</span>(<span class="string">&quot;Dormouse&quot;</span>))</span><br></pre></td></tr></table></figure><h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><p>传入一个limit参数来限制返回的数量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t_list = soup.find_all(<span class="string">&quot;a&quot;</span>, limit=<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> t_list:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure><h4 id="recursive"><a href="#recursive" class="headerlink" title="recursive"></a>recursive</h4><p>默认会检索当前tag的所有子孙节点，如果只想搜索直接子节点，可以使用该参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">soup.html.find_all(recursive=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>find( name , attrs , recursive , string , **kwargs )<br>返回符合条件的第一个Tag，即当我们要取一个值的时候就可以用该方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">soup.find(<span class="string">&quot;head&quot;</span>).find(<span class="string">&quot;title&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h3></li><li><p>通过tag标签名查找</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">soup.select(<span class="string">&quot;title&quot;</span>)</span><br><span class="line"></span><br><span class="line">soup.select(<span class="string">&quot;a&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>通过tag标签逐层查找：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">soup.select(<span class="string">&quot;body a&quot;</span>)</span><br><span class="line"></span><br><span class="line">soup.select(<span class="string">&quot;html head title&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>找到某个tag标签下的直接子标签：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">soup.select(<span class="string">&quot;head &gt; title&quot;</span>)</span><br><span class="line"></span><br><span class="line">soup.select(<span class="string">&quot;p &gt; #link1&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>找到兄弟节点标签：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">soup.select(<span class="string">&quot;#link1 ~ .sister&quot;</span>)</span><br><span class="line"></span><br><span class="line">soup.select(<span class="string">&quot;#link1 + .sister&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>通过class属性查找：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">soup.select(<span class="string">&quot;.sister&quot;</span>)</span><br><span class="line"></span><br><span class="line">soup.select(<span class="string">&quot;[class~=sister]&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>通过tag的id查找：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">soup.select(<span class="string">&#x27;#link1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">soup.select(<span class="string">&quot;a#link2&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>同时用多种css选择器查询：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">soup.select(<span class="string">&quot;#link1,#link2&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>通过是否存在某个属性来查找：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">soup.select(<span class="string">&quot;a[href]&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>通过属性的值来查找：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">soup.select(<span class="string">&#x27;a[href=&quot;http://example.com/elsie&quot;]&#x27;</span>)</span><br><span class="line"></span><br><span class="line">soup.select<span class="string">&#x27;a[href^=&quot;http://example.com&quot;]&#x27;</span>)</span><br><span class="line"></span><br><span class="line">soup.select(<span class="string">&#x27;a[href$=&quot;tillie&quot;]&#x27;</span>)</span><br><span class="line"></span><br><span class="line">soup.select(<span class="string">&#x27;a[href*=&quot;.com/el&quot;]&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>通过语言设置来查找：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">multilingual_markup = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"> &lt;p lang=&quot;en&quot;&gt;Hello&lt;/p&gt;</span></span><br><span class="line"><span class="string"> &lt;p lang=&quot;en-us&quot;&gt;Howdy, y&#x27;all&lt;/p&gt;</span></span><br><span class="line"><span class="string"> &lt;p lang=&quot;en-gb&quot;&gt;Pip-pip, old fruit&lt;/p&gt;</span></span><br><span class="line"><span class="string"> &lt;p lang=&quot;fr&quot;&gt;Bonjour mes amis&lt;/p&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">multilingual_soup = BeautifulSoup(multilingual_markup)</span><br><span class="line">multilingual_soup.select(<span class="string">&#x27;p[lang|=en]&#x27;</span>)</span><br><span class="line"><span class="comment"># [&lt;p lang=&quot;en&quot;&gt;Hello&lt;/p&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;p lang=&quot;en-us&quot;&gt;Howdy, y&#x27;all&lt;/p&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;p lang=&quot;en-gb&quot;&gt;Pip-pip, old fruit&lt;/p&gt;]</span></span><br></pre></td></tr></table></figure></li><li><p>返回查找到的元素的第一个</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">soup.select_one(<span class="string">&quot;.sister&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="修改文档树"><a href="#修改文档树" class="headerlink" title="修改文档树"></a>修改文档树</h2><p>BeautifulSoup的强项是文档树的搜索，但同时也可以方便的修改文档树，这部分可详细参考官方文档。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;h3 id=&quot;安装BeautifulSoup&quot;&gt;&lt;a href=&quot;#安装BeautifulSoup&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="python" scheme="https://zcej.github.io/categories/python/"/>
    
    <category term="爬虫" scheme="https://zcej.github.io/categories/python/%E7%88%AC%E8%99%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>项目实战：go语言实现redis(四)</title>
    <link href="https://zcej.github.io/2022/05/27/go/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%EF%BC%9Ago%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0redis(%E5%9B%9B)/"/>
    <id>https://zcej.github.io/2022/05/27/go/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%EF%BC%9Ago%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0redis(%E5%9B%9B)/</id>
    <published>2022-05-27T12:51:46.000Z</published>
    <updated>2022-06-28T15:48:16.023Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>本系列文章记录如何基于go语言实现Redis，从整体设计到具体细节实现，不仅可以有效的锻炼自己的编码能力，又能加深对redis的认识。文章主要从整体设计思路入手，记录关键的设计步骤，详细的实现可以参考<a href="https://github.com/zcej/go-redis">github</a>上的相关代码。主体上有下面几个部分：</p><ul><li>TCP服务器(一)：支持同时监听多个TCP连接，并进行相关处理</li><li>Redis协议解析器(一)：实现相关Handler，命令解析及响应处理</li><li>内存数据库(二)：实现数据库，注册相关命令，完成支持对数据库的增删改查</li><li>Redis持久化(三)：实现redis中的持久化功能aof</li><li>**Redis集群(四)**：本文将通过一致性哈希的方式实现cluster集群</li></ul><p>本章的项目目录结构如下，在前一篇的基础上新增了cluster相关文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">├─aof</span><br><span class="line">│</span><br><span class="line">├─cluster</span><br><span class="line">│  client_pool.go</span><br><span class="line">│  cluster_database.go</span><br><span class="line">│  com.go</span><br><span class="line">│  del.go</span><br><span class="line">│  keys.go</span><br><span class="line">│  ping.go</span><br><span class="line">│  rename.go</span><br><span class="line">│  router.go</span><br><span class="line">│</span><br><span class="line">├─config</span><br><span class="line">│</span><br><span class="line">├─database</span><br><span class="line">│</span><br><span class="line">├─datastruct</span><br><span class="line">│  └─dict</span><br><span class="line">│</span><br><span class="line">├─interface</span><br><span class="line">│  ├─database</span><br><span class="line">│  │</span><br><span class="line">│  ├─dict</span><br><span class="line">│  │</span><br><span class="line">│  ├─resp</span><br><span class="line">│  │</span><br><span class="line">│  └─tcp</span><br><span class="line">│</span><br><span class="line">├─lib</span><br><span class="line">│</span><br><span class="line">├─resp</span><br><span class="line">│  ├─connection</span><br><span class="line">│  │</span><br><span class="line">│  ├─handler</span><br><span class="line">│  │</span><br><span class="line">│  ├─parser</span><br><span class="line">│  │</span><br><span class="line">│  └─reply</span><br><span class="line">│</span><br><span class="line">├─tcp</span><br><span class="line">│</span><br><span class="line">│ go.mod</span><br><span class="line">│ main.go</span><br><span class="line">│ redis.conf</span><br></pre></td></tr></table></figure><h2 id="实现一致性hash"><a href="#实现一致性hash" class="headerlink" title="实现一致性hash"></a>实现一致性hash</h2><p>结构体定义<br />在文件<code>lib/comsistenthash/comsistenthash.go</code>中定义结构体<code>NodeMap</code>，包含下面几个属性，并进行初始化，此处设置了一个默认的哈希函数<code>crc32.ChecksumIEEE</code>。</p><ul><li><p><code>hashFunc</code>：类型为func，需要指定一个hash函数</p></li><li><p><code>nodeHashs</code>：类型为int类型的切片，存储节点哈希后的值，且该切片有序的</p></li><li><p><code>nodehashMap</code>：类型为map，key为哈希值，value是节点的地址</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashFunc defines function to generate hash code</span></span><br><span class="line"><span class="keyword">type</span> HashFunc <span class="function"><span class="keyword">func</span><span class="params">(data []<span class="type">byte</span>)</span></span> <span class="type">uint32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NodeMap stores nodes and you can pick node from NodeMap</span></span><br><span class="line"><span class="keyword">type</span> NodeMap <span class="keyword">struct</span> &#123;</span><br><span class="line">    hashFunc    HashFunc</span><br><span class="line">    nodeHashs   []<span class="type">int</span> <span class="comment">// sorted</span></span><br><span class="line">    nodehashMap <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewNodeMap creates a new NodeMap</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewNodeMap</span><span class="params">(fn HashFunc)</span></span> *NodeMap &#123;</span><br><span class="line">    m := &amp;NodeMap&#123;</span><br><span class="line">        hashFunc:    fn,</span><br><span class="line">        nodehashMap: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> m.hashFunc == <span class="literal">nil</span> &#123;</span><br><span class="line">        m.hashFunc = crc32.ChecksumIEEE</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法实现<br />需要实现添加节点到哈希环中和从哈希环取出节点的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IsEmpty returns if there is no node in NodeMap</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *NodeMap)</span></span> IsEmpty() <span class="type">bool</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AddNode add the given nodes into consistent hash circle</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *NodeMap)</span></span> AddNode(keys ...<span class="type">string</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PickNode gets the closest item in the hash to the provided key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *NodeMap)</span></span> PickNode(key <span class="type">string</span>) <span class="type">string</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="集群核心架构"><a href="#集群核心架构" class="headerlink" title="集群核心架构"></a>集群核心架构</h2><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><p>为了支持高并发的连接及能够对连接进行复用，此处引进了一个第三方连接池，通过命令<code>go get &quot;github.com/jolestar/go-commons-pool/v2&quot;</code>进行下载。另外，在<code>cluster/client_pool.go</code>中定义结构体<code>connectionFactory</code>实现其接口<code>PooledObjectFactory</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> connectionFactory <span class="keyword">struct</span> &#123;</span><br><span class="line">    Peer <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *connectionFactory)</span></span> MakeObject(ctx context.Context) (*pool.PooledObject, <span class="type">error</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *connectionFactory)</span></span> DestroyObject(ctx context.Context, object *pool.PooledObject) <span class="type">error</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *connectionFactory)</span></span> ValidateObject(ctx context.Context, object *pool.PooledObject) <span class="type">bool</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *connectionFactory)</span></span> ActivateObject(ctx context.Context, object *pool.PooledObject) <span class="type">error</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *connectionFactory)</span></span> PassivateObject(ctx context.Context, object *pool.PooledObject) <span class="type">error</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="实现ClusterDatabase"><a href="#实现ClusterDatabase" class="headerlink" title="实现ClusterDatabase"></a>实现ClusterDatabase</h3><p>需要对原来单体的Database进行进一步封装，新建文件<code>cluster/cluster_database.go</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClusterDatabase represents a node of godis cluster</span></span><br><span class="line"><span class="comment">// it holds part of data and coordinates other nodes to finish transactions</span></span><br><span class="line"><span class="keyword">type</span> ClusterDatabase <span class="keyword">struct</span> &#123;</span><br><span class="line">    self           <span class="type">string</span></span><br><span class="line"></span><br><span class="line">    nodes          []<span class="type">string</span></span><br><span class="line">    peerPicker     *consistenthash.NodeMap</span><br><span class="line">    peerConnection <span class="keyword">map</span>[<span class="type">string</span>]*pool.ObjectPool</span><br><span class="line">    db             databaseface.Database</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MakeClusterDatabase creates and starts a node of cluster</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeClusterDatabase</span><span class="params">()</span></span> *ClusterDatabase &#123;</span><br><span class="line">    cluster := &amp;ClusterDatabase&#123;</span><br><span class="line">        self: config.Properties.Self,</span><br><span class="line"></span><br><span class="line">        db:             database.NewStandaloneDatabase(),</span><br><span class="line">        peerPicker:     consistenthash.NewNodeMap(<span class="literal">nil</span>),</span><br><span class="line">        peerConnection: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*pool.ObjectPool),</span><br><span class="line">    &#125;</span><br><span class="line">    nodes := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(config.Properties.Peers)+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> _, peer := <span class="keyword">range</span> config.Properties.Peers &#123;</span><br><span class="line">        nodes = <span class="built_in">append</span>(nodes, peer)</span><br><span class="line">    &#125;</span><br><span class="line">    nodes = <span class="built_in">append</span>(nodes, config.Properties.Self)</span><br><span class="line">    cluster.peerPicker.AddNode(nodes...)</span><br><span class="line">    ctx := context.Background()</span><br><span class="line">    <span class="keyword">for</span> _, peer := <span class="keyword">range</span> config.Properties.Peers &#123;</span><br><span class="line">        cluster.peerConnection[peer] = pool.NewObjectPoolWithDefaultConfig(ctx, &amp;connectionFactory&#123;</span><br><span class="line">            Peer: peer,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    cluster.nodes = nodes</span><br><span class="line">    <span class="keyword">return</span> cluster</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外还需实现以下几个方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Close stops current node of cluster</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cluster *ClusterDatabase)</span></span> Close() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Exec executes command on cluster</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cluster *ClusterDatabase)</span></span> Exec(c resp.Connection, cmdLine [][]<span class="type">byte</span>) (result resp.Reply) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AfterClientClose does some clean after client close connection</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cluster *ClusterDatabase)</span></span> AfterClientClose(c resp.Connection) &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="操作连接池"><a href="#操作连接池" class="headerlink" title="操作连接池"></a>操作连接池</h3><p><code>cluster/com.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cluster *ClusterDatabase)</span></span> getPeerClient(peer <span class="type">string</span>) (*client.Client, <span class="type">error</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cluster *ClusterDatabase)</span></span> returnPeerClient(peer <span class="type">string</span>, peerClient *client.Client) <span class="type">error</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// relay relays command to peer</span></span><br><span class="line"><span class="comment">// select db by c.GetDBIndex()</span></span><br><span class="line"><span class="comment">// cannot call Prepare, Commit, execRollback of self node</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cluster *ClusterDatabase)</span></span> relay(peer <span class="type">string</span>, c resp.Connection, args [][]<span class="type">byte</span>) resp.Reply &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// broadcast broadcasts command to all node in cluster</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cluster *ClusterDatabase)</span></span> broadcast(c resp.Connection, args [][]<span class="type">byte</span>) <span class="keyword">map</span>[<span class="type">string</span>]resp.Reply &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="指令路由"><a href="#指令路由" class="headerlink" title="指令路由"></a>指令路由</h3><p>需要根据不同的指令，操作对应的节点，这里需要有一个全局的方式，找到执行指令的相关函数，新建文件<code>cluster/router.go</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeRouter</span><span class="params">()</span></span> <span class="keyword">map</span>[<span class="type">string</span>]CmdFunc &#123;</span><br><span class="line">    routerMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]CmdFunc)</span><br><span class="line">    routerMap[<span class="string">&quot;ping&quot;</span>] = ping</span><br><span class="line"></span><br><span class="line">    routerMap[<span class="string">&quot;del&quot;</span>] = Del</span><br><span class="line"></span><br><span class="line">    routerMap[<span class="string">&quot;exists&quot;</span>] = defaultFunc</span><br><span class="line">    routerMap[<span class="string">&quot;type&quot;</span>] = defaultFunc</span><br><span class="line">    routerMap[<span class="string">&quot;rename&quot;</span>] = Rename</span><br><span class="line">    routerMap[<span class="string">&quot;renamenx&quot;</span>] = Rename</span><br><span class="line"></span><br><span class="line">    routerMap[<span class="string">&quot;set&quot;</span>] = defaultFunc</span><br><span class="line">    routerMap[<span class="string">&quot;setnx&quot;</span>] = defaultFunc</span><br><span class="line">    routerMap[<span class="string">&quot;get&quot;</span>] = defaultFunc</span><br><span class="line">    routerMap[<span class="string">&quot;getset&quot;</span>] = defaultFunc</span><br><span class="line"></span><br><span class="line">    routerMap[<span class="string">&quot;flushdb&quot;</span>] = FlushDB</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> routerMap</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// relay command to responsible peer, and return its reply to client</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">defaultFunc</span><span class="params">(cluster *ClusterDatabase, c resp.Connection, args [][]<span class="type">byte</span>)</span></span> resp.Reply &#123;</span><br><span class="line">    key := <span class="type">string</span>(args[<span class="number">1</span>])</span><br><span class="line">    peer := cluster.peerPicker.PickNode(key)</span><br><span class="line">    <span class="keyword">return</span> cluster.relay(peer, c, args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改特殊的指令操作，分别在下述文件中添加对应的函数。</p></li><li><p><code>cluster/ping.go</code>：直接执行即可</p></li><li><p><code>cluster/del.go</code>：需要广播至集群的所有节点</p></li><li><p><code>cluster/rename.go</code>：需要找到键所在的节点执行，并处理重命名后更换节点的情况</p></li><li><p><code>cluster/keys.go</code>：需要广播至集群的所有节点</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ping</span><span class="params">(cluster *ClusterDatabase, c resp.Connection, cmdAndArgs [][]<span class="type">byte</span>)</span></span> resp.Reply &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Del atomically removes given writeKeys from cluster, writeKeys can be distributed on any node</span></span><br><span class="line"><span class="comment">// if the given writeKeys are distributed on different node, Del will use try-commit-catch to remove them</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Del</span><span class="params">(cluster *ClusterDatabase, c resp.Connection, args [][]<span class="type">byte</span>)</span></span> resp.Reply &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rename renames a key, the origin and the destination must within the same node</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Rename</span><span class="params">(cluster *ClusterDatabase, c resp.Connection, args [][]<span class="type">byte</span>)</span></span> resp.Reply &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FlushDB removes all data in current database</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FlushDB</span><span class="params">(cluster *ClusterDatabase, c resp.Connection, args [][]<span class="type">byte</span>)</span></span> resp.Reply &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="启用集群模式"><a href="#启用集群模式" class="headerlink" title="启用集群模式"></a>启用集群模式</h2><p>要使用集群需要修改<code>resp/handler/handler.go</code>中初始化Database的逻辑。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MakeHandler creates a RespHandler instance</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeHandler</span><span class="params">()</span></span> *RespHandler &#123;</span><br><span class="line">    <span class="keyword">var</span> db databaseface.Database</span><br><span class="line">    <span class="keyword">if</span> config.Properties.Self != <span class="string">&quot;&quot;</span> &amp;&amp;</span><br><span class="line">        <span class="built_in">len</span>(config.Properties.Peers) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        db = cluster.MakeClusterDatabase()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        db = database.NewStandaloneDatabase()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;RespHandler&#123;</span><br><span class="line">        db: db,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，基于go语言实现redis的项目已基本完成了。项目中有许多值得学习的地方，例如整个架构的设计，整体功能的切分及具体实现。每一步的过程都需要有自己的思考，而不是按部就班，随便记录以下就完了，记录下这个系列的文章，也是为了以后的回顾，温故而知新才能不断的加深影响提高自己。不过项目也依然有很多需要优化的地方，这个可以参考开源的项目<a href="https://github.com/HDT3213/godis">godis</a>。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;本系列文章记录如何基于go语言实现Redis，从整体设计到具体细节实现，不仅可以有效的锻炼自己的编码能力，又能加深对redis的认识。文章主</summary>
      
    
    
    
    <category term="go" scheme="https://zcej.github.io/categories/go/"/>
    
    <category term="项目实战" scheme="https://zcej.github.io/categories/go/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    
    
  </entry>
  
  <entry>
    <title>项目实战：go语言实现redis(三)</title>
    <link href="https://zcej.github.io/2022/05/21/go/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%EF%BC%9Ago%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0redis(%E4%B8%89)/"/>
    <id>https://zcej.github.io/2022/05/21/go/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%EF%BC%9Ago%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0redis(%E4%B8%89)/</id>
    <published>2022-05-21T02:14:09.000Z</published>
    <updated>2022-06-28T15:53:39.796Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>本系列文章记录如何基于go语言实现Redis，从整体设计到具体细节实现，不仅可以有效的锻炼自己的编码能力，又能加深对redis的认识。文章主要从整体设计思路入手，记录关键的设计步骤，详细的实现可以参考<a href="https://github.com/zcej/go-redis">github</a>上的相关代码。主体上有下面几个部分：</p><ul><li>TCP服务器(一)：支持同时监听多个TCP连接，并进行相关处理</li><li>Redis协议解析器(一)：实现相关Handler，命令解析及响应处理</li><li>内存数据库(二)：实现数据库，注册相关命令，完成支持对数据库的增删改查</li><li>**Redis持久化(三)**：实现redis中的持久化功能aof</li><li>Redis集群(四)</li></ul><p>本章的项目目录结构如下，主要是在前一篇文章新增了aof相关文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">├─aof</span><br><span class="line">│  aof.go</span><br><span class="line">│</span><br><span class="line">├─config</span><br><span class="line">│</span><br><span class="line">├─database</span><br><span class="line">│</span><br><span class="line">├─datastruct</span><br><span class="line">│  └─dict</span><br><span class="line">│</span><br><span class="line">├─interface</span><br><span class="line">│  ├─database</span><br><span class="line">│  │</span><br><span class="line">│  ├─dict</span><br><span class="line">│  │</span><br><span class="line">│  ├─resp</span><br><span class="line">│  │</span><br><span class="line">│  └─tcp</span><br><span class="line">│</span><br><span class="line">├─lib</span><br><span class="line">│</span><br><span class="line">├─resp</span><br><span class="line">│  ├─connection</span><br><span class="line">│  │</span><br><span class="line">│  ├─handler</span><br><span class="line">│  │</span><br><span class="line">│  ├─parser</span><br><span class="line">│  │</span><br><span class="line">│  └─reply</span><br><span class="line">│</span><br><span class="line">├─tcp</span><br><span class="line">│ </span><br><span class="line">│ go.mod</span><br><span class="line">│ main.go</span><br><span class="line">│ redis.conf</span><br></pre></td></tr></table></figure><h2 id="命令记录与恢复"><a href="#命令记录与恢复" class="headerlink" title="命令记录与恢复"></a>命令记录与恢复</h2><p>需要实现一个<code>AofHandler</code>结构体，由它封装命令保存及数据恢复的相关方法，然后在初始化Database的时候将AofHandler进行注册。在文件<code>aof/aof.go</code>中的实现如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CmdLine is alias for [][]byte, represents a command line</span></span><br><span class="line"><span class="keyword">type</span> CmdLine = [][]<span class="type">byte</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> payload <span class="keyword">struct</span> &#123;</span><br><span class="line">    cmdLine CmdLine</span><br><span class="line">    dbIndex <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AofHandler receive msgs from channel and write to AOF file</span></span><br><span class="line"><span class="keyword">type</span> AofHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">    db          databaseface.Database</span><br><span class="line">    aofChan     <span class="keyword">chan</span> *payload</span><br><span class="line">    aofFile     *os.File</span><br><span class="line">    aofFilename <span class="type">string</span></span><br><span class="line">    currentDB   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外初始化<code>AofHandler</code>的时候还需要考虑根据已有的Aof文件进行恢复，以及启用一个协程不断的记录执行过的命令。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewAOFHandler creates a new aof.AofHandler</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAOFHandler</span><span class="params">(db databaseface.Database)</span></span> (*AofHandler, <span class="type">error</span>) &#123;</span><br><span class="line">    handler := &amp;AofHandler&#123;&#125;</span><br><span class="line">    handler.aofFilename = config.Properties.AppendFilename</span><br><span class="line">    handler.db = db</span><br><span class="line">    handler.LoadAof()</span><br><span class="line">    aofFile, err := os.OpenFile(handler.aofFilename, os.O_APPEND|os.O_CREATE|os.O_RDWR, <span class="number">0600</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    handler.aofFile = aofFile</span><br><span class="line">    handler.aofChan = <span class="built_in">make</span>(<span class="keyword">chan</span> *payload, aofQueueSize)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        handler.handleAof()</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> handler, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外还需实现下述方法：</p><ul><li><code>AddAof</code>：如果配置中开启Aof的话，将执行的命令发送到channel中</li><li><code>handleAof</code>：从channel中读取数据，并写入到文件当中</li><li><code>LoadAof</code>：从文件中读取命令，然后执行<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AddAof send command to aof goroutine through channel</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(handler *AofHandler)</span></span> AddAof(dbIndex <span class="type">int</span>, cmdLine CmdLine) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// handleAof listen aof channel and write into file</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(handler *AofHandler)</span></span> handleAof() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LoadAof read aof file</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(handler *AofHandler)</span></span> LoadAof() &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="底层指令集修改"><a href="#底层指令集修改" class="headerlink" title="底层指令集修改"></a>底层指令集修改</h2>首先修改<code>database/db.go</code>中的结构体DB，新增属性addAof，以便指令集中的方法能够调用到addAof，需要修改的地方如下，另外初始化该方法的工作将在后续完成。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DB stores data and execute user&#x27;s commands</span></span><br><span class="line"><span class="keyword">type</span> DB <span class="keyword">struct</span> &#123;</span><br><span class="line">    index  <span class="type">int</span></span><br><span class="line">    data   iDict.Dict <span class="comment">// key -&gt; DataEntity</span></span><br><span class="line">    addAof <span class="function"><span class="keyword">func</span><span class="params">(CmdLine)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// makeDB create DB instance</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeDB</span><span class="params">()</span></span> *DB &#123;</span><br><span class="line">    db := &amp;DB&#123;</span><br><span class="line">        data: dict.MakeSyncDict(),</span><br><span class="line">        addAof: <span class="function"><span class="keyword">func</span><span class="params">(line CmdLine)</span></span> &#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> db</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>在<code>database/string.go</code>中对应的需要记录该指令的方法中添加<code>Addof</code>：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// execSet sets string value and time to live to the given key</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execSet</span><span class="params">(db *DB, args [][]<span class="type">byte</span>)</span></span> resp.Reply &#123;</span><br><span class="line">    ...</span><br><span class="line">    db.addAof(utils.ToCmdLine2(<span class="string">&quot;set&quot;</span>, args...))</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// execSetNX sets string if not exists</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execSetNX</span><span class="params">(db *DB, args [][]<span class="type">byte</span>)</span></span> resp.Reply &#123;</span><br><span class="line">    ...</span><br><span class="line">    db.addAof(utils.ToCmdLine2(<span class="string">&quot;setnx&quot;</span>, args...))</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>注：同样的<code>database/keys.go</code>中的相关方法也许调用<code>Addof</code>方法。</p></blockquote></li></ul><h2 id="调用AofHandler"><a href="#调用AofHandler" class="headerlink" title="调用AofHandler"></a>调用AofHandler</h2><p>初始化database时将<code>AofHandler</code>注册到Database结构体中，然后把方法<code>Addof</code>赋值给DB结构体，这样上述指令集就能调用到该方法了。文件<code>database/databse.go</code>中需要修改的地方如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Database is a set of multiple database set</span></span><br><span class="line"><span class="keyword">type</span> Database <span class="keyword">struct</span> &#123;</span><br><span class="line">    dbSet      []*DB</span><br><span class="line">    aofHandler *aof.AofHandler <span class="comment">// handle aof persistence</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewDatabase creates a redis database,</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDatabase</span><span class="params">()</span></span> *Database &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> config.Properties.AppendOnly &#123;</span><br><span class="line">        aofHandler, err := aof.NewAOFHandler(mdb)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line">        mdb.aofHandler = aofHandler</span><br><span class="line">        <span class="keyword">for</span> _, db := <span class="keyword">range</span> mdb.dbSet &#123;</span><br><span class="line">            <span class="comment">// avoid closure</span></span><br><span class="line">            singleDB := db</span><br><span class="line">            singleDB.addAof = <span class="function"><span class="keyword">func</span><span class="params">(line CmdLine)</span></span> &#123;</span><br><span class="line">                mdb.aofHandler.AddAof(singleDB.index, line)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mdb</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：上述for循环遍历数据库的切片时，需要暂时把db赋值给一个临时变量，不然拿到的db都是最后一个值，这是go语言中循环变量的作用域导致的，需要注意。</p><ul><li>在go语言的for循环中，循环内部创建的函数变量都是共享同一内存地址，for循环总是使用同一块内存去接收循环中的变量的值。不管循环多少次，变量的内存地址都是相同的。</li><li>此处使用的解决方法就是用一个临时变量进行赋值保存记录。</li></ul></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>redis支持两种持久化的方式，一种是aof，它对数据有修改的相关指令记录到文件中，重新执行这些命令达到数据恢复的效果。另一种是rdb，这种方式是记录了内存快照，在指定的时间间隔内，将内存中的数据写入到磁盘中，就是在指定目录下生产一个dump.rdb文件，通过加载该文件进行恢复数据。本文基于go语言实现了aof持久化功能，通过可插拔的方式集成到之前已基本实现的单体redis当中。接下来将实现redis的集群模式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;本系列文章记录如何基于go语言实现Redis，从整体设计到具体细节实现，不仅可以有效的锻炼自己的编码能力，又能加深对redis的认识。文章主</summary>
      
    
    
    
    <category term="go" scheme="https://zcej.github.io/categories/go/"/>
    
    <category term="项目实战" scheme="https://zcej.github.io/categories/go/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    
    
  </entry>
  
  <entry>
    <title>项目实战：go语言实现redis(二)</title>
    <link href="https://zcej.github.io/2022/05/12/go/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%EF%BC%9Ago%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0redis(%E4%BA%8C)/"/>
    <id>https://zcej.github.io/2022/05/12/go/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%EF%BC%9Ago%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0redis(%E4%BA%8C)/</id>
    <published>2022-05-12T15:06:31.000Z</published>
    <updated>2022-06-28T15:56:20.131Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>本系列文章记录如何基于go语言实现Redis，从整体设计到具体细节实现，不仅可以有效的锻炼自己的编码能力，又能加深对redis的认识。文章主要从整体设计思路入手，记录关键的设计步骤，详细的实现可以参考<a href="https://github.com/zcej/go-redis">github</a>上的相关代码。主体上有下面几个部分：</p><ul><li>TCP服务器(一)：支持同时监听多个TCP连接，并进行相关处理</li><li>Redis协议解析器(一)：实现相关Handler，命令解析及响应处理</li><li>**内存数据库(二)**：实现数据库，注册相关命令，完成支持对数据库的增删改查</li><li>Redis持久化(三)</li><li>Redis集群(四)</li></ul><p>本章的项目目录结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">├─config</span><br><span class="line">│</span><br><span class="line">├─database</span><br><span class="line">│  command.go</span><br><span class="line">│  database.go</span><br><span class="line">│  db.go</span><br><span class="line">│  echo_database.go</span><br><span class="line">│  keys.go</span><br><span class="line">│  ping.go</span><br><span class="line">│  string.go</span><br><span class="line">│</span><br><span class="line">├─datastruct</span><br><span class="line">│  └─dict</span><br><span class="line">│     simple_dict.go</span><br><span class="line">│     sync_dict.go</span><br><span class="line">│</span><br><span class="line">├─interface</span><br><span class="line">│  ├─database</span><br><span class="line">│  │</span><br><span class="line">│  ├─dict</span><br><span class="line">│  │  dict.go</span><br><span class="line">│  │</span><br><span class="line">│  ├─resp</span><br><span class="line">│  │</span><br><span class="line">│  └─tcp</span><br><span class="line">│</span><br><span class="line">├─lib</span><br><span class="line">│</span><br><span class="line">├─resp</span><br><span class="line">│  ├─connection</span><br><span class="line">│  │</span><br><span class="line">│  ├─handler</span><br><span class="line">│  │</span><br><span class="line">│  ├─parser</span><br><span class="line">│  │</span><br><span class="line">│  └─reply</span><br><span class="line">│</span><br><span class="line">├─tcp</span><br><span class="line">│ </span><br><span class="line">│ go.mod</span><br><span class="line">│ main.go</span><br><span class="line">│ redis.conf</span><br></pre></td></tr></table></figure><h2 id="数据底层存储"><a href="#数据底层存储" class="headerlink" title="数据底层存储"></a>数据底层存储</h2><h3 id="定义及实现Dict接口"><a href="#定义及实现Dict接口" class="headerlink" title="定义及实现Dict接口"></a>定义及实现Dict接口</h3><p>在<code>interface/dict/dict.go</code>中定义Dict接口，包含下述方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Consumer is used to traversal dict, if it returns false the traversal will be break</span></span><br><span class="line"><span class="keyword">type</span> Consumer <span class="function"><span class="keyword">func</span><span class="params">(key <span class="type">string</span>, val <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Dict is interface of a key-value data structure</span></span><br><span class="line"><span class="keyword">type</span> Dict <span class="keyword">interface</span> &#123;</span><br><span class="line">    Get(key <span class="type">string</span>) (val <span class="keyword">interface</span>&#123;&#125;, exists <span class="type">bool</span>)</span><br><span class="line">    Len() <span class="type">int</span></span><br><span class="line">    Put(key <span class="type">string</span>, val <span class="keyword">interface</span>&#123;&#125;) (result <span class="type">int</span>)</span><br><span class="line">    PutIfAbsent(key <span class="type">string</span>, val <span class="keyword">interface</span>&#123;&#125;) (result <span class="type">int</span>)</span><br><span class="line">    PutIfExists(key <span class="type">string</span>, val <span class="keyword">interface</span>&#123;&#125;) (result <span class="type">int</span>)</span><br><span class="line">    Remove(key <span class="type">string</span>) (result <span class="type">int</span>)</span><br><span class="line">    ForEach(consumer Consumer)</span><br><span class="line">    Keys() []<span class="type">string</span></span><br><span class="line">    RandomKeys(limit <span class="type">int</span>) []<span class="type">string</span></span><br><span class="line">    RandomDistinctKeys(limit <span class="type">int</span>) []<span class="type">string</span></span><br><span class="line">    Clear()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在<code>datastruct/dict/sync_dict.go</code>中实现一个并发安全的dict。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SyncDict wraps a map, it is not thread safe</span></span><br><span class="line"><span class="keyword">type</span> SyncDict <span class="keyword">struct</span> &#123;</span><br><span class="line">    m sync.Map</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MakeSyncDict makes a new map</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeSyncDict</span><span class="params">()</span></span> *SyncDict &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;SyncDict&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get returns the binding value and whether the key is exist</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dict *SyncDict)</span></span> Get(key <span class="type">string</span>) (val <span class="keyword">interface</span>&#123;&#125;, exists <span class="type">bool</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Len returns the number of dict</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dict *SyncDict)</span></span> Len() <span class="type">int</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Put puts key value into dict and returns the number of new inserted key-value</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dict *SyncDict)</span></span> Put(key <span class="type">string</span>, val <span class="keyword">interface</span>&#123;&#125;) (result <span class="type">int</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PutIfAbsent puts value if the key is not exists and returns the number of updated key-value</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dict *SyncDict)</span></span> PutIfAbsent(key <span class="type">string</span>, val <span class="keyword">interface</span>&#123;&#125;) (result <span class="type">int</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PutIfExists puts value if the key is exist and returns the number of inserted key-value</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dict *SyncDict)</span></span> PutIfExists(key <span class="type">string</span>, val <span class="keyword">interface</span>&#123;&#125;) (result <span class="type">int</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove removes the key and return the number of deleted key-value</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dict *SyncDict)</span></span> Remove(key <span class="type">string</span>) (result <span class="type">int</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Keys returns all keys in dict</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dict *SyncDict)</span></span> Keys() []<span class="type">string</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ForEach traversal the dict</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dict *SyncDict)</span></span> ForEach(consumer iDict.Consumer) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RandomKeys randomly returns keys of the given number, may contain duplicated key</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dict *SyncDict)</span></span> RandomKeys(limit <span class="type">int</span>) []<span class="type">string</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RandomDistinctKeys randomly returns keys of the given number, won&#x27;t contain duplicated key</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dict *SyncDict)</span></span> RandomDistinctKeys(limit <span class="type">int</span>) []<span class="type">string</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clear removes all keys in dict</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dict *SyncDict)</span></span> Clear() &#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：非并发安全的实现可参考<code>datastruct/dict/simple_dict.go</code></p></blockquote><h3 id="定义DB结构体"><a href="#定义DB结构体" class="headerlink" title="定义DB结构体"></a>定义DB结构体</h3><p>在<code>database/db.go</code>定义DB结构体，它是对底层<code>Dict</code>相关操作的进一步封装，根据接收到的实际命令找到对应的方法并执行，其核心是<code>Exec</code>方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DB stores data and execute user&#x27;s commands</span></span><br><span class="line"><span class="keyword">type</span> DB <span class="keyword">struct</span> &#123;</span><br><span class="line">    index <span class="type">int</span></span><br><span class="line">    data  dict.Dict <span class="comment">// key -&gt; DataEntity</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// makeDB create DB instance</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeDB</span><span class="params">()</span></span> *DB &#123;</span><br><span class="line">    db := &amp;DB&#123;data: dict.MakeSyncDict()&#125;</span><br><span class="line">    <span class="keyword">return</span> db</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Exec executes command within one database</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Exec(c resp.Connection, cmdLine [][]<span class="type">byte</span>) resp.Reply &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetEntity returns DataEntity bind to given key</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> GetEntity(key <span class="type">string</span>) (*database.DataEntity, <span class="type">bool</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PutEntity a DataEntity into DB</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> PutEntity(key <span class="type">string</span>, entity *database.DataEntity) <span class="type">int</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PutIfExists edit an existing DataEntity</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> PutIfExists(key <span class="type">string</span>, entity *database.DataEntity) <span class="type">int</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove the given key from db</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Remove(key <span class="type">string</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Removes the given keys from db</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Removes(keys ...<span class="type">string</span>) (deleted <span class="type">int</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Flush clean database</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Flush() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validateArity</span><span class="params">(arity <span class="type">int</span>, cmdArgs [][]<span class="type">byte</span>)</span></span> <span class="type">bool</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="命令注册及实现"><a href="#命令注册及实现" class="headerlink" title="命令注册及实现"></a>命令注册及实现</h2><h3 id="命令的注册"><a href="#命令的注册" class="headerlink" title="命令的注册"></a>命令的注册</h3><p><code>database/command.go</code>主要包含以下三个部分：</p><ul><li><code>cmdTable</code>：类型为字典，功能为存储命令及对应命令的结构体</li><li><code>command</code>：类型为结构体，包含命令对应的实际方法以及参数数量</li><li><code>RegisterCommand</code>：类型为一个函数，用于实现命令注册全局表中<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cmdTable = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*command)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> command <span class="keyword">struct</span> &#123;</span><br><span class="line">    executor ExecFunc</span><br><span class="line">    arity    <span class="type">int</span> <span class="comment">// allow number of args, arity &lt; 0 means len(args) &gt;= -arity</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RegisterCommand registers a new command</span></span><br><span class="line"><span class="comment">// arity means allowed number of cmdArgs, arity &lt; 0 means len(args) &gt;= -arity.</span></span><br><span class="line"><span class="comment">// for example: the arity of `get` is 2, `mget` is -2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterCommand</span><span class="params">(name <span class="type">string</span>, executor ExecFunc, arity <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    name = strings.ToLower(name)</span><br><span class="line">    cmdTable[name] = &amp;command&#123;</span><br><span class="line">        executor: executor,</span><br><span class="line">        arity:    arity,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="命令的实现"><a href="#命令的实现" class="headerlink" title="命令的实现"></a>命令的实现</h3><h4 id="ping的实现与注册"><a href="#ping的实现与注册" class="headerlink" title="ping的实现与注册"></a>ping的实现与注册</h4>在文件<code>database/ping.go</code>中的<code>init()</code>方法下将命令及其对应的处理函数注册到全局表中：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    RegisterCommand(<span class="string">&quot;ping&quot;</span>, Ping, <span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ping the server</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Ping</span><span class="params">(db *DB, args [][]<span class="type">byte</span>)</span></span> resp.Reply &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="keys指令集的实现与注册"><a href="#keys指令集的实现与注册" class="headerlink" title="keys指令集的实现与注册"></a>keys指令集的实现与注册</h4>在文件<code>database/keys.go</code>中的<code>init()</code>方法下将命令及其对应的处理函数注册到全局表中：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    RegisterCommand(<span class="string">&quot;Del&quot;</span>, execDel, <span class="number">-2</span>)</span><br><span class="line">    RegisterCommand(<span class="string">&quot;Exists&quot;</span>, execExists, <span class="number">-2</span>)</span><br><span class="line">    RegisterCommand(<span class="string">&quot;Keys&quot;</span>, execKeys, <span class="number">2</span>)</span><br><span class="line">    RegisterCommand(<span class="string">&quot;FlushDB&quot;</span>, execFlushDB, <span class="number">-1</span>)</span><br><span class="line">    RegisterCommand(<span class="string">&quot;Type&quot;</span>, execType, <span class="number">2</span>)</span><br><span class="line">    RegisterCommand(<span class="string">&quot;Rename&quot;</span>, execRename, <span class="number">3</span>)</span><br><span class="line">    RegisterCommand(<span class="string">&quot;RenameNx&quot;</span>, execRenameNx, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>并实现相关函数：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// execDel removes a key from db</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execDel</span><span class="params">(db *DB, args [][]<span class="type">byte</span>)</span></span> resp.Reply &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// execExists checks if a is existed in db</span></span><br><span class="line"><span class="function"><span class="keyword">func</span>  <span class="title">execExists</span><span class="params">(db *DB, args [][]<span class="type">byte</span>)</span></span> resp.Reply &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// execFlushDB removes all data in current db</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execFlushDB</span><span class="params">(db *DB, args [][]<span class="type">byte</span>)</span></span> resp.Reply &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// execType returns the type of entity, including: string, list, hash, set and zset</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execType</span><span class="params">(db *DB, args [][]<span class="type">byte</span>)</span></span> resp.Reply &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// execRename a key</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execRename</span><span class="params">(db *DB, args [][]<span class="type">byte</span>)</span></span> resp.Reply &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// execRenameNx a key, only if the new key does not exist</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execRenameNx</span><span class="params">(db *DB, args [][]<span class="type">byte</span>)</span></span> resp.Reply &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// execKeys returns all keys matching the given pattern</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execKeys</span><span class="params">(db *DB, args [][]<span class="type">byte</span>)</span></span> resp.Reply &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="string指令集的实现与注册"><a href="#string指令集的实现与注册" class="headerlink" title="string指令集的实现与注册"></a>string指令集的实现与注册</h4>在文件<code>database/string.go</code>中的<code>init()</code>方法下将命令及其对应的处理函数注册到全局表中：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    RegisterCommand(<span class="string">&quot;Get&quot;</span>, execGet, <span class="number">2</span>)</span><br><span class="line">    RegisterCommand(<span class="string">&quot;Set&quot;</span>, execSet, <span class="number">-3</span>)</span><br><span class="line">    RegisterCommand(<span class="string">&quot;SetNx&quot;</span>, execSetNX, <span class="number">3</span>)</span><br><span class="line">    RegisterCommand(<span class="string">&quot;GetSet&quot;</span>, execGetSet, <span class="number">3</span>)</span><br><span class="line">    RegisterCommand(<span class="string">&quot;StrLen&quot;</span>, execStrLen, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>并实现相关函数：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> getAsString(key <span class="type">string</span>) ([]<span class="type">byte</span>, reply.ErrorReply) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// execGet returns string value bound to the given key</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execGet</span><span class="params">(db *DB, args [][]<span class="type">byte</span>)</span></span> resp.Reply &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// execSet sets string value and time to live to the given key</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execSet</span><span class="params">(db *DB, args [][]<span class="type">byte</span>)</span></span> resp.Reply &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// execSetNX sets string if not exists</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execSetNX</span><span class="params">(db *DB, args [][]<span class="type">byte</span>)</span></span> resp.Reply &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// execGetSet sets value of a string-type key and returns its old value</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execGetSet</span><span class="params">(db *DB, args [][]<span class="type">byte</span>)</span></span> resp.Reply &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// execStrLen returns len of string value bound to the given key</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execStrLen</span><span class="params">(db *DB, args [][]<span class="type">byte</span>)</span></span> resp.Reply &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="实现数据库核心"><a href="#实现数据库核心" class="headerlink" title="实现数据库核心"></a>实现数据库核心</h2>在<code>database/database.go</code>中定义结构体Database，需实现第一篇文章中定义的Database接口，并进行初始化，创建16个数据库表，另外还需要注意执行命令时所在db的选择，这里封装了一个选择db的函数<code>execSelect</code>。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Database is a set of multiple database set</span></span><br><span class="line"><span class="keyword">type</span> Database <span class="keyword">struct</span> &#123;</span><br><span class="line">    dbSet []*DB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewDatabase creates a redis database,</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDatabase</span><span class="params">()</span></span> *Database &#123;</span><br><span class="line">    mdb := &amp;Database&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> config.Properties.Databases == <span class="number">0</span> &#123;</span><br><span class="line">        config.Properties.Databases = <span class="number">16</span></span><br><span class="line">    &#125;</span><br><span class="line">    mdb.dbSet = <span class="built_in">make</span>([]*DB, config.Properties.Databases)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> mdb.dbSet &#123;</span><br><span class="line">        singleDB := makeDB()</span><br><span class="line">        singleDB.index = i</span><br><span class="line">        mdb.dbSet[i] = singleDB</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mdb</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Exec executes command</span></span><br><span class="line"><span class="comment">// parameter `cmdLine` contains command and its arguments, for example: &quot;set key value&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mdb *Database)</span></span> Exec(c resp.Connection, cmdLine [][]<span class="type">byte</span>) (result resp.Reply) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close graceful shutdown database</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mdb *Database)</span></span> Close() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mdb *Database)</span></span> AfterClientClose(c resp.Connection) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execSelect</span><span class="params">(c resp.Connection, mdb *Database, args [][]<span class="type">byte</span>)</span></span> resp.Reply &#123;&#125;</span><br></pre></td></tr></table></figure>然后将<code>resp/handler/handler.go</code>中的初始化数据库改为上述实现的数据库即可。<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>到目前为止一个单体的redis应用已基本完成，可以暂不关注每个方法的具体实现，但是一定要理解整个调用逻辑，做到融会贯通。首先处理TCP连接，选择对应的handler，由handler初始化database，同时对conn封装，选择对应的数据库执行命令，在项目一开始运行的时候会将代码中已实现的命令注册到全局表中。接下来将实现redis的持久化与集群的相关功能。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;本系列文章记录如何基于go语言实现Redis，从整体设计到具体细节实现，不仅可以有效的锻炼自己的编码能力，又能加深对redis的认识。文章主</summary>
      
    
    
    
    <category term="go" scheme="https://zcej.github.io/categories/go/"/>
    
    <category term="项目实战" scheme="https://zcej.github.io/categories/go/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    
    
  </entry>
  
  <entry>
    <title>项目实战：go语言实现redis(一)</title>
    <link href="https://zcej.github.io/2022/05/08/go/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%EF%BC%9Ago%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0redis(%E4%B8%80)/"/>
    <id>https://zcej.github.io/2022/05/08/go/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%EF%BC%9Ago%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0redis(%E4%B8%80)/</id>
    <published>2022-05-08T14:41:18.000Z</published>
    <updated>2022-06-28T16:06:11.479Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>本系列文章记录如何基于go语言实现Redis，从整体设计到具体细节实现，不仅可以有效的锻炼自己的编码能力，又能加深对redis的认识。文章主要从整体设计思路入手，记录关键的设计步骤，详细的实现可以参考<a href="https://github.com/zcej/go-redis">github</a>上的相关代码。主体上有下面几个部分：</p><ul><li><p>**TCP服务器(一)**：支持同时监听多个TCP连接，并进行相关处理</p></li><li><p>**Redis协议解析器(一)**：实现相关Handler，命令解析及响应处理</p></li><li><p>内存数据库(二)</p></li><li><p>Redis持久化(三)</p></li><li><p>Redis集群(四)</p><h2 id="实现TCP服务器"><a href="#实现TCP服务器" class="headerlink" title="实现TCP服务器"></a>实现TCP服务器</h2><p>项目初始化，主要包括相关配置，日志处理，以及定义相关接口或结构体。当前目录结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">├─config</span><br><span class="line">│  config.go</span><br><span class="line">│</span><br><span class="line">├─interface</span><br><span class="line">│  └─tcp</span><br><span class="line">│     handler.go</span><br><span class="line">│</span><br><span class="line">├─lib</span><br><span class="line">│</span><br><span class="line">├─tcp</span><br><span class="line">│   echo.go</span><br><span class="line">│   server.go</span><br><span class="line">│ </span><br><span class="line">| go.mod</span><br><span class="line">| main.go</span><br><span class="line">| redis.conf</span><br></pre></td></tr></table></figure><h3 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h3><h4 id="配置文件解析"><a href="#配置文件解析" class="headerlink" title="配置文件解析"></a>配置文件解析</h4><p>在<code>config/config.go</code>文件中定义Redis相关服务端属性如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> config</span><br><span class="line"></span><br><span class="line"><span class="comment">// ServerProperties defines global config properties</span></span><br><span class="line"><span class="keyword">type</span> ServerProperties <span class="keyword">struct</span> &#123;</span><br><span class="line">    Bind           <span class="type">string</span>   <span class="string">`cfg:&quot;bind&quot;`</span></span><br><span class="line">    Port           <span class="type">int</span>      <span class="string">`cfg:&quot;port&quot;`</span></span><br><span class="line">    AppendOnly     <span class="type">bool</span>     <span class="string">`cfg:&quot;appendOnly&quot;`</span></span><br><span class="line">    AppendFilename <span class="type">string</span>   <span class="string">`cfg:&quot;appendFilename&quot;`</span></span><br><span class="line">    MaxClients     <span class="type">int</span>      <span class="string">`cfg:&quot;maxclients&quot;`</span></span><br><span class="line">    RequirePass    <span class="type">string</span>   <span class="string">`cfg:&quot;requirepass&quot;`</span></span><br><span class="line">    Databases      <span class="type">int</span>      <span class="string">`cfg:&quot;databases&quot;`</span></span><br><span class="line"></span><br><span class="line">    Peers          []<span class="type">string</span> <span class="string">`cfg:&quot;peers&quot;`</span></span><br><span class="line">    Self           <span class="type">string</span>   <span class="string">`cfg:&quot;self&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Properties holds global config properties</span></span><br><span class="line"><span class="keyword">var</span> Properties *ServerProperties</span><br></pre></td></tr></table></figure><p>另外，还需要实现配置文件解析的相关方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SetupConfig read config file and store properties into Properties</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetupConfig</span><span class="params">(configFilename <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    file, err := os.Open(configFilename)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    Properties = parse(file)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parse</span><span class="params">(src io.Reader)</span></span> *ServerProperties &#123;</span><br><span class="line">    config := &amp;ServerProperties&#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了防止没有配置文件的情况下也能正常初始化，可以添加如下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// default config</span></span><br><span class="line">    Properties = &amp;ServerProperties&#123;</span><br><span class="line">        Bind:       <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">        Port:       <span class="number">6379</span>,</span><br><span class="line">        AppendOnly: <span class="literal">false</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h4><p>在<code>interface/tcp/handler.go</code>中需要定义相关接口，以规范化处理tcp的连接：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handler represents application server over tcp</span></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">    Handle(ctx context.Context, conn net.Conn)</span><br><span class="line">    Close() <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TCP服务实现"><a href="#TCP服务实现" class="headerlink" title="TCP服务实现"></a>TCP服务实现</h3><h4 id="并发处理tcp连接"><a href="#并发处理tcp连接" class="headerlink" title="并发处理tcp连接"></a>并发处理tcp连接</h4><p>在<code>tcp/server.go</code>中实现以下两个函数，用于处理tcp连接，此处主要依赖标准库<code>net</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Config stores tcp handler properties</span></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">    Address    <span class="type">string</span>        <span class="string">`yaml:&quot;address&quot;`</span></span><br><span class="line">    MaxConnect <span class="type">uint32</span>        <span class="string">`yaml:&quot;max-connect&quot;`</span></span><br><span class="line">    Timeout    time.Duration <span class="string">`yaml:&quot;timeout&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ListenAndServeWithSignal binds port and handle requests, blocking until receive stop signal</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServeWithSignal</span><span class="params">(cfg *Config, handler tcp.Handler)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    closeChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    ...</span><br><span class="line">    listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, cfg.Address)</span><br><span class="line">    ...</span><br><span class="line">    ListenAndServe(listener, handler, closeChan)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ListenAndServe binds port and handle requests, blocking until close</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(listener net.Listener, handler tcp.Handler, closeChan &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        &lt;-closeChan</span><br><span class="line">        listener.Close()</span><br><span class="line">        handler.Close()</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        conn, err := listener.Accept()</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            handler.Handle(ctx, conn)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="main函数入口实现"><a href="#main函数入口实现" class="headerlink" title="main函数入口实现"></a>main函数入口实现</h4><p>此时<code>main.go</code>中需要调用的函数已基本实现，后续修改只需传入对应的Handler即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;go-redis/config&quot;</span></span><br><span class="line">    <span class="string">&quot;go-redis/lib/logger&quot;</span></span><br><span class="line">    <span class="string">&quot;go-redis/tcp&quot;</span></span><br><span class="line">    EchoHandler <span class="string">&quot;go-redis/tcp&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> configFile <span class="type">string</span> = <span class="string">&quot;redis.conf&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> defaultProperties = &amp;config.ServerProperties&#123;</span><br><span class="line">    Bind: <span class="string">&quot;0.0.0.0&quot;</span>,</span><br><span class="line">    Port: <span class="number">6379</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fileExists</span><span class="params">(filename <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    info, err := os.Stat(filename)</span><br><span class="line">    <span class="keyword">return</span> err == <span class="literal">nil</span> &amp;&amp; !info.IsDir()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    logger.Setup(&amp;logger.Settings&#123;</span><br><span class="line">        Path:       <span class="string">&quot;logs&quot;</span>,</span><br><span class="line">        Name:       <span class="string">&quot;godis&quot;</span>,</span><br><span class="line">        Ext:        <span class="string">&quot;log&quot;</span>,</span><br><span class="line">        TimeFormat: <span class="string">&quot;2006-01-02&quot;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> fileExists(configFile) &#123;</span><br><span class="line">        config.SetupConfig(configFile)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        config.Properties = defaultProperties</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err := tcp.ListenAndServeWithSignal(</span><br><span class="line">        &amp;tcp.Config&#123;</span><br><span class="line">            Address: fmt.Sprintf(<span class="string">&quot;%s:%d&quot;</span>,</span><br><span class="line">                config.Properties.Bind,</span><br><span class="line">                config.Properties.Port),</span><br><span class="line">        &#125;,</span><br><span class="line">        EchoHandler.MakeHandler())</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        logger.Error(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="echoHandler示例"><a href="#echoHandler示例" class="headerlink" title="echoHandler示例"></a>echoHandler示例</h4><p>新建文件<code>tcp/echo.go</code>，定义结构体<code>EchoHandler</code>与<code>EchoClient</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EchoHandler echos received line to client, using for test</span></span><br><span class="line"><span class="keyword">type</span> EchoHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">    activeConn sync.Map</span><br><span class="line">    closing    atomic.Boolean</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MakeHandler creates EchoHandler</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeHandler</span><span class="params">()</span></span> *EchoHandler &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;EchoHandler&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EchoClient is client for EchoHandler, using for test</span></span><br><span class="line"><span class="keyword">type</span> EchoClient <span class="keyword">struct</span> &#123;</span><br><span class="line">    Conn    net.Conn</span><br><span class="line">    Waiting wait.Wait</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close close connection</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *EchoClient)</span></span> Close() <span class="type">error</span> &#123;</span><br><span class="line">    c.Waiting.WaitWithTimeout(<span class="number">10</span> * time.Second)</span><br><span class="line">    c.Conn.Close()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>EchoHandler</code>实现了接口<code>Handler</code>，主要是将接收到的数据原样返回，详情如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle echos received line to client</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *EchoHandler)</span></span> Handle(ctx context.Context, conn net.Conn) &#123;</span><br><span class="line">    ...</span><br><span class="line">    reader := bufio.NewReader(conn)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// may occurs: client EOF, client timeout, server early close</span></span><br><span class="line">        msg, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        ....</span><br><span class="line">        b := []<span class="type">byte</span>(msg)</span><br><span class="line">        _, _ = conn.Write(b)</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close stops echo handler</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *EchoHandler)</span></span> Close() <span class="type">error</span> &#123;</span><br><span class="line">    h.closing.Set(<span class="literal">true</span>)</span><br><span class="line">    h.activeConn.Range(<span class="function"><span class="keyword">func</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;, val <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        client := key.(*EchoClient)</span><br><span class="line">        _ = client.Close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现Redis协议解析器"><a href="#实现Redis协议解析器" class="headerlink" title="实现Redis协议解析器"></a>实现Redis协议解析器</h2><p>本章节主要新增了redis相关命令的解析，具体执行，以及响应处理等，相关目录结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">├─config</span><br><span class="line">│  config.go</span><br><span class="line">│</span><br><span class="line">├─database</span><br><span class="line">│  echo_database.go</span><br><span class="line">│</span><br><span class="line">├─interface</span><br><span class="line">│  ├─database</span><br><span class="line">│  │  database.go</span><br><span class="line">│  │</span><br><span class="line">│  ├─resp</span><br><span class="line">│  │  conn.go</span><br><span class="line">│  │  reply.go</span><br><span class="line">│  │</span><br><span class="line">│  └─tcp</span><br><span class="line">│     handler.go</span><br><span class="line">│</span><br><span class="line">├─lib</span><br><span class="line">│</span><br><span class="line">├─resp</span><br><span class="line">│  ├─connection</span><br><span class="line">│  │  conn.go</span><br><span class="line">│  │</span><br><span class="line">│  ├─handler</span><br><span class="line">│  │  handler.go</span><br><span class="line">│  │</span><br><span class="line">│  ├─parser</span><br><span class="line">│  │      parser.go</span><br><span class="line">│  │</span><br><span class="line">│  └─reply</span><br><span class="line">│     consts.go</span><br><span class="line">│     errors.go</span><br><span class="line">│     reply.go</span><br><span class="line">│</span><br><span class="line">└─tcp</span><br><span class="line">│   echo.go</span><br><span class="line">│   server.go</span><br><span class="line">│ </span><br><span class="line">| go.mod</span><br><span class="line">| main.go</span><br><span class="line">| redis.conf</span><br></pre></td></tr></table></figure><h3 id="redis网络协议认识"><a href="#redis网络协议认识" class="headerlink" title="redis网络协议认识"></a>redis网络协议认识</h3></li><li><p>正常回复：以”+”开头，以”\r\n”结尾的字符串形式</p></li><li><p>错误回复：以”-“开头，以”\r\n”结尾的字符串形式</p></li><li><p>整数：以”:”开头，以”\r\n”结尾的字符串形式</p></li><li><p>多行字符串：以”$”开头，后面跟实际发送的字节数，以”\r\n”结尾</p></li><li><p>数组：以”*”开头，后面跟成员个数</p><h3 id="接口定义及实现"><a href="#接口定义及实现" class="headerlink" title="接口定义及实现"></a>接口定义及实现</h3><h4 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h4><p>在<code>interface/resp/conn.go</code>中定义连接，主要包含三个方法，写数据、获取当前所在数据库的索引，以及选择数据库：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Connection represents a connection with redis client</span></span><br><span class="line"><span class="keyword">type</span> Connection <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write([]<span class="type">byte</span>) <span class="type">error</span></span><br><span class="line">    GetDBIndex() <span class="type">int</span> <span class="comment">// used for multi database</span></span><br><span class="line">    SelectDB(<span class="type">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>resp/connection/conn.go</code>中创建Connection结构体并实现Connection接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Connection represents a connection with a redis-cli</span></span><br><span class="line"><span class="keyword">type</span> Connection <span class="keyword">struct</span> &#123;</span><br><span class="line">    conn         net.Conn</span><br><span class="line">    waitingReply wait.Wait  <span class="comment">// waiting until reply finished</span></span><br><span class="line">    mu           sync.Mutex <span class="comment">// lock while handler sending response</span></span><br><span class="line">    selectedDB   <span class="type">int</span>        <span class="comment">// selected db</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewConn</span><span class="params">(conn net.Conn)</span></span> *Connection &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Connection&#123;conn: conn,&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RemoteAddr returns the remote network address</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Connection)</span></span> RemoteAddr() net.Addr &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close disconnect with the client</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Connection)</span></span> Close() <span class="type">error</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write sends response to client over tcp connection</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Connection)</span></span> Write(b []<span class="type">byte</span>) <span class="type">error</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetDBIndex returns selected db</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Connection)</span></span> GetDBIndex() <span class="type">int</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SelectDB selects a database</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Connection)</span></span> SelectDB(dbNum <span class="type">int</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="Reply"><a href="#Reply" class="headerlink" title="Reply"></a>Reply</h4><p>在<code>interface/resp/reply.go</code>中定义接口Reply，用于处理基于resp协议的响应，主要包含<code>ToBytes</code>方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reply is the interface of redis serialization protocol message</span></span><br><span class="line"><span class="keyword">type</span> Reply <span class="keyword">interface</span> &#123;</span><br><span class="line">    ToBytes() []<span class="type">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ErrorReply is an error and redis.Reply</span></span><br><span class="line"><span class="keyword">type</span> ErrorReply <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="type">string</span></span><br><span class="line">    ToBytes() []<span class="type">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>resp/reply</code>下创建以下三个文件，分别用于实现具体的相关处理：</p></li><li><p><code>consts.go</code>：定义一些固定不变的响应</p></li><li><p><code>reply.go</code>：定义正常执行命令时的响应</p></li><li><p><code>errors.go</code>：定义发生错误时的响应</p></li></ul><p><code>consts.go</code>中的文件内容如下，其中的结构体都需要实现Reply接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PongReply is +PONG</span></span><br><span class="line"><span class="keyword">type</span> PongReply <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OkReply is +OK</span></span><br><span class="line"><span class="keyword">type</span> OkReply <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NullBulkReply is empty string</span></span><br><span class="line"><span class="keyword">type</span> NullBulkReply <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EmptyMultiBulkReply is a empty list</span></span><br><span class="line"><span class="keyword">type</span> EmptyMultiBulkReply <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NoReply respond nothing, for commands like subscribe</span></span><br><span class="line"><span class="keyword">type</span> NoReply <span class="keyword">struct</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><code>reply.go</code>中的文件内容如下，其中的结构体都需要实现Reply接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BulkReply stores a binary-safe string</span></span><br><span class="line"><span class="keyword">type</span> BulkReply <span class="keyword">struct</span> &#123;</span><br><span class="line">    Arg []<span class="type">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MultiBulkReply stores a list of string</span></span><br><span class="line"><span class="keyword">type</span> MultiBulkReply <span class="keyword">struct</span> &#123;</span><br><span class="line">    Args [][]<span class="type">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// StatusReply stores a simple status string</span></span><br><span class="line"><span class="keyword">type</span> StatusReply <span class="keyword">struct</span> &#123;</span><br><span class="line">    Status <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IntReply stores an int64 number</span></span><br><span class="line"><span class="keyword">type</span> IntReply <span class="keyword">struct</span> &#123;</span><br><span class="line">    Code <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// StandardErrReply represents handler error</span></span><br><span class="line"><span class="keyword">type</span> StandardErrReply <span class="keyword">struct</span> &#123;</span><br><span class="line">    Status <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>errors.go</code>中的文件内容如下，其中的结构体都需要实现Reply接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UnknownErrReply represents UnknownErr</span></span><br><span class="line"><span class="keyword">type</span> UnknownErrReply <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ArgNumErrReply represents wrong number of arguments for command</span></span><br><span class="line"><span class="keyword">type</span> ArgNumErrReply <span class="keyword">struct</span> &#123;</span><br><span class="line">    Cmd <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SyntaxErrReply represents meeting unexpected arguments</span></span><br><span class="line"><span class="keyword">type</span> SyntaxErrReply <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WrongTypeErrReply represents operation against a key holding the wrong kind of value</span></span><br><span class="line"><span class="keyword">type</span> WrongTypeErrReply <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ProtocolErrReply represents meeting unexpected byte during parse requests</span></span><br><span class="line"><span class="keyword">type</span> ProtocolErrReply <span class="keyword">struct</span> &#123;</span><br><span class="line">    Msg <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Database"><a href="#Database" class="headerlink" title="Database"></a>Database</h4><p>在<code>interface/database/database.go</code>定义接口Database，规范不同的数据库实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Database is the interface for redis style storage engine</span></span><br><span class="line"><span class="keyword">type</span> Database <span class="keyword">interface</span> &#123;</span><br><span class="line">    Exec(client resp.Connection, args [][]<span class="type">byte</span>) resp.Reply</span><br><span class="line">    AfterClientClose(c resp.Connection)</span><br><span class="line">    Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="命令解析实现"><a href="#命令解析实现" class="headerlink" title="命令解析实现"></a>命令解析实现</h3><p>在文件<code>resp/parser/parser.go</code>实现下面的功能：</p><h4 id="响应流式处理"><a href="#响应流式处理" class="headerlink" title="响应流式处理"></a>响应流式处理</h4><ul><li><p><code>Payload</code>：包含正常响应或错误</p></li><li><p><code>readState</code>：解析器状态</p></li><li><p><code>ParseStream</code>：返回数据类型为<code>Payload</code>的channel</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Payload stores redis.Reply or error</span></span><br><span class="line"><span class="keyword">type</span> Payload <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data resp.Reply</span><br><span class="line">    Err  <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> readState <span class="keyword">struct</span> &#123;</span><br><span class="line">    readingMultiLine  <span class="type">bool</span></span><br><span class="line">    expectedArgsCount <span class="type">int</span></span><br><span class="line">    msgType           <span class="type">byte</span></span><br><span class="line">    args              [][]<span class="type">byte</span></span><br><span class="line">    bulkLen           <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *readState)</span></span> finished() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.expectedArgsCount &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(s.args) == s.expectedArgsCount</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ParseStream reads data from io.Reader and send payloads through channel</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseStream</span><span class="params">(reader io.Reader)</span></span> &lt;-<span class="keyword">chan</span> *Payload &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> *Payload)</span><br><span class="line">    <span class="keyword">go</span> parse0(reader, ch)</span><br><span class="line">    <span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="命令读取及具体解析"><a href="#命令读取及具体解析" class="headerlink" title="命令读取及具体解析"></a>命令读取及具体解析</h4></li><li><p><code>readLine</code>：精确读取一行数据</p></li><li><p><code>parseMultiBulkHeader</code>：处理多行数据(“*”号开始)，改变解析器状态</p></li><li><p><code>parseBulkHeader</code>：处理单个数据(“$”号开始)，改变解析器状态</p></li><li><p><code>parseSingleLineReply</code>：处理客户端发送+ok -err  :5的情况</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readLine</span><span class="params">(bufReader *bufio.Reader, state *readState)</span></span> ([]<span class="type">byte</span>, <span class="type">bool</span>, <span class="type">error</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseMultiBulkHeader</span><span class="params">(msg []<span class="type">byte</span>, state *readState)</span></span> <span class="type">error</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseBulkHeader</span><span class="params">(msg []<span class="type">byte</span>, state *readState)</span></span> <span class="type">error</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseSingleLineReply</span><span class="params">(msg []<span class="type">byte</span>)</span></span> (resp.Reply, <span class="type">error</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="解析实现"><a href="#解析实现" class="headerlink" title="解析实现"></a>解析实现</h4></li><li><p><code>readBody</code>：去除其他字符，解析命令内容</p></li><li><p><code>parse0</code>：根据读取到的数据调用不同的解析方法，并将结果返回Payload的channel</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// read the non-first lines of multi bulk reply or bulk reply</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readBody</span><span class="params">(msg []<span class="type">byte</span>, state *readState)</span></span> <span class="type">error</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parse0</span><span class="params">(reader io.Reader, ch <span class="keyword">chan</span>&lt;- *Payload)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="实现RespHandler"><a href="#实现RespHandler" class="headerlink" title="实现RespHandler"></a>实现RespHandler</h3><p>在TCP层面处理用户发过来的数据，并调用resp协议解析器进行解析，然后根据对应的db去实际执行相关的命令，主要在Handle方法中实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RespHandler implements tcp.Handler and serves as a redis handler</span></span><br><span class="line"><span class="keyword">type</span> RespHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">    activeConn sync.Map <span class="comment">// *client -&gt; placeholder</span></span><br><span class="line">    db         databaseface.Database</span><br><span class="line">    closing    atomic.Boolean <span class="comment">// refusing new client and new request</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MakeHandler creates a RespHandler instance</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeHandler</span><span class="params">()</span></span> *RespHandler &#123;</span><br><span class="line">    <span class="keyword">var</span> db databaseface.Database</span><br><span class="line">    db = database.NewEchoDatabase()</span><br><span class="line">    <span class="keyword">return</span> &amp;RespHandler&#123;</span><br><span class="line">        db: db,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *RespHandler)</span></span> closeClient(client *connection.Connection) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle receives and executes redis commands</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *RespHandler)</span></span> Handle(ctx context.Context, conn net.Conn) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close stops handler</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *RespHandler)</span></span> Close() <span class="type">error</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="EchoDatabase示例"><a href="#EchoDatabase示例" class="headerlink" title="EchoDatabase示例"></a>EchoDatabase示例</h3><p>在<code>database/echo_database.go</code>中简单实现一个数据库，其实现了Database接口。这里只是方便做简单测试，下一篇文章将记录如何实现redis的内存数据库：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> EchoDatabase <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewEchoDatabase</span><span class="params">()</span></span> *EchoDatabase &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;EchoDatabase&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e EchoDatabase)</span></span> Exec(client resp.Connection, args [][]<span class="type">byte</span>) resp.Reply &#123;</span><br><span class="line">    <span class="keyword">return</span> reply.MakeMultiBulkReply(args)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e EchoDatabase)</span></span> AfterClientClose(c resp.Connection) &#123;</span><br><span class="line">    logger.Info(<span class="string">&quot;EchoDatabase AfterClientClose&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e EchoDatabase)</span></span> Close() &#123;</span><br><span class="line">    logger.Info(<span class="string">&quot;EchoDatabase Close&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;本系列文章记录如何基于go语言实现Redis，从整体设计到具体细节实现，不仅可以有效的锻炼自己的编码能力，又能加深对redis的认识。文章主</summary>
      
    
    
    
    <category term="go" scheme="https://zcej.github.io/categories/go/"/>
    
    <category term="项目实战" scheme="https://zcej.github.io/categories/go/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    
    
  </entry>
  
  <entry>
    <title>go语言实现大根堆、小根堆及堆排序</title>
    <link href="https://zcej.github.io/2022/03/18/go/go%E5%AE%9E%E7%8E%B0%E5%A4%A7%E6%A0%B9%E5%A0%86%E3%80%81%E5%B0%8F%E6%A0%B9%E5%A0%86%E5%8F%8A%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>https://zcej.github.io/2022/03/18/go/go%E5%AE%9E%E7%8E%B0%E5%A4%A7%E6%A0%B9%E5%A0%86%E3%80%81%E5%B0%8F%E6%A0%B9%E5%A0%86%E5%8F%8A%E5%A0%86%E6%8E%92%E5%BA%8F/</id>
    <published>2022-03-18T13:07:38.000Z</published>
    <updated>2022-06-28T16:24:38.505Z</updated>
    
    <content type="html"><![CDATA[<p>二叉堆是一种特殊的堆，它满足两个性质：结构性和堆序性</p><ul><li>结构性：二叉堆是一棵完全二叉树，完全二叉树可以用一个数组表示，不需要指针，所以效率更高。当用数组表示时，数组中任一位置i上的元素，其左子树在位置2i上，右子树在位置2i+1上，其父节点在位置i&#x2F;2上。</li><li>堆序性质：堆的最小值或最大值在根节点上，所以可以快速找到最大值或最小值。</li></ul><p>最大堆和最小堆是二叉堆的两种形式：</p><ul><li>最大堆：根节点的键值是所有堆节点键值中最大者的堆。</li><li>最小堆：根节点的键值是所有堆节点键值中最小者的堆。</li></ul><h2 id="最小堆实现"><a href="#最小堆实现" class="headerlink" title="最小堆实现"></a>最小堆实现</h2><h3 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h3><p>当向最小堆插入元素时：</p><blockquote><ul><li>将元素插入末尾</li><li>判断该元素是否需要上移(与父节点比较，如果比父节点小则上移)</li><li>重复上述步骤，直到满足最小堆特性</li></ul></blockquote><p>当向最小堆删除元素时：</p><blockquote><ul><li>删除堆顶元素</li><li>判断目前的堆顶元素是否需要下调(与子节点比较，和其中较小的节点交换位置)</li><li>重复上述步骤，直到满足最小堆特性</li></ul></blockquote><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>下面以求数据流中第k大的元素为问题实现一个最小堆，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> minHeap <span class="keyword">struct</span> &#123;</span><br><span class="line">    k    <span class="type">int</span>   <span class="comment">// 容量</span></span><br><span class="line">    heap []<span class="type">int</span> <span class="comment">// heap数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createMinHeap</span><span class="params">(k <span class="type">int</span>, nums []<span class="type">int</span>)</span></span> *minHeap &#123;</span><br><span class="line">    heap := &amp;minHeap&#123;k: k, heap: []<span class="type">int</span>&#123;&#125;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, n := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        heap.add(n)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> heap</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *minHeap)</span></span> add(num <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(m.heap) &lt; m.k &#123;</span><br><span class="line">        m.heap = <span class="built_in">append</span>(m.heap, num)</span><br><span class="line">        m.up(<span class="built_in">len</span>(m.heap) - <span class="number">1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> num &gt; m.heap[<span class="number">0</span>] &#123;</span><br><span class="line">        m.heap[<span class="number">0</span>] = num</span><br><span class="line">        m.down(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素上浮</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *minHeap)</span></span> up(i <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">        parent := (i - <span class="number">1</span>) &gt;&gt; <span class="number">1</span> <span class="comment">// 找到父节点在heap数组中的位置</span></span><br><span class="line">        <span class="comment">// 如果比父节点元素小，则交换位置并更新索引</span></span><br><span class="line">        <span class="keyword">if</span> m.heap[parent] &gt; m.heap[i] &#123;</span><br><span class="line">            m.heap[parent], m.heap[i] = m.heap[i], m.heap[parent]</span><br><span class="line">            i = parent</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> <span class="comment">// 当前节点比父节点小，满足最小堆性质，退出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素下沉(包括切片中第一个元素，索引为0)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *minHeap)</span></span> down(i <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="number">2</span>*i+<span class="number">1</span> &lt; <span class="built_in">len</span>(m.heap) &#123; <span class="comment">// 左子节点越界，则退出循环</span></span><br><span class="line">        child := <span class="number">2</span>*i + <span class="number">1</span> <span class="comment">// 左子节点在heap切片中的位置</span></span><br><span class="line">        <span class="keyword">if</span> child+<span class="number">1</span> &lt; <span class="built_in">len</span>(m.heap) &amp;&amp; m.heap[child+<span class="number">1</span>] &lt; m.heap[child] &#123;</span><br><span class="line">            child++ <span class="comment">// 如果右子节点没有越界，且值比左子节点更小，则选择下沉右子节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将当前元素与子节点最大元素对比，然后交换并更新索引</span></span><br><span class="line">        <span class="keyword">if</span> m.heap[i] &gt; m.heap[child] &#123;</span><br><span class="line">            m.heap[child], m.heap[i] = m.heap[i], m.heap[child]</span><br><span class="line">            i = child</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> <span class="comment">// 子节点都比自己大，满足最小堆属性，退出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>如果要求输出数据流中的第k大元素，正好可以使用最小堆实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> KthLargest <span class="keyword">struct</span> &#123;</span><br><span class="line">    heap *minHeap</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(k <span class="type">int</span>, nums []<span class="type">int</span>)</span></span> KthLargest &#123;</span><br><span class="line">    <span class="keyword">return</span> KthLargest&#123;heap: createMinHeap(k, nums)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(k *KthLargest)</span></span> Add(val <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    k.heap.add(val)</span><br><span class="line">    <span class="keyword">return</span> k.heap.heap[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用heap包实现"><a href="#使用heap包实现" class="headerlink" title="使用heap包实现"></a>使用heap包实现</h2><p>heap源码中定义了一个Interface接口，该接口一共包含5个方法，定义一个实现了该接口的结构体就实现了一个二叉堆。<br><code>container/heap/heap.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Note that Push and Pop in this interface are for package heap&#x27;s</span></span><br><span class="line"><span class="comment">// implementation to call. To add and remove things from the heap,</span></span><br><span class="line"><span class="comment">// use heap.Push and heap.Pop.</span></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    sort.Interface</span><br><span class="line">    Push(x <span class="keyword">interface</span>&#123;&#125;) <span class="comment">// add x as element Len()</span></span><br><span class="line">    Pop() <span class="keyword">interface</span>&#123;&#125;   <span class="comment">// remove and return element Len() - 1.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sort/sort.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An implementation of Interface can be sorted by the routines in this package.</span></span><br><span class="line"><span class="comment">// The methods refer to elements of the underlying collection by integer index.</span></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Len is the number of elements in the collection.</span></span><br><span class="line">    Len() <span class="type">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Less reports whether the element with index i</span></span><br><span class="line">    <span class="comment">// must sort before the element with index j.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// If both Less(i, j) and Less(j, i) are false,</span></span><br><span class="line">    <span class="comment">// then the elements at index i and j are considered equal.</span></span><br><span class="line">    <span class="comment">// Sort may place equal elements in any order in the final result,</span></span><br><span class="line">    <span class="comment">// while Stable preserves the original input order of equal elements.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Less must describe a transitive ordering:</span></span><br><span class="line">    <span class="comment">//  - if both Less(i, j) and Less(j, k) are true, then Less(i, k) must be true as well.</span></span><br><span class="line">    <span class="comment">//  - if both Less(i, j) and Less(j, k) are false, then Less(i, k) must be false as well.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Note that floating-point comparison (the &lt; operator on float32 or float64 values)</span></span><br><span class="line">    <span class="comment">// is not a transitive ordering when not-a-number (NaN) values are involved.</span></span><br><span class="line">    <span class="comment">// See Float64Slice.Less for a correct implementation for floating-point values.</span></span><br><span class="line">    Less(i, j <span class="type">int</span>) <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Swap swaps the elements with indexes i and j.</span></span><br><span class="line">    Swap(i, j <span class="type">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个最大堆，实现上述接口如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MaxHeap []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MaxHeap)</span></span> Len() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(h)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MaxHeap)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> h[i] &gt; h[j] <span class="comment">// 因为实现最大堆，所以使用大于号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *MaxHeap)</span></span> Swap(i, j <span class="type">int</span>) &#123;</span><br><span class="line">    (*h)[i], (*h)[j] = (*h)[j], (*h)[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *MaxHeap)</span></span> Push(x <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    *h = <span class="built_in">append</span>(*h, x.(<span class="type">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pop 弹出堆顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *MaxHeap)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">    res := (*h)[<span class="built_in">len</span>(*h)<span class="number">-1</span>]</span><br><span class="line">    *h = (*h)[:<span class="built_in">len</span>(*h)<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    h := &amp;MaxHeap&#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>&#125;</span><br><span class="line">    heap.Init(h)</span><br><span class="line">    heap.Push(h, <span class="number">8</span>)</span><br><span class="line">    <span class="keyword">for</span> h.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d &quot;</span>, heap.Pop(h))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序是一种选择排序，它的最坏、最好、平均时间复杂度均为O(nlogn)，它也是不稳定排序。</p><blockquote><ul><li>排序的过程主要由构建初始堆，交换堆顶元素和末尾元素并重建堆两部分组成</li><li>升序使用最大堆，每次和末尾元素交换，然后重新构建最大堆，整体数组减一；反之降序使用最小堆</li><li>堆构建从第一个非叶子节点开始，也就是<code>len/2 - 1</code>所在位置的元素</li></ul></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxHeap</span><span class="params">(nums []<span class="type">int</span>, length <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> length &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    &#125;</span><br><span class="line">    parent := length/<span class="number">2</span> + <span class="number">1</span> <span class="comment">// 第一个非叶子节点</span></span><br><span class="line">    <span class="keyword">for</span> i := parent; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="comment">// 比较三个节点的大小并将较大的节点上浮</span></span><br><span class="line">        max := i</span><br><span class="line">        leftChild := <span class="number">2</span>*i + <span class="number">1</span></span><br><span class="line">        rightChild := <span class="number">2</span>*i + <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> leftChild &lt;= length<span class="number">-1</span> &amp;&amp; nums[leftChild] &gt; nums[max] &#123;</span><br><span class="line">            max = leftChild</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> rightChild &lt;= length<span class="number">-1</span> &amp;&amp; nums[rightChild] &gt; nums[max] &#123;</span><br><span class="line">            max = rightChild</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> max != i &#123;</span><br><span class="line">            nums[i], nums[max] = nums[max], nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortHeap</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    length := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i++ &#123;</span><br><span class="line">        lastLength := length - i <span class="comment">// 剔除已经排完序的元素</span></span><br><span class="line">        nums = maxHeap(nums, lastLength)  <span class="comment">// 重新构建最大堆</span></span><br><span class="line">        nums[<span class="number">0</span>], nums[lastLength<span class="number">-1</span>] = nums[lastLength<span class="number">-1</span>], nums[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    nums := []<span class="type">int</span>&#123;<span class="number">8</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">9</span>&#125;</span><br><span class="line">    fmt.Println(sortHeap(nums))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;二叉堆是一种特殊的堆，它满足两个性质：结构性和堆序性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;结构性：二叉堆是一棵完全二叉树，完全二叉树可以用一个数组表示，不需要指针，所以效率更高。当用数组表示时，数组中任一位置i上的元素，其左子树在位置2i上，右子树在位置2i+1上，其父节点在位置i&amp;</summary>
      
    
    
    
    <category term="go" scheme="https://zcej.github.io/categories/go/"/>
    
    
  </entry>
  
  <entry>
    <title>channel的底层实现</title>
    <link href="https://zcej.github.io/2022/03/05/go/channel%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"/>
    <id>https://zcej.github.io/2022/03/05/go/channel%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-03-05T11:43:21.000Z</published>
    <updated>2022-05-23T09:46:25.833Z</updated>
    
    <content type="html"><![CDATA[<p>本文基于go版本1.16</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>其底层数据结构为runtime包下的一个hchan的结构体，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">qcount   <span class="type">uint</span>           <span class="comment">// total data in the queue</span></span><br><span class="line">dataqsiz <span class="type">uint</span>           <span class="comment">// size of the circular queue</span></span><br><span class="line">buf      unsafe.Pointer <span class="comment">// points to an array of dataqsiz elements</span></span><br><span class="line">elemsize <span class="type">uint16</span></span><br><span class="line">closed   <span class="type">uint32</span></span><br><span class="line">elemtype *_type <span class="comment">// element type</span></span><br><span class="line">sendx    <span class="type">uint</span>   <span class="comment">// send index</span></span><br><span class="line">recvx    <span class="type">uint</span>   <span class="comment">// receive index</span></span><br><span class="line">recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line">sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line"><span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Do not change another G&#x27;s status while holding this lock</span></span><br><span class="line"><span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line"><span class="comment">// with stack shrinking.</span></span><br><span class="line">lock mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">first *sudog</span><br><span class="line">last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li><code>buf</code>指向底层循环数组，只有缓冲型的channel才有</li><li><code>sendx, recvx</code>均指向底层循环数组，表示当前可以发送和接收的元素位置索引值（相对于底层数组）</li><li><code>sendq, recvq</code>分别表示向channel读取或发送数据而阻塞的goroutine队列</li><li><code>waitq</code>是sudog的一个双向链表（sudog实际上是对goroutine的封装）</li><li><code>lock</code>用来保证每个读channel或写channel的操作都是原子的</li></ul></blockquote><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>使用<code>make</code>能创建一个能收能发的channel：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无缓冲通道</span></span><br><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有缓冲通道</span></span><br><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>通过汇编分析（go complie），找到最终创建chan的函数是位于runtime&#x2F;chan.go下的函数<code>makechan</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">maxAlign  = <span class="number">8</span></span><br><span class="line">hchanSize = unsafe.Sizeof(hchan&#123;&#125;) + <span class="type">uintptr</span>(-<span class="type">int</span>(unsafe.Sizeof(hchan&#123;&#125;))&amp;(maxAlign<span class="number">-1</span>))</span><br><span class="line">debugChan = <span class="literal">false</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="type">int</span>)</span></span> *hchan &#123;</span><br><span class="line">elem := t.elem</span><br><span class="line"></span><br><span class="line"><span class="comment">// compiler checks this but be safe.</span></span><br><span class="line"><span class="keyword">if</span> elem.size &gt;= <span class="number">1</span>&lt;&lt;<span class="number">16</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;makechan: invalid channel element type&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> hchanSize%maxAlign != <span class="number">0</span> || elem.align &gt; maxAlign &#123;</span><br><span class="line">throw(<span class="string">&quot;makechan: bad alignment&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mem, overflow := math.MulUintptr(elem.size, <span class="type">uintptr</span>(size))</span><br><span class="line"><span class="keyword">if</span> overflow || mem &gt; maxAlloc-hchanSize || size &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;makechan: size out of range&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers.</span></span><br><span class="line"><span class="comment">// buf points into the same allocation, elemtype is persistent.</span></span><br><span class="line"><span class="comment">// SudoG&#x27;s are referenced from their owning thread so they can&#x27;t be collected.</span></span><br><span class="line"><span class="comment">// TODO(dvyukov,rlh): Rethink when collector can move allocated objects.</span></span><br><span class="line"><span class="keyword">var</span> c *hchan</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> mem == <span class="number">0</span>:</span><br><span class="line"><span class="comment">// Queue or element size is zero.</span></span><br><span class="line">c = (*hchan)(mallocgc(hchanSize, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line"><span class="comment">// Race detector uses this location for synchronization.</span></span><br><span class="line">c.buf = c.raceaddr()</span><br><span class="line"><span class="keyword">case</span> elem.ptrdata == <span class="number">0</span>:</span><br><span class="line"><span class="comment">// Elements do not contain pointers.</span></span><br><span class="line"><span class="comment">// Allocate hchan and buf in one call.</span></span><br><span class="line">c = (*hchan)(mallocgc(hchanSize+mem, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// Elements contain pointers.</span></span><br><span class="line">c = <span class="built_in">new</span>(hchan)</span><br><span class="line">c.buf = mallocgc(mem, elem, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.elemsize = <span class="type">uint16</span>(elem.size)</span><br><span class="line">c.elemtype = elem</span><br><span class="line">c.dataqsiz = <span class="type">uint</span>(size)</span><br><span class="line">lockInit(&amp;c.lock, lockRankHchan)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debugChan &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;makechan: chan=&quot;</span>, c, <span class="string">&quot;; elemsize=&quot;</span>, elem.size, <span class="string">&quot;; dataqsiz=&quot;</span>, size, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>, callerpc <span class="type">uintptr</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;  <span class="comment">// 当channel是nil</span></span><br><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>  <span class="comment">// 非阻塞直接返回false，表示发送失败</span></span><br><span class="line">&#125;</span><br><span class="line">gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanSendNilChan, traceEvGoStop, <span class="number">2</span>)  <span class="comment">// 挂起当前goroutine</span></span><br><span class="line">throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debugChan &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;chansend: chan=&quot;</span>, c, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">racereadpc(c.raceaddr(), callerpc, funcPC(chansend))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fast path: check for failed non-blocking operation without acquiring the lock.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// After observing that the channel is not closed, we observe that the channel is</span></span><br><span class="line"><span class="comment">// not ready for sending. Each of these observations is a single word-sized read</span></span><br><span class="line"><span class="comment">// (first c.closed and second full()).</span></span><br><span class="line"><span class="comment">// Because a closed channel cannot transition from &#x27;ready for sending&#x27; to</span></span><br><span class="line"><span class="comment">// &#x27;not ready for sending&#x27;, even if the channel is closed between the two observations,</span></span><br><span class="line"><span class="comment">// they imply a moment between the two when the channel was both not yet closed</span></span><br><span class="line"><span class="comment">// and not ready for sending. We behave as if we observed the channel at that moment,</span></span><br><span class="line"><span class="comment">// and report that the send cannot proceed.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// It is okay if the reads are reordered here: if we observe that the channel is not</span></span><br><span class="line"><span class="comment">// ready for sending and then observe that it is not closed, that implies that the</span></span><br><span class="line"><span class="comment">// channel wasn&#x27;t closed during the first observation. However, nothing here</span></span><br><span class="line"><span class="comment">// guarantees forward progress. We rely on the side effects of lock release in</span></span><br><span class="line"><span class="comment">// chanrecv() and closechan() to update this thread&#x27;s view of c.closed and full().</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 快速检测非阻塞且channel未关闭情况下的失败场景（详情看下述full函数）：</span></span><br><span class="line">    <span class="comment">// 1. 对于无缓冲channel，接收队列里没有goroutine则发送失败(非阻塞)</span></span><br><span class="line">    <span class="comment">// 2. 对于有缓冲channel，循环数组中已装满元素则发送失败(非阻塞)</span></span><br><span class="line"><span class="keyword">if</span> !block &amp;&amp; c.closed == <span class="number">0</span> &amp;&amp; full(c) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t0 <span class="type">int64</span></span><br><span class="line"><span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">t0 = cputicks()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lock(&amp;c.lock)  <span class="comment">// 锁住channel，并发安全</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;  <span class="comment">// 如果channel关闭了，则解锁并抛出异常</span></span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果接收队列里有goroutine，则直接将要发送的数据拷贝到接收goroutine</span></span><br><span class="line"><span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Found a waiting receiver. We pass the value we want to send</span></span><br><span class="line"><span class="comment">// directly to the receiver, bypassing the channel buffer (if any).</span></span><br><span class="line">send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于有缓冲的channel，如果还有缓冲空间</span></span><br><span class="line"><span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line"><span class="comment">// Space is available in the channel buffer. Enqueue the element to send.</span></span><br><span class="line">qp := chanbuf(c, c.sendx)  <span class="comment">// qp指向buf的sendx位置</span></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">racenotify(c, c.sendx, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line">typedmemmove(c.elemtype, qp, ep)  <span class="comment">// 将数据从ep处拷贝到qp</span></span><br><span class="line">c.sendx++  <span class="comment">// 发送游标值加一</span></span><br><span class="line"><span class="keyword">if</span> c.sendx == c.dataqsiz &#123;  <span class="comment">// 如果发送游标值等于容量值，游标值归0</span></span><br><span class="line">c.sendx = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">c.qcount++  <span class="comment">// 缓冲区的元素数量加一</span></span><br><span class="line">unlock(&amp;c.lock)  <span class="comment">// 解锁</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !block &#123;  <span class="comment">// 如果是非阻塞的，直接返回错误</span></span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// channel满了，发送方会被阻塞。接下来会构造一个sudog</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// Block on the channel. Some receiver will complete our operation for us.</span></span><br><span class="line">    gp := getg()  <span class="comment">// 获取当前goroutine的指针</span></span><br><span class="line">mysg := acquireSudog()</span><br><span class="line">mysg.releasetime = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">mysg.releasetime = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line"><span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">mysg.elem = ep</span><br><span class="line">mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">mysg.g = gp</span><br><span class="line">mysg.isSelect = <span class="literal">false</span></span><br><span class="line">mysg.c = c</span><br><span class="line">gp.waiting = mysg</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">c.sendq.enqueue(mysg)  <span class="comment">// 当前goroutine进入发送等待队列</span></span><br><span class="line"><span class="comment">// Signal to anyone trying to shrink our stack that we&#x27;re about</span></span><br><span class="line"><span class="comment">// to park on a channel. The window between when this G&#x27;s status</span></span><br><span class="line"><span class="comment">// changes and when we set gp.activeStackChans is not safe for</span></span><br><span class="line"><span class="comment">// stack shrinking.</span></span><br><span class="line">atomic.Store8(&amp;gp.parkingOnChan, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 挂起当前goroutine</span></span><br><span class="line">gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanSend, traceEvGoBlockSend, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// Ensure the value being sent is kept alive until the</span></span><br><span class="line"><span class="comment">// receiver copies it out. The sudog has a pointer to the</span></span><br><span class="line"><span class="comment">// stack object, but sudogs aren&#x27;t considered as roots of the</span></span><br><span class="line"><span class="comment">// stack tracer.</span></span><br><span class="line">KeepAlive(ep)</span><br><span class="line"></span><br><span class="line"><span class="comment">// someone woke us up.</span></span><br><span class="line"><span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">throw(<span class="string">&quot;G waiting list is corrupted&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">gp.waiting = <span class="literal">nil</span></span><br><span class="line">gp.activeStackChans = <span class="literal">false</span></span><br><span class="line">closed := !mysg.success</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">mysg.c = <span class="literal">nil</span></span><br><span class="line">releaseSudog(mysg)</span><br><span class="line"><span class="keyword">if</span> closed &#123;</span><br><span class="line"><span class="keyword">if</span> c.closed == <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;chansend: spurious wakeup&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">full</span><span class="params">(c *hchan)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="comment">// c.dataqsiz is immutable (never written after the channel is created)</span></span><br><span class="line"><span class="comment">// so it is safe to read at any time during channel operation.</span></span><br><span class="line"><span class="keyword">if</span> c.dataqsiz == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// Assumes that a pointer read is relaxed-atomic.</span></span><br><span class="line"><span class="keyword">return</span> c.recvq.first == <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Assumes that a uint read is relaxed-atomic.</span></span><br><span class="line"><span class="keyword">return</span> c.qcount == c.dataqsiz</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if !block &amp;&amp; c.closed == 0 &amp;&amp; full(c) &#123;</span></span><br><span class="line"><span class="comment">//        return false</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>这里有一个点需要注意，结合在<code>chansend</code>中调用<code>full</code>的地方上的英文注释进行分析，在得知channel未被关闭的情况下(<code>c.closed==0</code>)，去获取<code>c.recvq.first</code>和<code>c.qcount</code>的值时为什么不需要加锁(假设这个期间channe被关闭，则前后条件实际上是不一致的)？</p><ul><li>因为一个已经关闭的channel不能将channel状态从<code>ready for sending</code>变成<code>not ready for sending</code>，意味着在两个观测之间有一个时刻，通道既没有被关闭，也没有准备好发送，此时直接返回false也是没有问题的</li><li>然后其会依赖<code>chanrecv()</code>和<code>closechan()</code>中锁释放的副作用来更新这个线程的<code>c.closed</code>和<code>full</code></li></ul></blockquote><p>如果从等待接收队列recvq里出队一个sudog(代表一个goroutine)，说明此时channel是空的，没有元素，所以才会有等待接收者。这时会调用send函数将元素直接从发送者的栈拷贝到接收者的栈，关键操作由<code>sendDirect</code>函数完成。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// send processes a send operation on an empty channel c.</span></span><br><span class="line"><span class="comment">// The value ep sent by the sender is copied to the receiver sg.</span></span><br><span class="line"><span class="comment">// The receiver is then woken up to go on its merry way.</span></span><br><span class="line"><span class="comment">// Channel c must be empty and locked.  send unlocks c with unlockf.</span></span><br><span class="line"><span class="comment">// sg must already be dequeued from c.</span></span><br><span class="line"><span class="comment">// ep must be non-nil and point to the heap or the caller&#x27;s stack.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span></span>, skip <span class="type">int</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line"><span class="keyword">if</span> c.dataqsiz == <span class="number">0</span> &#123;</span><br><span class="line">racesync(c, sg)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Pretend we go through the buffer, even though</span></span><br><span class="line"><span class="comment">// we copy directly. Note that we need to increment</span></span><br><span class="line"><span class="comment">// the head/tail locations only when raceenabled.</span></span><br><span class="line">racenotify(c, c.recvx, <span class="literal">nil</span>)</span><br><span class="line">racenotify(c, c.recvx, sg)</span><br><span class="line">c.recvx++</span><br><span class="line"><span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">c.recvx = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">c.sendx = c.recvx <span class="comment">// c.sendx = (c.sendx+1) % c.dataqsiz</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// sg.elem指向接收到的值存放的位置，如val &lt;-ch，指的就是&amp;val</span></span><br><span class="line"><span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">sendDirect(c.elemtype, sg, ep)  <span class="comment">// 直接拷贝内存（从发送者到接收者）</span></span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">gp := sg.g  <span class="comment">// sudo上绑定的goroutine</span></span><br><span class="line">unlockf()</span><br><span class="line">gp.param = unsafe.Pointer(sg)</span><br><span class="line">sg.success = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">goready(gp, skip+<span class="number">1</span>)  <span class="comment">// 唤醒接收的goroutine</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看<code>sendDirect</code>函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sends and receives on unbuffered or empty-buffered channels are the</span></span><br><span class="line"><span class="comment">// only operations where one running goroutine writes to the stack of</span></span><br><span class="line"><span class="comment">// another running goroutine. The GC assumes that stack writes only</span></span><br><span class="line"><span class="comment">// happen when the goroutine is running and are only done by that</span></span><br><span class="line"><span class="comment">// goroutine. Using a write barrier is sufficient to make up for</span></span><br><span class="line"><span class="comment">// violating that assumption, but the write barrier has to work.</span></span><br><span class="line"><span class="comment">// typedmemmove will call bulkBarrierPreWrite, but the target bytes</span></span><br><span class="line"><span class="comment">// are not in the heap, so that will not help. We arrange to call</span></span><br><span class="line"><span class="comment">// memmove and typeBitsBulkBarrier instead.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendDirect</span><span class="params">(t *_type, sg *sudog, src unsafe.Pointer)</span></span> &#123;</span><br><span class="line"><span class="comment">// src is on our stack, dst is a slot on another stack.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Once we read sg.elem out of sg, it will no longer</span></span><br><span class="line"><span class="comment">// be updated if the destination&#x27;s stack gets copied (shrunk).</span></span><br><span class="line"><span class="comment">// So make sure that no preemption points can happen between read &amp; use.</span></span><br><span class="line">dst := sg.elem</span><br><span class="line">typeBitsBulkBarrier(t, <span class="type">uintptr</span>(dst), <span class="type">uintptr</span>(src), t.size)</span><br><span class="line"><span class="comment">// No need for cgo write barrier checks because dst is always</span></span><br><span class="line"><span class="comment">// Go memory.</span></span><br><span class="line">memmove(dst, src, t.size)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里涉及到一个goroutine直接写另一个goroutine栈的操作，一般而言，不同goroutine的栈是各自独有的。而这也违反了GC的一些假设。为了不出问题，写的过程中增加了写屏障，保证正确的完成写操作。这样做的好处是减少了一次内存拷贝，不用先拷贝到channel的buf，直接由发送者到接收者，减少了中间一层，效率得以提高。然后解锁，唤醒接收者，等待调度器的光临，接收者得以重见天日，可以继续执行接收操作后续代码了。</p><h2 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h2><p>接收操作有两种写法，一种带”ok”，表示channel是否被关闭；一种不带”ok”，这种写法当接收到相应类型的零值时无法知道是真实的发送者发送者发送过来的值，还是channel被关闭后，返回给接收者默认类型的零值。经过编译器的处理后，这两种写法对应源码以下的两个函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entry points for &lt;- c from compiled code</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv1</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;</span><br><span class="line">chanrecv(c, elem, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv2</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> (received <span class="type">bool</span>) &#123;</span><br><span class="line">_, received = chanrecv(c, elem, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有上述源码可见，最终都会调用<code>chanrecv</code>这个函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// chanrecv receives on channel c and writes the received data to ep.</span></span><br><span class="line"><span class="comment">// ep may be nil, in which case received data is ignored.</span></span><br><span class="line"><span class="comment">// If block == false and no elements are available, returns (false, false).</span></span><br><span class="line"><span class="comment">// Otherwise, if c is closed, zeros *ep and returns (true, false).</span></span><br><span class="line"><span class="comment">// Otherwise, fills in *ep with an element and returns (true, true).</span></span><br><span class="line"><span class="comment">// A non-nil ep must point to the heap or the caller&#x27;s stack.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>)</span></span> (selected, received <span class="type">bool</span>) &#123;</span><br><span class="line"><span class="comment">// raceenabled: don&#x27;t need to check ep, as it is always on the stack</span></span><br><span class="line"><span class="comment">// or is new memory allocated by reflect.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debugChan &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;chanrecv: chan=&quot;</span>, c, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;  <span class="comment">// 如果是nil的channel</span></span><br><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fast path: check for failed non-blocking operation without acquiring the lock.</span></span><br><span class="line"><span class="keyword">if</span> !block &amp;&amp; empty(c) &#123;</span><br><span class="line"><span class="comment">// After observing that the channel is not ready for receiving, we observe whether the</span></span><br><span class="line"><span class="comment">// channel is closed.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Reordering of these checks could lead to incorrect behavior when racing with a close.</span></span><br><span class="line"><span class="comment">// For example, if the channel was open and not empty, was closed, and then drained,</span></span><br><span class="line"><span class="comment">// reordered reads could incorrectly indicate &quot;open and empty&quot;. To prevent reordering,</span></span><br><span class="line"><span class="comment">// we use atomic loads for both checks, and rely on emptying and closing to happen in</span></span><br><span class="line"><span class="comment">// separate critical sections under the same lock.  This assumption fails when closing</span></span><br><span class="line"><span class="comment">// an unbuffered channel with a blocked send, but that is an error condition anyway.</span></span><br><span class="line"><span class="keyword">if</span> atomic.Load(&amp;c.closed) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// Because a channel cannot be reopened, the later observation of the channel</span></span><br><span class="line"><span class="comment">// being not closed implies that it was also not closed at the moment of the</span></span><br><span class="line"><span class="comment">// first observation. We behave as if we observed the channel at that moment</span></span><br><span class="line"><span class="comment">// and report that the receive cannot proceed.</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// The channel is irreversibly closed. Re-check whether the channel has any pending data</span></span><br><span class="line"><span class="comment">// to receive, which could have arrived between the empty and closed checks above.</span></span><br><span class="line"><span class="comment">// Sequential consistency is also required here, when racing with such a send.</span></span><br><span class="line"><span class="keyword">if</span> empty(c) &#123;</span><br><span class="line"><span class="comment">// The channel is irreversibly closed and empty.</span></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">raceacquire(c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemclr(c.elemtype, ep)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t0 <span class="type">int64</span></span><br><span class="line"><span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">t0 = cputicks()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &amp;&amp; c.qcount == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">raceacquire(c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemclr(c.elemtype, ep)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Found a waiting sender. If buffer is size 0, receive value</span></span><br><span class="line"><span class="comment">// directly from sender. Otherwise, receive from head of queue</span></span><br><span class="line"><span class="comment">// and add sender&#x27;s value to the tail of the queue (both map to</span></span><br><span class="line"><span class="comment">// the same buffer slot because the queue is full).</span></span><br><span class="line">recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有缓冲channel，buf里面有元素，可以正常接收</span></span><br><span class="line"><span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// Receive directly from queue</span></span><br><span class="line">qp := chanbuf(c, c.recvx)</span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">racenotify(c, c.recvx, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;  <span class="comment">// 不忽略要接收的值，不是&quot;&lt;-ch&quot;，而是&quot;val &lt;-ch&quot;，ep指向val</span></span><br><span class="line">typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">&#125;</span><br><span class="line">typedmemclr(c.elemtype, qp)  <span class="comment">// 清理掉循环数组里相应位置的值</span></span><br><span class="line">c.recvx++  <span class="comment">// 接收游标向前移动</span></span><br><span class="line"><span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">c.recvx = <span class="number">0</span>  <span class="comment">// 接收游标归零</span></span><br><span class="line">&#125;</span><br><span class="line">c.qcount--</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// no sender available: block on this channel.</span></span><br><span class="line">gp := getg()</span><br><span class="line">mysg := acquireSudog()</span><br><span class="line">mysg.releasetime = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">mysg.releasetime = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line"><span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">mysg.elem = ep</span><br><span class="line">mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">gp.waiting = mysg</span><br><span class="line">mysg.g = gp</span><br><span class="line">mysg.isSelect = <span class="literal">false</span></span><br><span class="line">mysg.c = c</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">c.recvq.enqueue(mysg)</span><br><span class="line"><span class="comment">// Signal to anyone trying to shrink our stack that we&#x27;re about</span></span><br><span class="line"><span class="comment">// to park on a channel. The window between when this G&#x27;s status</span></span><br><span class="line"><span class="comment">// changes and when we set gp.activeStackChans is not safe for</span></span><br><span class="line"><span class="comment">// stack shrinking.</span></span><br><span class="line">atomic.Store8(&amp;gp.parkingOnChan, <span class="number">1</span>)</span><br><span class="line">gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanReceive, traceEvGoBlockRecv, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// someone woke us up</span></span><br><span class="line"><span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">throw(<span class="string">&quot;G waiting list is corrupted&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">gp.waiting = <span class="literal">nil</span></span><br><span class="line">gp.activeStackChans = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">success := mysg.success</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">mysg.c = <span class="literal">nil</span></span><br><span class="line">releaseSudog(mysg)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, success</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closechan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;close of nil channel&quot;</span>))  <span class="comment">// 关闭一个nil的channel直接panic</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;close of closed channel&quot;</span>))  <span class="comment">// 关闭一个已经关闭的channel，panic</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">callerpc := getcallerpc()</span><br><span class="line">racewritepc(c.raceaddr(), callerpc, funcPC(closechan))</span><br><span class="line">racerelease(c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.closed = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> glist gList</span><br><span class="line"></span><br><span class="line"><span class="comment">// release all readers</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">sg := c.recvq.dequeue()</span><br><span class="line"><span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemclr(c.elemtype, sg.elem)</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">gp := sg.g</span><br><span class="line">gp.param = unsafe.Pointer(sg)</span><br><span class="line">sg.success = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">raceacquireg(gp, c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line">glist.push(gp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// release all writers (they will panic)</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">sg := c.sendq.dequeue()</span><br><span class="line"><span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">gp := sg.g</span><br><span class="line">gp.param = unsafe.Pointer(sg)</span><br><span class="line">sg.success = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">raceacquireg(gp, c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line">glist.push(gp)</span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ready all Gs now that we&#x27;ve dropped the channel lock.</span></span><br><span class="line"><span class="keyword">for</span> !glist.empty() &#123;</span><br><span class="line">gp := glist.pop()</span><br><span class="line">gp.schedlink = <span class="number">0</span></span><br><span class="line">goready(gp, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><ul><li>close逻辑比较简单，对于一个channel，recvq和sendq中分别保存了阻塞的发送者和接收者。关闭channel后，对于等待接收者而言，会收到一个相应类型的零值。对于等待发送者，会直接panic。所以，在不了解channel还有没有接收者的情况下，不能贸然关闭channel。</li><li>close函数先上一把大锁，接着把所有挂在这个channel上的sender和receiver全都连成一个sudog链表，再解锁。最后再将所有的sudog全都唤醒。</li><li>唤醒之后，该干什么干什么。sender会继续执行chansend函数里goparkunlock函数之后的代码，当检测到channel已经关闭了则会panic。receiver则会进行后续的扫尾工作，然后返回，这里selected会返回true，received会根据channel是否关闭返回不同的值。</li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文基于go版本1.16&lt;/p&gt;
&lt;h2 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h2&gt;&lt;p&gt;其底层数据结构为runtime包下的一个hchan的结构体，如下：&lt;/p&gt;
&lt;fig</summary>
      
    
    
    
    <category term="go" scheme="https://zcej.github.io/categories/go/"/>
    
    
  </entry>
  
  <entry>
    <title>go语言变量逃逸分析</title>
    <link href="https://zcej.github.io/2022/02/12/go/go%E8%AF%AD%E8%A8%80%E5%8F%98%E9%87%8F%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/"/>
    <id>https://zcej.github.io/2022/02/12/go/go%E8%AF%AD%E8%A8%80%E5%8F%98%E9%87%8F%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</id>
    <published>2022-02-12T07:16:09.000Z</published>
    <updated>2022-06-28T16:22:59.830Z</updated>
    
    <content type="html"><![CDATA[<p>go实现了内存的自动管理，其主要包括两个动作：分配与释放。为了更好的理解逃逸分析，需要对堆和栈有一定的了解。</p><h2 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h2><p>应用程序的内存载体，可以简单分为堆和栈。</p><p>在go中，栈的内存是由编译器进行分配和释放，栈区往往存储着函数参数、局部变量和调用函数帧，它们随着函数的创建而分配，函数的退出而销毁。一个goroutine对应一个栈，栈是调用栈的简称。一个栈通常又包含了许多栈帧，它描述的函数之间的调用关系，每一帧对应一次尚未返回的函数调用，它本身也是以栈形式存放数据。</p><p>与栈不同的是，应用程序在运行时只会存在一个堆。狭隘的说，内存管理只是针对堆内存而言的。程序在运行期间可以主动从堆上申请内存，这些内存通过go的内存分配器分配，并由垃圾回收器回收。</p><p>另外，对于堆内存的回收，还需要通过标记清除阶段，如三色标记法。但是对于栈上的内存而言，其分配和释放非常廉价。简单的说，它只需要两个cpu指令，一个是分配入栈，一个是栈内释放，而这只需要借助栈相关的寄存器即可完成。</p><h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><p>对于一个对象是被分配在堆上还是栈上，<a href="https://go.dev/doc/faq#stack_or_heap">官网</a>上也有这样的回答：</p><ul><li>如果可以，go编译器会尽可能将变量分配到栈上。但是，当编译器无法证明函数返回后，该变量没有被引用，那么编译器就必须在堆上分配该变量，以此避免悬挂指针。另外如果局部变量非常大，也会将其分配在堆上。</li><li>而go编译器则是通过逃逸分析去选择堆或者是栈，逃逸分析的基本思想如下：检查变量的生命周期是否是完全可知的，如果通过检查，则可以在栈上分配。否则，就是逃逸，必须在堆上进行分配。</li></ul><p>可以通过命令<code>go build -gcflags &quot;-m -l&quot;</code>来查看逃逸分析结果：</p><ul><li>-m：打印逃逸分析信息</li><li>-l：禁止内联优化</li></ul><p>常见的逃逸情况如下所示：</p><h3 id="情况一：变量类型不确定"><a href="#情况一：变量类型不确定" class="headerlink" title="情况一：变量类型不确定"></a>情况一：变量类型不确定</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">666</span></span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出如下</span></span><br><span class="line"><span class="comment">// $ go build -gcflags &quot;-m -l&quot; main.go</span></span><br><span class="line"><span class="comment">// # command-line-arguments</span></span><br><span class="line"><span class="comment">// ./main.go:7:13: ... argument does not escape</span></span><br><span class="line"><span class="comment">// ./main.go:7:13: a escapes to heap</span></span><br></pre></td></tr></table></figure><p>变量a发生了逃逸是因为其被传入了<code>fmt.Println</code>中，这个方法参数自己发生了逃逸。</p><blockquote><ul><li><code>func Println(a ...interface&#123;&#125;) (n int, err error)</code></li><li>因为<code>fmt.Println</code>函数参数为<code>interface</code>类型，编译期无法确定参数的具体类型，故分配在堆上</li></ul></blockquote><h3 id="情况二：暴露给外部指针"><a href="#情况二：暴露给外部指针" class="headerlink" title="情况二：暴露给外部指针"></a>情况二：暴露给外部指针</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> *<span class="type">int</span> &#123;</span><br><span class="line">    a := <span class="number">666</span></span><br><span class="line">    <span class="keyword">return</span> &amp;a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _ = foo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// # command-line-arguments</span></span><br><span class="line"><span class="comment">// .\main.go:4:2: moved to heap: a</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>变量存在外部引用则必定分配到堆上。</p><h3 id="情况三：变量所占内存较大"><a href="#情况三：变量所占内存较大" class="headerlink" title="情况三：变量所占内存较大"></a>情况三：变量所占内存较大</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10000</span>, <span class="number">10000</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        s[i] = i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    foo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// # command-line-arguments</span></span><br><span class="line"><span class="comment">// .\main.go:4:11: make([]int, 10000, 10000) escapes to heap</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里需要注意，在go中执行用户代码的goroutine是一种用户态线程，其调用栈内存被称为用户栈，它其实也是从堆区分配的，但是我们仍然可以将其看作和系统栈一样的内存空间，它的分配和释放都是通过编译器完成的。与其对应的是系统栈，它的分配和释放是操作系统完成的。在GMP模型中，一个M对应一个系统栈(也称为M的g0栈)，M上的多个goroutine会共享该系统栈。</p><ul><li><p>不同架构的系统栈最大限制不同，以x86_64为例，其系统栈最大为8mb</p></li><li><p>我们常说的goroutine初始大小为2kb，说的是用户栈，可在<code>runtime/stack.go</code>中找到</p></li><li><p>在go中大对象的范围为大于32kb，即上述代码中的n达到8192，就会逃逸</p><h3 id="情况四：变量大小不确定"><a href="#情况四：变量大小不确定" class="headerlink" title="情况四：变量大小不确定"></a>情况四：变量大小不确定</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    n := <span class="number">1</span></span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        s[i] = i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    foo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// # command-line-arguments</span></span><br><span class="line"><span class="comment">// .\main.go:5:11: make([]int, n) escapes to heap</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这次，在<code>make</code>方法中，没有直接指定大小，而是填入了变量<code>n</code>，这时go逃逸分析也会将其分配到堆区去。可见，为了保证内存的绝对安全，go的编译器可能会将一些变量不合时宜地分配到堆上，但是因为这些对象最终也会被垃圾收集器处理，所以也能接受。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2></li><li><p>发生逃逸的情况还有很多，理解其思想才是最为重要的。</p></li><li><p>理解逃逸分析可以帮助我们写出更好的程序，知道变量分配在堆栈上的差别，则尽可能写出分配在栈上的代码，堆上的变量变少了，可以减轻内存分配的开销，减小gc的压力，提高程序的运行速度。</p></li><li><p>你会发现有些go上线项目，它们在函数传参的时候，并没有传递结构体指针，而是直接传递的结构体。这个做法，虽然它需要值拷贝，但是这是在栈上完成的操作，开销远比变量逃逸后动态的在堆上分配内存少的多。当然这个做法不是绝对的，如果结构体较大，传递指针将更加合适。</p></li><li><p>从gc的角度来看，指针传递是个双刃剑，需要谨慎使用，否则线上调优解决gc延时会让人崩溃。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;go实现了内存的自动管理，其主要包括两个动作：分配与释放。为了更好的理解逃逸分析，需要对堆和栈有一定的了解。&lt;/p&gt;
&lt;h2 id=&quot;堆和栈&quot;&gt;&lt;a href=&quot;#堆和栈&quot; class=&quot;headerlink&quot; title=&quot;堆和栈&quot;&gt;&lt;/a&gt;堆和栈&lt;/h2&gt;&lt;p&gt;应用程序</summary>
      
    
    
    
    <category term="go" scheme="https://zcej.github.io/categories/go/"/>
    
    
  </entry>
  
</feed>
