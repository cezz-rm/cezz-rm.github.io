<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://zcej.github.io/atom.xml" rel="self"/>
  
  <link href="https://zcej.github.io/"/>
  <updated>2022-07-03T13:03:05.080Z</updated>
  <id>https://zcej.github.io/</id>
  
  <author>
    <name>CeJ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>快速上手BeautifulSoup4</title>
    <link href="https://zcej.github.io/2022/06/08/%E7%88%AC%E8%99%AB/BeautifulSoup4%E8%A7%A3%E6%9E%90/"/>
    <id>https://zcej.github.io/2022/06/08/%E7%88%AC%E8%99%AB/BeautifulSoup4%E8%A7%A3%E6%9E%90/</id>
    <published>2022-06-08T13:03:11.000Z</published>
    <updated>2022-07-03T13:03:05.080Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装BeautifulSoup"><a href="#安装BeautifulSoup" class="headerlink" title="安装BeautifulSoup"></a>安装BeautifulSoup</h3><p>可通过系统的包管理工具安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install Python-bs4</span><br></pre></td></tr></table></figure><p>或者通过python的包管理工具<code>pip</code>进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install beautifulsoup4 -i http://mirrors.aliyun.com/pypi/simple/</span><br></pre></td></tr></table></figure><h3 id="安装解析器"><a href="#安装解析器" class="headerlink" title="安装解析器"></a>安装解析器</h3><p>python内置了HTML解析器，若要使用第三方的解析器，如<code>lxml</code>，则需根据操作系统和python的版本选择对应的包进行安装，若要离线安装，windows下可点击该<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/#lxml">链接</a>下载。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt-get install Python-lxml</span><br><span class="line"></span><br><span class="line">pip install lxml</span><br></pre></td></tr></table></figure><p>或纯python实现的<code>html5lib</code>，其解析方式与浏览器相同。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt-get install Python-html5lib</span><br><span class="line"></span><br><span class="line">pip install html5lib</span><br></pre></td></tr></table></figure><table><thead><tr><th>解析器</th><th>使用方法</th><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>python标准库</td><td>BeautifulSoup(html, ‘html.parser’)</td><td></td><td></td></tr></tbody></table><ul><li>python的内置标准库</li><li>执行速度适中</li><li>文档容错能力强<br> | Python2.7.3或3.2.2前的版本中文容错能力差<br> |<br>| lxml HTML解析器 | BeautifulSoup(html, ‘lxml’) | </li><li>速度快</li><li>文档容错能力强<br> | 需要安装c语言库 |<br>| lxml XML解析器 | BeautifulSoup(html, [‘lxml’, ‘xml’]) | </li><li>速度快</li><li>唯一支持XML的解析器<br> | 需要安装c语言库 |<br>| html5lib | BeautifulSoup(html, ‘html5lib’) | </li><li>最好的容错性</li><li>以浏览器的方式解析文档</li><li>生成HTML5格式的文档<br> | </li><li>速度慢</li><li>不依赖外部扩展<br> |</li></ul><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><p>假设有一个网页<code>html</code>，创建一个<code>BeautifulSoup</code>对象，并指定解析器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(html, <span class="string">&quot;lxml)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">soup.prettify() # 缩进打印</span></span><br><span class="line"><span class="string">soup.title # 获取title标签的内容</span></span><br><span class="line"><span class="string">soup.div # 获取第一个div标签的内容</span></span><br><span class="line"><span class="string">soup.find(id=&quot;</span>uq<span class="string">&quot;) # 获取id=&quot;</span>u1<span class="string">&quot;的标签</span></span><br><span class="line"><span class="string">soup.find_all(class_=&quot;</span>item<span class="string">&quot;) # 查找所有class属性有item的标签                     </span></span><br></pre></td></tr></table></figure><blockquote><p>注：灵活利用IDE的打断点进行debug可以快速调试，拿到自己需要的元素</p></blockquote><h2 id="对象种类"><a href="#对象种类" class="headerlink" title="对象种类"></a>对象种类</h2><p>~将复杂HTML文档转换成一个复杂的树形结构，每个节点都是python对象，所有对象可以归为以下四类：</p><h3 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h3><p>Tag通俗点讲就是HTML中的一个个标签，它的类型是<code>bs4.element.Tag</code>，对于Tag有两个重要的属性，是name和attrs。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每个tag都有自己的名字，通过.name来获取</span></span><br><span class="line">tag.name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个tag可能有多个属性，其操作方式与字典相同，也可以通过点的方式获取</span></span><br><span class="line">tag[<span class="string">&quot;class&quot;</span>]</span><br><span class="line">tag.attrs</span><br></pre></td></tr></table></figure><blockquote><p>注：如果标签中某个属性有多值，则解析后返回的类型是list，但是转换的文档是xml时除外。</p></blockquote><h3 id="NavigableString"><a href="#NavigableString" class="headerlink" title="NavigableString"></a>NavigableString</h3><p>用于获取标签内部的文字，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">soup.title.string</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(bs.title.string))</span><br></pre></td></tr></table></figure><h3 id="BeautifulSoup"><a href="#BeautifulSoup" class="headerlink" title="BeautifulSoup"></a>BeautifulSoup</h3><p>表示的是一个文档的全部内容，大部分时候可以将其看作为一个特殊的Tag，可通过以下方式获取其名称和属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">soup.name</span><br><span class="line">soup.attrs</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(soup))</span><br></pre></td></tr></table></figure><h3 id="Comment"><a href="#Comment" class="headerlink" title="Comment"></a>Comment</h3><p>是一个特殊类型的NavigableString对象，其输出的内容不包括注释符号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">soup.a <span class="comment"># &lt;a class=&quot;mnav&quot;&gt;&lt;!--新闻--&gt;&lt;/a&gt;</span></span><br><span class="line"></span><br><span class="line">soup.a.string <span class="comment"># 新闻</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(soup.a.string)) <span class="comment"># &lt;class &#x27;bs4.element.Comment&#x27;&gt;</span></span><br></pre></td></tr></table></figure><h2 id="遍历文档树"><a href="#遍历文档树" class="headerlink" title="遍历文档树"></a>遍历文档树</h2><h3 id="子节点"><a href="#子节点" class="headerlink" title="子节点"></a>子节点</h3><h4 id="contents和-children"><a href="#contents和-children" class="headerlink" title=".contents和.children"></a>.contents和.children</h4><ul><li><p>contents：获取Tag的所有子节点，返回一个list</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">soup.contents</span><br><span class="line"></span><br><span class="line">soup.contents[<span class="number">0</span>].name</span><br></pre></td></tr></table></figure></li><li><p>children：获取Tag的所有子节点，返回一个生成器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> soup.body.children:</span><br><span class="line">    <span class="built_in">print</span>(child)</span><br></pre></td></tr></table></figure><h4 id="descendants"><a href="#descendants" class="headerlink" title=".descendants"></a>.descendants</h4></li><li><p><code>.contents</code>和<code>.children</code>属性仅包含tag的直接子节点，<code>.descendants</code>可以对所有tag的子孙节点进行递归循环。</p><h4 id="string"><a href="#string" class="headerlink" title=".string"></a>.string</h4></li><li><p>如果tag只有一个子节点，这个tag可以使用<code>.string</code>方法获取，如果有多个子节点，则返回为None</p><h4 id="strings和-stripped-strings"><a href="#strings和-stripped-strings" class="headerlink" title=".strings和.stripped_strings"></a>.strings和.stripped_strings</h4></li><li><p>若果tag中包含多个字符串，可以使用<code>.strings</code>循环获取</p></li><li><p>如果字符串包含很多空格或空行，可以使用<code>.stripped_strings</code>去除</p><h3 id="父节点"><a href="#父节点" class="headerlink" title="父节点"></a>父节点</h3><h4 id="parent"><a href="#parent" class="headerlink" title=".parent"></a>.parent</h4></li><li><p>通过<code>.parent</code>获取某个元素的父节点</p></li><li><p>顶层节点的父节点是BeautifulSoup对象</p></li><li><p>BeautifulSoup对象的<code>.parent</code>是None</p><h4 id="parents"><a href="#parents" class="headerlink" title=".parents"></a>.parents</h4></li><li><p>通过<code>.parents</code>可以递归获取元素的所有父节点</p><h3 id="兄弟节点"><a href="#兄弟节点" class="headerlink" title="兄弟节点"></a>兄弟节点</h3><h4 id="next-sibling和-previous-sibling"><a href="#next-sibling和-previous-sibling" class="headerlink" title=".next_sibling和.previous_sibling"></a>.next_sibling和.previous_sibling</h4></li><li><p>使用 .next_sibling 和 .previous_sibling 属性来查询兄弟节点</p><h4 id="next-siblings和-previous-siblings"><a href="#next-siblings和-previous-siblings" class="headerlink" title=".next_siblings和.previous_siblings"></a>.next_siblings和.previous_siblings</h4></li><li><p>通过 .next_siblings 和 .previous_siblings 属性可以对当前节点的兄弟节点迭代输出</p><h2 id="搜索文档树"><a href="#搜索文档树" class="headerlink" title="搜索文档树"></a>搜索文档树</h2><p>这里主要列举<code>find_all</code>和<code>find</code>方法以及CSS选择器，其他方法可参考官方文档。</p><h3 id="find-all"><a href="#find-all" class="headerlink" title="find_all"></a>find_all</h3><p>find_all(name, attrs, recursive, text, **kwargs)</p><h4 id="name参数"><a href="#name参数" class="headerlink" title="name参数"></a>name参数</h4></li><li><p>字符串过滤：会查找与字符串完全匹配的内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a_list = soup.find_all(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a_list)</span><br></pre></td></tr></table></figure></li><li><p>正则表达式过滤：如果传入的是正则表达式，那么BeautifulSoup4会通过search()来匹配内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a_list = soup.find_all(re.<span class="built_in">compile</span>(<span class="string">&quot;a&quot;</span>))</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> a_list:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure></li><li><p>列表：如果传入一个列表，BeautifulSoup4将会与列表中的任一元素匹配到的节点返回</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a_list = soup.find_all([<span class="string">&quot;meta&quot;</span>, <span class="string">&quot;link&quot;</span>])</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> a_list:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure></li><li><p>方法：传入一个方法，根据方法来匹配</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def name_is_exists(tag):</span><br><span class="line">    <span class="keyword">return</span> tag.has_attr(<span class="string">&quot;name&quot;</span>)</span><br><span class="line"></span><br><span class="line">a_list = soup.find_all(name_is_exists)</span><br><span class="line"><span class="keyword">for</span> item in a_list:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure><h4 id="kwargs"><a href="#kwargs" class="headerlink" title="kwargs"></a>kwargs</h4><p>如果一个指定名字的参数不是搜索内置的参数名,搜索时会把该参数当作指定名字tag的属性来搜索</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询id=head的Tag</span></span><br><span class="line">t_list = soup.find_all(<span class="built_in">id</span>=<span class="string">&quot;head&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(t_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询href属性包含ss1.bdstatic.com的Tag</span></span><br><span class="line">t_list = soup.find_all(href=re.<span class="built_in">compile</span>(<span class="string">&quot;http://news.baidu.com&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(t_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询所有包含class的Tag(注：class要加上_进行区分)</span></span><br><span class="line">t_list = soup.find_all(class_=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> t_list:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure><h4 id="attrs"><a href="#attrs" class="headerlink" title="attrs"></a>attrs</h4><p>不是所有的属性都可以使用上面的方式进行搜索，比如HTML的data-*属性，这时可以使用attrs参数，定义一个字典来搜索包含特殊属性的tag。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t_list = soup.find_all(attrs=&#123;<span class="string">&quot;data-foo&quot;</span>:<span class="string">&quot;value&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> t_list:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure><h4 id="string-1"><a href="#string-1" class="headerlink" title="string"></a>string</h4><p>通过string参数可以搜索文档中的字符串内容，与name参数的可选值一样，string参数接收字符串，正则表达式，列表，True。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t_list = soup.find_all(string=<span class="string">&quot;Elsie&quot;</span>)</span><br><span class="line">    </span><br><span class="line">t_list = soup.find_all(string=[<span class="string">&quot;Tillie&quot;</span>, <span class="string">&quot;Elsie&quot;</span>, <span class="string">&quot;Lacie&quot;</span>])</span><br><span class="line"></span><br><span class="line">t_list = soup.find_all(string=re.<span class="built_in">compile</span>(<span class="string">&quot;Dormouse&quot;</span>))</span><br></pre></td></tr></table></figure><h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><p>传入一个limit参数来限制返回的数量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t_list = soup.find_all(<span class="string">&quot;a&quot;</span>, limit=<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> t_list:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure><h4 id="recursive"><a href="#recursive" class="headerlink" title="recursive"></a>recursive</h4><p>默认会检索当前tag的所有子孙节点，如果只想搜索直接子节点，可以使用该参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">soup.html.find_all(recursive=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>find( name , attrs , recursive , string , **kwargs )<br>返回符合条件的第一个Tag，即当我们要取一个值的时候就可以用该方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">soup.find(<span class="string">&quot;head&quot;</span>).find(<span class="string">&quot;title&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h3></li><li><p>通过tag标签名查找</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">soup.select(<span class="string">&quot;title&quot;</span>)</span><br><span class="line"></span><br><span class="line">soup.select(<span class="string">&quot;a&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>通过tag标签逐层查找：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">soup.select(<span class="string">&quot;body a&quot;</span>)</span><br><span class="line"></span><br><span class="line">soup.select(<span class="string">&quot;html head title&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>找到某个tag标签下的直接子标签：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">soup.select(<span class="string">&quot;head &gt; title&quot;</span>)</span><br><span class="line"></span><br><span class="line">soup.select(<span class="string">&quot;p &gt; #link1&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>找到兄弟节点标签：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">soup.select(<span class="string">&quot;#link1 ~ .sister&quot;</span>)</span><br><span class="line"></span><br><span class="line">soup.select(<span class="string">&quot;#link1 + .sister&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>通过class属性查找：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">soup.select(<span class="string">&quot;.sister&quot;</span>)</span><br><span class="line"></span><br><span class="line">soup.select(<span class="string">&quot;[class~=sister]&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>通过tag的id查找：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">soup.select(<span class="string">&#x27;#link1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">soup.select(<span class="string">&quot;a#link2&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>同时用多种css选择器查询：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">soup.select(<span class="string">&quot;#link1,#link2&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>通过是否存在某个属性来查找：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">soup.select(<span class="string">&quot;a[href]&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>通过属性的值来查找：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">soup.select(<span class="string">&#x27;a[href=&quot;http://example.com/elsie&quot;]&#x27;</span>)</span><br><span class="line"></span><br><span class="line">soup.select<span class="string">&#x27;a[href^=&quot;http://example.com&quot;]&#x27;</span>)</span><br><span class="line"></span><br><span class="line">soup.select(<span class="string">&#x27;a[href$=&quot;tillie&quot;]&#x27;</span>)</span><br><span class="line"></span><br><span class="line">soup.select(<span class="string">&#x27;a[href*=&quot;.com/el&quot;]&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>通过语言设置来查找：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">multilingual_markup = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"> &lt;p lang=&quot;en&quot;&gt;Hello&lt;/p&gt;</span></span><br><span class="line"><span class="string"> &lt;p lang=&quot;en-us&quot;&gt;Howdy, y&#x27;all&lt;/p&gt;</span></span><br><span class="line"><span class="string"> &lt;p lang=&quot;en-gb&quot;&gt;Pip-pip, old fruit&lt;/p&gt;</span></span><br><span class="line"><span class="string"> &lt;p lang=&quot;fr&quot;&gt;Bonjour mes amis&lt;/p&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">multilingual_soup = BeautifulSoup(multilingual_markup)</span><br><span class="line">multilingual_soup.select(<span class="string">&#x27;p[lang|=en]&#x27;</span>)</span><br><span class="line"><span class="comment"># [&lt;p lang=&quot;en&quot;&gt;Hello&lt;/p&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;p lang=&quot;en-us&quot;&gt;Howdy, y&#x27;all&lt;/p&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;p lang=&quot;en-gb&quot;&gt;Pip-pip, old fruit&lt;/p&gt;]</span></span><br></pre></td></tr></table></figure></li><li><p>返回查找到的元素的第一个</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">soup.select_one(<span class="string">&quot;.sister&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="修改文档树"><a href="#修改文档树" class="headerlink" title="修改文档树"></a>修改文档树</h2><p>BeautifulSoup的强项是文档树的搜索，但同时也可以方便的修改文档树，这部分可详细参考官方文档。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;h3 id=&quot;安装BeautifulSoup&quot;&gt;&lt;a href=&quot;#安装BeautifulSoup&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="python" scheme="https://zcej.github.io/categories/python/"/>
    
    <category term="爬虫" scheme="https://zcej.github.io/categories/python/%E7%88%AC%E8%99%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>项目实战：go语言实现redis(四)</title>
    <link href="https://zcej.github.io/2022/05/27/go/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%EF%BC%9Ago%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0redis(%E5%9B%9B)/"/>
    <id>https://zcej.github.io/2022/05/27/go/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%EF%BC%9Ago%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0redis(%E5%9B%9B)/</id>
    <published>2022-05-27T12:51:46.000Z</published>
    <updated>2022-06-28T15:48:16.023Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>本系列文章记录如何基于go语言实现Redis，从整体设计到具体细节实现，不仅可以有效的锻炼自己的编码能力，又能加深对redis的认识。文章主要从整体设计思路入手，记录关键的设计步骤，详细的实现可以参考<a href="https://github.com/zcej/go-redis">github</a>上的相关代码。主体上有下面几个部分：</p><ul><li>TCP服务器(一)：支持同时监听多个TCP连接，并进行相关处理</li><li>Redis协议解析器(一)：实现相关Handler，命令解析及响应处理</li><li>内存数据库(二)：实现数据库，注册相关命令，完成支持对数据库的增删改查</li><li>Redis持久化(三)：实现redis中的持久化功能aof</li><li>**Redis集群(四)**：本文将通过一致性哈希的方式实现cluster集群</li></ul><p>本章的项目目录结构如下，在前一篇的基础上新增了cluster相关文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">├─aof</span><br><span class="line">│</span><br><span class="line">├─cluster</span><br><span class="line">│  client_pool.go</span><br><span class="line">│  cluster_database.go</span><br><span class="line">│  com.go</span><br><span class="line">│  del.go</span><br><span class="line">│  keys.go</span><br><span class="line">│  ping.go</span><br><span class="line">│  rename.go</span><br><span class="line">│  router.go</span><br><span class="line">│</span><br><span class="line">├─config</span><br><span class="line">│</span><br><span class="line">├─database</span><br><span class="line">│</span><br><span class="line">├─datastruct</span><br><span class="line">│  └─dict</span><br><span class="line">│</span><br><span class="line">├─interface</span><br><span class="line">│  ├─database</span><br><span class="line">│  │</span><br><span class="line">│  ├─dict</span><br><span class="line">│  │</span><br><span class="line">│  ├─resp</span><br><span class="line">│  │</span><br><span class="line">│  └─tcp</span><br><span class="line">│</span><br><span class="line">├─lib</span><br><span class="line">│</span><br><span class="line">├─resp</span><br><span class="line">│  ├─connection</span><br><span class="line">│  │</span><br><span class="line">│  ├─handler</span><br><span class="line">│  │</span><br><span class="line">│  ├─parser</span><br><span class="line">│  │</span><br><span class="line">│  └─reply</span><br><span class="line">│</span><br><span class="line">├─tcp</span><br><span class="line">│</span><br><span class="line">│ go.mod</span><br><span class="line">│ main.go</span><br><span class="line">│ redis.conf</span><br></pre></td></tr></table></figure><h2 id="实现一致性hash"><a href="#实现一致性hash" class="headerlink" title="实现一致性hash"></a>实现一致性hash</h2><p>结构体定义<br />在文件<code>lib/comsistenthash/comsistenthash.go</code>中定义结构体<code>NodeMap</code>，包含下面几个属性，并进行初始化，此处设置了一个默认的哈希函数<code>crc32.ChecksumIEEE</code>。</p><ul><li><p><code>hashFunc</code>：类型为func，需要指定一个hash函数</p></li><li><p><code>nodeHashs</code>：类型为int类型的切片，存储节点哈希后的值，且该切片有序的</p></li><li><p><code>nodehashMap</code>：类型为map，key为哈希值，value是节点的地址</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashFunc defines function to generate hash code</span></span><br><span class="line"><span class="keyword">type</span> HashFunc <span class="function"><span class="keyword">func</span><span class="params">(data []<span class="type">byte</span>)</span></span> <span class="type">uint32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NodeMap stores nodes and you can pick node from NodeMap</span></span><br><span class="line"><span class="keyword">type</span> NodeMap <span class="keyword">struct</span> &#123;</span><br><span class="line">    hashFunc    HashFunc</span><br><span class="line">    nodeHashs   []<span class="type">int</span> <span class="comment">// sorted</span></span><br><span class="line">    nodehashMap <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewNodeMap creates a new NodeMap</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewNodeMap</span><span class="params">(fn HashFunc)</span></span> *NodeMap &#123;</span><br><span class="line">    m := &amp;NodeMap&#123;</span><br><span class="line">        hashFunc:    fn,</span><br><span class="line">        nodehashMap: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> m.hashFunc == <span class="literal">nil</span> &#123;</span><br><span class="line">        m.hashFunc = crc32.ChecksumIEEE</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法实现<br />需要实现添加节点到哈希环中和从哈希环取出节点的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IsEmpty returns if there is no node in NodeMap</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *NodeMap)</span></span> IsEmpty() <span class="type">bool</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AddNode add the given nodes into consistent hash circle</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *NodeMap)</span></span> AddNode(keys ...<span class="type">string</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PickNode gets the closest item in the hash to the provided key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *NodeMap)</span></span> PickNode(key <span class="type">string</span>) <span class="type">string</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="集群核心架构"><a href="#集群核心架构" class="headerlink" title="集群核心架构"></a>集群核心架构</h2><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><p>为了支持高并发的连接及能够对连接进行复用，此处引进了一个第三方连接池，通过命令<code>go get &quot;github.com/jolestar/go-commons-pool/v2&quot;</code>进行下载。另外，在<code>cluster/client_pool.go</code>中定义结构体<code>connectionFactory</code>实现其接口<code>PooledObjectFactory</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> connectionFactory <span class="keyword">struct</span> &#123;</span><br><span class="line">    Peer <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *connectionFactory)</span></span> MakeObject(ctx context.Context) (*pool.PooledObject, <span class="type">error</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *connectionFactory)</span></span> DestroyObject(ctx context.Context, object *pool.PooledObject) <span class="type">error</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *connectionFactory)</span></span> ValidateObject(ctx context.Context, object *pool.PooledObject) <span class="type">bool</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *connectionFactory)</span></span> ActivateObject(ctx context.Context, object *pool.PooledObject) <span class="type">error</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *connectionFactory)</span></span> PassivateObject(ctx context.Context, object *pool.PooledObject) <span class="type">error</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="实现ClusterDatabase"><a href="#实现ClusterDatabase" class="headerlink" title="实现ClusterDatabase"></a>实现ClusterDatabase</h3><p>需要对原来单体的Database进行进一步封装，新建文件<code>cluster/cluster_database.go</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClusterDatabase represents a node of godis cluster</span></span><br><span class="line"><span class="comment">// it holds part of data and coordinates other nodes to finish transactions</span></span><br><span class="line"><span class="keyword">type</span> ClusterDatabase <span class="keyword">struct</span> &#123;</span><br><span class="line">    self           <span class="type">string</span></span><br><span class="line"></span><br><span class="line">    nodes          []<span class="type">string</span></span><br><span class="line">    peerPicker     *consistenthash.NodeMap</span><br><span class="line">    peerConnection <span class="keyword">map</span>[<span class="type">string</span>]*pool.ObjectPool</span><br><span class="line">    db             databaseface.Database</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MakeClusterDatabase creates and starts a node of cluster</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeClusterDatabase</span><span class="params">()</span></span> *ClusterDatabase &#123;</span><br><span class="line">    cluster := &amp;ClusterDatabase&#123;</span><br><span class="line">        self: config.Properties.Self,</span><br><span class="line"></span><br><span class="line">        db:             database.NewStandaloneDatabase(),</span><br><span class="line">        peerPicker:     consistenthash.NewNodeMap(<span class="literal">nil</span>),</span><br><span class="line">        peerConnection: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*pool.ObjectPool),</span><br><span class="line">    &#125;</span><br><span class="line">    nodes := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(config.Properties.Peers)+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> _, peer := <span class="keyword">range</span> config.Properties.Peers &#123;</span><br><span class="line">        nodes = <span class="built_in">append</span>(nodes, peer)</span><br><span class="line">    &#125;</span><br><span class="line">    nodes = <span class="built_in">append</span>(nodes, config.Properties.Self)</span><br><span class="line">    cluster.peerPicker.AddNode(nodes...)</span><br><span class="line">    ctx := context.Background()</span><br><span class="line">    <span class="keyword">for</span> _, peer := <span class="keyword">range</span> config.Properties.Peers &#123;</span><br><span class="line">        cluster.peerConnection[peer] = pool.NewObjectPoolWithDefaultConfig(ctx, &amp;connectionFactory&#123;</span><br><span class="line">            Peer: peer,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    cluster.nodes = nodes</span><br><span class="line">    <span class="keyword">return</span> cluster</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外还需实现以下几个方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Close stops current node of cluster</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cluster *ClusterDatabase)</span></span> Close() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Exec executes command on cluster</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cluster *ClusterDatabase)</span></span> Exec(c resp.Connection, cmdLine [][]<span class="type">byte</span>) (result resp.Reply) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AfterClientClose does some clean after client close connection</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cluster *ClusterDatabase)</span></span> AfterClientClose(c resp.Connection) &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="操作连接池"><a href="#操作连接池" class="headerlink" title="操作连接池"></a>操作连接池</h3><p><code>cluster/com.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cluster *ClusterDatabase)</span></span> getPeerClient(peer <span class="type">string</span>) (*client.Client, <span class="type">error</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cluster *ClusterDatabase)</span></span> returnPeerClient(peer <span class="type">string</span>, peerClient *client.Client) <span class="type">error</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// relay relays command to peer</span></span><br><span class="line"><span class="comment">// select db by c.GetDBIndex()</span></span><br><span class="line"><span class="comment">// cannot call Prepare, Commit, execRollback of self node</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cluster *ClusterDatabase)</span></span> relay(peer <span class="type">string</span>, c resp.Connection, args [][]<span class="type">byte</span>) resp.Reply &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// broadcast broadcasts command to all node in cluster</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cluster *ClusterDatabase)</span></span> broadcast(c resp.Connection, args [][]<span class="type">byte</span>) <span class="keyword">map</span>[<span class="type">string</span>]resp.Reply &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="指令路由"><a href="#指令路由" class="headerlink" title="指令路由"></a>指令路由</h3><p>需要根据不同的指令，操作对应的节点，这里需要有一个全局的方式，找到执行指令的相关函数，新建文件<code>cluster/router.go</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeRouter</span><span class="params">()</span></span> <span class="keyword">map</span>[<span class="type">string</span>]CmdFunc &#123;</span><br><span class="line">    routerMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]CmdFunc)</span><br><span class="line">    routerMap[<span class="string">&quot;ping&quot;</span>] = ping</span><br><span class="line"></span><br><span class="line">    routerMap[<span class="string">&quot;del&quot;</span>] = Del</span><br><span class="line"></span><br><span class="line">    routerMap[<span class="string">&quot;exists&quot;</span>] = defaultFunc</span><br><span class="line">    routerMap[<span class="string">&quot;type&quot;</span>] = defaultFunc</span><br><span class="line">    routerMap[<span class="string">&quot;rename&quot;</span>] = Rename</span><br><span class="line">    routerMap[<span class="string">&quot;renamenx&quot;</span>] = Rename</span><br><span class="line"></span><br><span class="line">    routerMap[<span class="string">&quot;set&quot;</span>] = defaultFunc</span><br><span class="line">    routerMap[<span class="string">&quot;setnx&quot;</span>] = defaultFunc</span><br><span class="line">    routerMap[<span class="string">&quot;get&quot;</span>] = defaultFunc</span><br><span class="line">    routerMap[<span class="string">&quot;getset&quot;</span>] = defaultFunc</span><br><span class="line"></span><br><span class="line">    routerMap[<span class="string">&quot;flushdb&quot;</span>] = FlushDB</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> routerMap</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// relay command to responsible peer, and return its reply to client</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">defaultFunc</span><span class="params">(cluster *ClusterDatabase, c resp.Connection, args [][]<span class="type">byte</span>)</span></span> resp.Reply &#123;</span><br><span class="line">    key := <span class="type">string</span>(args[<span class="number">1</span>])</span><br><span class="line">    peer := cluster.peerPicker.PickNode(key)</span><br><span class="line">    <span class="keyword">return</span> cluster.relay(peer, c, args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改特殊的指令操作，分别在下述文件中添加对应的函数。</p></li><li><p><code>cluster/ping.go</code>：直接执行即可</p></li><li><p><code>cluster/del.go</code>：需要广播至集群的所有节点</p></li><li><p><code>cluster/rename.go</code>：需要找到键所在的节点执行，并处理重命名后更换节点的情况</p></li><li><p><code>cluster/keys.go</code>：需要广播至集群的所有节点</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ping</span><span class="params">(cluster *ClusterDatabase, c resp.Connection, cmdAndArgs [][]<span class="type">byte</span>)</span></span> resp.Reply &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Del atomically removes given writeKeys from cluster, writeKeys can be distributed on any node</span></span><br><span class="line"><span class="comment">// if the given writeKeys are distributed on different node, Del will use try-commit-catch to remove them</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Del</span><span class="params">(cluster *ClusterDatabase, c resp.Connection, args [][]<span class="type">byte</span>)</span></span> resp.Reply &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rename renames a key, the origin and the destination must within the same node</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Rename</span><span class="params">(cluster *ClusterDatabase, c resp.Connection, args [][]<span class="type">byte</span>)</span></span> resp.Reply &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FlushDB removes all data in current database</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FlushDB</span><span class="params">(cluster *ClusterDatabase, c resp.Connection, args [][]<span class="type">byte</span>)</span></span> resp.Reply &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="启用集群模式"><a href="#启用集群模式" class="headerlink" title="启用集群模式"></a>启用集群模式</h2><p>要使用集群需要修改<code>resp/handler/handler.go</code>中初始化Database的逻辑。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MakeHandler creates a RespHandler instance</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeHandler</span><span class="params">()</span></span> *RespHandler &#123;</span><br><span class="line">    <span class="keyword">var</span> db databaseface.Database</span><br><span class="line">    <span class="keyword">if</span> config.Properties.Self != <span class="string">&quot;&quot;</span> &amp;&amp;</span><br><span class="line">        <span class="built_in">len</span>(config.Properties.Peers) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        db = cluster.MakeClusterDatabase()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        db = database.NewStandaloneDatabase()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;RespHandler&#123;</span><br><span class="line">        db: db,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，基于go语言实现redis的项目已基本完成了。项目中有许多值得学习的地方，例如整个架构的设计，整体功能的切分及具体实现。每一步的过程都需要有自己的思考，而不是按部就班，随便记录以下就完了，记录下这个系列的文章，也是为了以后的回顾，温故而知新才能不断的加深影响提高自己。不过项目也依然有很多需要优化的地方，这个可以参考开源的项目<a href="https://github.com/HDT3213/godis">godis</a>。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;本系列文章记录如何基于go语言实现Redis，从整体设计到具体细节实现，不仅可以有效的锻炼自己的编码能力，又能加深对redis的认识。文章主</summary>
      
    
    
    
    <category term="go" scheme="https://zcej.github.io/categories/go/"/>
    
    <category term="项目实战" scheme="https://zcej.github.io/categories/go/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    
    
  </entry>
  
  <entry>
    <title>项目实战：go语言实现redis(三)</title>
    <link href="https://zcej.github.io/2022/05/21/go/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%EF%BC%9Ago%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0redis(%E4%B8%89)/"/>
    <id>https://zcej.github.io/2022/05/21/go/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%EF%BC%9Ago%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0redis(%E4%B8%89)/</id>
    <published>2022-05-21T02:14:09.000Z</published>
    <updated>2022-06-28T15:53:39.796Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>本系列文章记录如何基于go语言实现Redis，从整体设计到具体细节实现，不仅可以有效的锻炼自己的编码能力，又能加深对redis的认识。文章主要从整体设计思路入手，记录关键的设计步骤，详细的实现可以参考<a href="https://github.com/zcej/go-redis">github</a>上的相关代码。主体上有下面几个部分：</p><ul><li>TCP服务器(一)：支持同时监听多个TCP连接，并进行相关处理</li><li>Redis协议解析器(一)：实现相关Handler，命令解析及响应处理</li><li>内存数据库(二)：实现数据库，注册相关命令，完成支持对数据库的增删改查</li><li>**Redis持久化(三)**：实现redis中的持久化功能aof</li><li>Redis集群(四)</li></ul><p>本章的项目目录结构如下，主要是在前一篇文章新增了aof相关文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">├─aof</span><br><span class="line">│  aof.go</span><br><span class="line">│</span><br><span class="line">├─config</span><br><span class="line">│</span><br><span class="line">├─database</span><br><span class="line">│</span><br><span class="line">├─datastruct</span><br><span class="line">│  └─dict</span><br><span class="line">│</span><br><span class="line">├─interface</span><br><span class="line">│  ├─database</span><br><span class="line">│  │</span><br><span class="line">│  ├─dict</span><br><span class="line">│  │</span><br><span class="line">│  ├─resp</span><br><span class="line">│  │</span><br><span class="line">│  └─tcp</span><br><span class="line">│</span><br><span class="line">├─lib</span><br><span class="line">│</span><br><span class="line">├─resp</span><br><span class="line">│  ├─connection</span><br><span class="line">│  │</span><br><span class="line">│  ├─handler</span><br><span class="line">│  │</span><br><span class="line">│  ├─parser</span><br><span class="line">│  │</span><br><span class="line">│  └─reply</span><br><span class="line">│</span><br><span class="line">├─tcp</span><br><span class="line">│ </span><br><span class="line">│ go.mod</span><br><span class="line">│ main.go</span><br><span class="line">│ redis.conf</span><br></pre></td></tr></table></figure><h2 id="命令记录与恢复"><a href="#命令记录与恢复" class="headerlink" title="命令记录与恢复"></a>命令记录与恢复</h2><p>需要实现一个<code>AofHandler</code>结构体，由它封装命令保存及数据恢复的相关方法，然后在初始化Database的时候将AofHandler进行注册。在文件<code>aof/aof.go</code>中的实现如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CmdLine is alias for [][]byte, represents a command line</span></span><br><span class="line"><span class="keyword">type</span> CmdLine = [][]<span class="type">byte</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> payload <span class="keyword">struct</span> &#123;</span><br><span class="line">    cmdLine CmdLine</span><br><span class="line">    dbIndex <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AofHandler receive msgs from channel and write to AOF file</span></span><br><span class="line"><span class="keyword">type</span> AofHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">    db          databaseface.Database</span><br><span class="line">    aofChan     <span class="keyword">chan</span> *payload</span><br><span class="line">    aofFile     *os.File</span><br><span class="line">    aofFilename <span class="type">string</span></span><br><span class="line">    currentDB   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外初始化<code>AofHandler</code>的时候还需要考虑根据已有的Aof文件进行恢复，以及启用一个协程不断的记录执行过的命令。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewAOFHandler creates a new aof.AofHandler</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAOFHandler</span><span class="params">(db databaseface.Database)</span></span> (*AofHandler, <span class="type">error</span>) &#123;</span><br><span class="line">    handler := &amp;AofHandler&#123;&#125;</span><br><span class="line">    handler.aofFilename = config.Properties.AppendFilename</span><br><span class="line">    handler.db = db</span><br><span class="line">    handler.LoadAof()</span><br><span class="line">    aofFile, err := os.OpenFile(handler.aofFilename, os.O_APPEND|os.O_CREATE|os.O_RDWR, <span class="number">0600</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    handler.aofFile = aofFile</span><br><span class="line">    handler.aofChan = <span class="built_in">make</span>(<span class="keyword">chan</span> *payload, aofQueueSize)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        handler.handleAof()</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> handler, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外还需实现下述方法：</p><ul><li><code>AddAof</code>：如果配置中开启Aof的话，将执行的命令发送到channel中</li><li><code>handleAof</code>：从channel中读取数据，并写入到文件当中</li><li><code>LoadAof</code>：从文件中读取命令，然后执行<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AddAof send command to aof goroutine through channel</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(handler *AofHandler)</span></span> AddAof(dbIndex <span class="type">int</span>, cmdLine CmdLine) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// handleAof listen aof channel and write into file</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(handler *AofHandler)</span></span> handleAof() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LoadAof read aof file</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(handler *AofHandler)</span></span> LoadAof() &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="底层指令集修改"><a href="#底层指令集修改" class="headerlink" title="底层指令集修改"></a>底层指令集修改</h2>首先修改<code>database/db.go</code>中的结构体DB，新增属性addAof，以便指令集中的方法能够调用到addAof，需要修改的地方如下，另外初始化该方法的工作将在后续完成。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DB stores data and execute user&#x27;s commands</span></span><br><span class="line"><span class="keyword">type</span> DB <span class="keyword">struct</span> &#123;</span><br><span class="line">    index  <span class="type">int</span></span><br><span class="line">    data   iDict.Dict <span class="comment">// key -&gt; DataEntity</span></span><br><span class="line">    addAof <span class="function"><span class="keyword">func</span><span class="params">(CmdLine)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// makeDB create DB instance</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeDB</span><span class="params">()</span></span> *DB &#123;</span><br><span class="line">    db := &amp;DB&#123;</span><br><span class="line">        data: dict.MakeSyncDict(),</span><br><span class="line">        addAof: <span class="function"><span class="keyword">func</span><span class="params">(line CmdLine)</span></span> &#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> db</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>在<code>database/string.go</code>中对应的需要记录该指令的方法中添加<code>Addof</code>：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// execSet sets string value and time to live to the given key</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execSet</span><span class="params">(db *DB, args [][]<span class="type">byte</span>)</span></span> resp.Reply &#123;</span><br><span class="line">    ...</span><br><span class="line">    db.addAof(utils.ToCmdLine2(<span class="string">&quot;set&quot;</span>, args...))</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// execSetNX sets string if not exists</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execSetNX</span><span class="params">(db *DB, args [][]<span class="type">byte</span>)</span></span> resp.Reply &#123;</span><br><span class="line">    ...</span><br><span class="line">    db.addAof(utils.ToCmdLine2(<span class="string">&quot;setnx&quot;</span>, args...))</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>注：同样的<code>database/keys.go</code>中的相关方法也许调用<code>Addof</code>方法。</p></blockquote></li></ul><h2 id="调用AofHandler"><a href="#调用AofHandler" class="headerlink" title="调用AofHandler"></a>调用AofHandler</h2><p>初始化database时将<code>AofHandler</code>注册到Database结构体中，然后把方法<code>Addof</code>赋值给DB结构体，这样上述指令集就能调用到该方法了。文件<code>database/databse.go</code>中需要修改的地方如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Database is a set of multiple database set</span></span><br><span class="line"><span class="keyword">type</span> Database <span class="keyword">struct</span> &#123;</span><br><span class="line">    dbSet      []*DB</span><br><span class="line">    aofHandler *aof.AofHandler <span class="comment">// handle aof persistence</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewDatabase creates a redis database,</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDatabase</span><span class="params">()</span></span> *Database &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> config.Properties.AppendOnly &#123;</span><br><span class="line">        aofHandler, err := aof.NewAOFHandler(mdb)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line">        mdb.aofHandler = aofHandler</span><br><span class="line">        <span class="keyword">for</span> _, db := <span class="keyword">range</span> mdb.dbSet &#123;</span><br><span class="line">            <span class="comment">// avoid closure</span></span><br><span class="line">            singleDB := db</span><br><span class="line">            singleDB.addAof = <span class="function"><span class="keyword">func</span><span class="params">(line CmdLine)</span></span> &#123;</span><br><span class="line">                mdb.aofHandler.AddAof(singleDB.index, line)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mdb</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：上述for循环遍历数据库的切片时，需要暂时把db赋值给一个临时变量，不然拿到的db都是最后一个值，这是go语言中循环变量的作用域导致的，需要注意。</p><ul><li>在go语言的for循环中，循环内部创建的函数变量都是共享同一内存地址，for循环总是使用同一块内存去接收循环中的变量的值。不管循环多少次，变量的内存地址都是相同的。</li><li>此处使用的解决方法就是用一个临时变量进行赋值保存记录。</li></ul></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>redis支持两种持久化的方式，一种是aof，它对数据有修改的相关指令记录到文件中，重新执行这些命令达到数据恢复的效果。另一种是rdb，这种方式是记录了内存快照，在指定的时间间隔内，将内存中的数据写入到磁盘中，就是在指定目录下生产一个dump.rdb文件，通过加载该文件进行恢复数据。本文基于go语言实现了aof持久化功能，通过可插拔的方式集成到之前已基本实现的单体redis当中。接下来将实现redis的集群模式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;本系列文章记录如何基于go语言实现Redis，从整体设计到具体细节实现，不仅可以有效的锻炼自己的编码能力，又能加深对redis的认识。文章主</summary>
      
    
    
    
    <category term="go" scheme="https://zcej.github.io/categories/go/"/>
    
    <category term="项目实战" scheme="https://zcej.github.io/categories/go/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    
    
  </entry>
  
  <entry>
    <title>项目实战：go语言实现redis(二)</title>
    <link href="https://zcej.github.io/2022/05/12/go/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%EF%BC%9Ago%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0redis(%E4%BA%8C)/"/>
    <id>https://zcej.github.io/2022/05/12/go/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%EF%BC%9Ago%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0redis(%E4%BA%8C)/</id>
    <published>2022-05-12T15:06:31.000Z</published>
    <updated>2022-06-28T15:56:20.131Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>本系列文章记录如何基于go语言实现Redis，从整体设计到具体细节实现，不仅可以有效的锻炼自己的编码能力，又能加深对redis的认识。文章主要从整体设计思路入手，记录关键的设计步骤，详细的实现可以参考<a href="https://github.com/zcej/go-redis">github</a>上的相关代码。主体上有下面几个部分：</p><ul><li>TCP服务器(一)：支持同时监听多个TCP连接，并进行相关处理</li><li>Redis协议解析器(一)：实现相关Handler，命令解析及响应处理</li><li>**内存数据库(二)**：实现数据库，注册相关命令，完成支持对数据库的增删改查</li><li>Redis持久化(三)</li><li>Redis集群(四)</li></ul><p>本章的项目目录结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">├─config</span><br><span class="line">│</span><br><span class="line">├─database</span><br><span class="line">│  command.go</span><br><span class="line">│  database.go</span><br><span class="line">│  db.go</span><br><span class="line">│  echo_database.go</span><br><span class="line">│  keys.go</span><br><span class="line">│  ping.go</span><br><span class="line">│  string.go</span><br><span class="line">│</span><br><span class="line">├─datastruct</span><br><span class="line">│  └─dict</span><br><span class="line">│     simple_dict.go</span><br><span class="line">│     sync_dict.go</span><br><span class="line">│</span><br><span class="line">├─interface</span><br><span class="line">│  ├─database</span><br><span class="line">│  │</span><br><span class="line">│  ├─dict</span><br><span class="line">│  │  dict.go</span><br><span class="line">│  │</span><br><span class="line">│  ├─resp</span><br><span class="line">│  │</span><br><span class="line">│  └─tcp</span><br><span class="line">│</span><br><span class="line">├─lib</span><br><span class="line">│</span><br><span class="line">├─resp</span><br><span class="line">│  ├─connection</span><br><span class="line">│  │</span><br><span class="line">│  ├─handler</span><br><span class="line">│  │</span><br><span class="line">│  ├─parser</span><br><span class="line">│  │</span><br><span class="line">│  └─reply</span><br><span class="line">│</span><br><span class="line">├─tcp</span><br><span class="line">│ </span><br><span class="line">│ go.mod</span><br><span class="line">│ main.go</span><br><span class="line">│ redis.conf</span><br></pre></td></tr></table></figure><h2 id="数据底层存储"><a href="#数据底层存储" class="headerlink" title="数据底层存储"></a>数据底层存储</h2><h3 id="定义及实现Dict接口"><a href="#定义及实现Dict接口" class="headerlink" title="定义及实现Dict接口"></a>定义及实现Dict接口</h3><p>在<code>interface/dict/dict.go</code>中定义Dict接口，包含下述方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Consumer is used to traversal dict, if it returns false the traversal will be break</span></span><br><span class="line"><span class="keyword">type</span> Consumer <span class="function"><span class="keyword">func</span><span class="params">(key <span class="type">string</span>, val <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Dict is interface of a key-value data structure</span></span><br><span class="line"><span class="keyword">type</span> Dict <span class="keyword">interface</span> &#123;</span><br><span class="line">    Get(key <span class="type">string</span>) (val <span class="keyword">interface</span>&#123;&#125;, exists <span class="type">bool</span>)</span><br><span class="line">    Len() <span class="type">int</span></span><br><span class="line">    Put(key <span class="type">string</span>, val <span class="keyword">interface</span>&#123;&#125;) (result <span class="type">int</span>)</span><br><span class="line">    PutIfAbsent(key <span class="type">string</span>, val <span class="keyword">interface</span>&#123;&#125;) (result <span class="type">int</span>)</span><br><span class="line">    PutIfExists(key <span class="type">string</span>, val <span class="keyword">interface</span>&#123;&#125;) (result <span class="type">int</span>)</span><br><span class="line">    Remove(key <span class="type">string</span>) (result <span class="type">int</span>)</span><br><span class="line">    ForEach(consumer Consumer)</span><br><span class="line">    Keys() []<span class="type">string</span></span><br><span class="line">    RandomKeys(limit <span class="type">int</span>) []<span class="type">string</span></span><br><span class="line">    RandomDistinctKeys(limit <span class="type">int</span>) []<span class="type">string</span></span><br><span class="line">    Clear()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在<code>datastruct/dict/sync_dict.go</code>中实现一个并发安全的dict。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SyncDict wraps a map, it is not thread safe</span></span><br><span class="line"><span class="keyword">type</span> SyncDict <span class="keyword">struct</span> &#123;</span><br><span class="line">    m sync.Map</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MakeSyncDict makes a new map</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeSyncDict</span><span class="params">()</span></span> *SyncDict &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;SyncDict&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get returns the binding value and whether the key is exist</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dict *SyncDict)</span></span> Get(key <span class="type">string</span>) (val <span class="keyword">interface</span>&#123;&#125;, exists <span class="type">bool</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Len returns the number of dict</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dict *SyncDict)</span></span> Len() <span class="type">int</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Put puts key value into dict and returns the number of new inserted key-value</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dict *SyncDict)</span></span> Put(key <span class="type">string</span>, val <span class="keyword">interface</span>&#123;&#125;) (result <span class="type">int</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PutIfAbsent puts value if the key is not exists and returns the number of updated key-value</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dict *SyncDict)</span></span> PutIfAbsent(key <span class="type">string</span>, val <span class="keyword">interface</span>&#123;&#125;) (result <span class="type">int</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PutIfExists puts value if the key is exist and returns the number of inserted key-value</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dict *SyncDict)</span></span> PutIfExists(key <span class="type">string</span>, val <span class="keyword">interface</span>&#123;&#125;) (result <span class="type">int</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove removes the key and return the number of deleted key-value</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dict *SyncDict)</span></span> Remove(key <span class="type">string</span>) (result <span class="type">int</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Keys returns all keys in dict</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dict *SyncDict)</span></span> Keys() []<span class="type">string</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ForEach traversal the dict</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dict *SyncDict)</span></span> ForEach(consumer iDict.Consumer) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RandomKeys randomly returns keys of the given number, may contain duplicated key</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dict *SyncDict)</span></span> RandomKeys(limit <span class="type">int</span>) []<span class="type">string</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RandomDistinctKeys randomly returns keys of the given number, won&#x27;t contain duplicated key</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dict *SyncDict)</span></span> RandomDistinctKeys(limit <span class="type">int</span>) []<span class="type">string</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clear removes all keys in dict</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dict *SyncDict)</span></span> Clear() &#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：非并发安全的实现可参考<code>datastruct/dict/simple_dict.go</code></p></blockquote><h3 id="定义DB结构体"><a href="#定义DB结构体" class="headerlink" title="定义DB结构体"></a>定义DB结构体</h3><p>在<code>database/db.go</code>定义DB结构体，它是对底层<code>Dict</code>相关操作的进一步封装，根据接收到的实际命令找到对应的方法并执行，其核心是<code>Exec</code>方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DB stores data and execute user&#x27;s commands</span></span><br><span class="line"><span class="keyword">type</span> DB <span class="keyword">struct</span> &#123;</span><br><span class="line">    index <span class="type">int</span></span><br><span class="line">    data  dict.Dict <span class="comment">// key -&gt; DataEntity</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// makeDB create DB instance</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeDB</span><span class="params">()</span></span> *DB &#123;</span><br><span class="line">    db := &amp;DB&#123;data: dict.MakeSyncDict()&#125;</span><br><span class="line">    <span class="keyword">return</span> db</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Exec executes command within one database</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Exec(c resp.Connection, cmdLine [][]<span class="type">byte</span>) resp.Reply &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetEntity returns DataEntity bind to given key</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> GetEntity(key <span class="type">string</span>) (*database.DataEntity, <span class="type">bool</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PutEntity a DataEntity into DB</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> PutEntity(key <span class="type">string</span>, entity *database.DataEntity) <span class="type">int</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PutIfExists edit an existing DataEntity</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> PutIfExists(key <span class="type">string</span>, entity *database.DataEntity) <span class="type">int</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove the given key from db</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Remove(key <span class="type">string</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Removes the given keys from db</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Removes(keys ...<span class="type">string</span>) (deleted <span class="type">int</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Flush clean database</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Flush() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validateArity</span><span class="params">(arity <span class="type">int</span>, cmdArgs [][]<span class="type">byte</span>)</span></span> <span class="type">bool</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="命令注册及实现"><a href="#命令注册及实现" class="headerlink" title="命令注册及实现"></a>命令注册及实现</h2><h3 id="命令的注册"><a href="#命令的注册" class="headerlink" title="命令的注册"></a>命令的注册</h3><p><code>database/command.go</code>主要包含以下三个部分：</p><ul><li><code>cmdTable</code>：类型为字典，功能为存储命令及对应命令的结构体</li><li><code>command</code>：类型为结构体，包含命令对应的实际方法以及参数数量</li><li><code>RegisterCommand</code>：类型为一个函数，用于实现命令注册全局表中<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cmdTable = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*command)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> command <span class="keyword">struct</span> &#123;</span><br><span class="line">    executor ExecFunc</span><br><span class="line">    arity    <span class="type">int</span> <span class="comment">// allow number of args, arity &lt; 0 means len(args) &gt;= -arity</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RegisterCommand registers a new command</span></span><br><span class="line"><span class="comment">// arity means allowed number of cmdArgs, arity &lt; 0 means len(args) &gt;= -arity.</span></span><br><span class="line"><span class="comment">// for example: the arity of `get` is 2, `mget` is -2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterCommand</span><span class="params">(name <span class="type">string</span>, executor ExecFunc, arity <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    name = strings.ToLower(name)</span><br><span class="line">    cmdTable[name] = &amp;command&#123;</span><br><span class="line">        executor: executor,</span><br><span class="line">        arity:    arity,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="命令的实现"><a href="#命令的实现" class="headerlink" title="命令的实现"></a>命令的实现</h3><h4 id="ping的实现与注册"><a href="#ping的实现与注册" class="headerlink" title="ping的实现与注册"></a>ping的实现与注册</h4>在文件<code>database/ping.go</code>中的<code>init()</code>方法下将命令及其对应的处理函数注册到全局表中：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    RegisterCommand(<span class="string">&quot;ping&quot;</span>, Ping, <span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ping the server</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Ping</span><span class="params">(db *DB, args [][]<span class="type">byte</span>)</span></span> resp.Reply &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="keys指令集的实现与注册"><a href="#keys指令集的实现与注册" class="headerlink" title="keys指令集的实现与注册"></a>keys指令集的实现与注册</h4>在文件<code>database/keys.go</code>中的<code>init()</code>方法下将命令及其对应的处理函数注册到全局表中：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    RegisterCommand(<span class="string">&quot;Del&quot;</span>, execDel, <span class="number">-2</span>)</span><br><span class="line">    RegisterCommand(<span class="string">&quot;Exists&quot;</span>, execExists, <span class="number">-2</span>)</span><br><span class="line">    RegisterCommand(<span class="string">&quot;Keys&quot;</span>, execKeys, <span class="number">2</span>)</span><br><span class="line">    RegisterCommand(<span class="string">&quot;FlushDB&quot;</span>, execFlushDB, <span class="number">-1</span>)</span><br><span class="line">    RegisterCommand(<span class="string">&quot;Type&quot;</span>, execType, <span class="number">2</span>)</span><br><span class="line">    RegisterCommand(<span class="string">&quot;Rename&quot;</span>, execRename, <span class="number">3</span>)</span><br><span class="line">    RegisterCommand(<span class="string">&quot;RenameNx&quot;</span>, execRenameNx, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>并实现相关函数：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// execDel removes a key from db</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execDel</span><span class="params">(db *DB, args [][]<span class="type">byte</span>)</span></span> resp.Reply &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// execExists checks if a is existed in db</span></span><br><span class="line"><span class="function"><span class="keyword">func</span>  <span class="title">execExists</span><span class="params">(db *DB, args [][]<span class="type">byte</span>)</span></span> resp.Reply &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// execFlushDB removes all data in current db</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execFlushDB</span><span class="params">(db *DB, args [][]<span class="type">byte</span>)</span></span> resp.Reply &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// execType returns the type of entity, including: string, list, hash, set and zset</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execType</span><span class="params">(db *DB, args [][]<span class="type">byte</span>)</span></span> resp.Reply &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// execRename a key</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execRename</span><span class="params">(db *DB, args [][]<span class="type">byte</span>)</span></span> resp.Reply &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// execRenameNx a key, only if the new key does not exist</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execRenameNx</span><span class="params">(db *DB, args [][]<span class="type">byte</span>)</span></span> resp.Reply &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// execKeys returns all keys matching the given pattern</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execKeys</span><span class="params">(db *DB, args [][]<span class="type">byte</span>)</span></span> resp.Reply &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="string指令集的实现与注册"><a href="#string指令集的实现与注册" class="headerlink" title="string指令集的实现与注册"></a>string指令集的实现与注册</h4>在文件<code>database/string.go</code>中的<code>init()</code>方法下将命令及其对应的处理函数注册到全局表中：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    RegisterCommand(<span class="string">&quot;Get&quot;</span>, execGet, <span class="number">2</span>)</span><br><span class="line">    RegisterCommand(<span class="string">&quot;Set&quot;</span>, execSet, <span class="number">-3</span>)</span><br><span class="line">    RegisterCommand(<span class="string">&quot;SetNx&quot;</span>, execSetNX, <span class="number">3</span>)</span><br><span class="line">    RegisterCommand(<span class="string">&quot;GetSet&quot;</span>, execGetSet, <span class="number">3</span>)</span><br><span class="line">    RegisterCommand(<span class="string">&quot;StrLen&quot;</span>, execStrLen, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>并实现相关函数：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> getAsString(key <span class="type">string</span>) ([]<span class="type">byte</span>, reply.ErrorReply) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// execGet returns string value bound to the given key</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execGet</span><span class="params">(db *DB, args [][]<span class="type">byte</span>)</span></span> resp.Reply &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// execSet sets string value and time to live to the given key</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execSet</span><span class="params">(db *DB, args [][]<span class="type">byte</span>)</span></span> resp.Reply &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// execSetNX sets string if not exists</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execSetNX</span><span class="params">(db *DB, args [][]<span class="type">byte</span>)</span></span> resp.Reply &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// execGetSet sets value of a string-type key and returns its old value</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execGetSet</span><span class="params">(db *DB, args [][]<span class="type">byte</span>)</span></span> resp.Reply &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// execStrLen returns len of string value bound to the given key</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execStrLen</span><span class="params">(db *DB, args [][]<span class="type">byte</span>)</span></span> resp.Reply &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="实现数据库核心"><a href="#实现数据库核心" class="headerlink" title="实现数据库核心"></a>实现数据库核心</h2>在<code>database/database.go</code>中定义结构体Database，需实现第一篇文章中定义的Database接口，并进行初始化，创建16个数据库表，另外还需要注意执行命令时所在db的选择，这里封装了一个选择db的函数<code>execSelect</code>。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Database is a set of multiple database set</span></span><br><span class="line"><span class="keyword">type</span> Database <span class="keyword">struct</span> &#123;</span><br><span class="line">    dbSet []*DB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewDatabase creates a redis database,</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDatabase</span><span class="params">()</span></span> *Database &#123;</span><br><span class="line">    mdb := &amp;Database&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> config.Properties.Databases == <span class="number">0</span> &#123;</span><br><span class="line">        config.Properties.Databases = <span class="number">16</span></span><br><span class="line">    &#125;</span><br><span class="line">    mdb.dbSet = <span class="built_in">make</span>([]*DB, config.Properties.Databases)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> mdb.dbSet &#123;</span><br><span class="line">        singleDB := makeDB()</span><br><span class="line">        singleDB.index = i</span><br><span class="line">        mdb.dbSet[i] = singleDB</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mdb</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Exec executes command</span></span><br><span class="line"><span class="comment">// parameter `cmdLine` contains command and its arguments, for example: &quot;set key value&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mdb *Database)</span></span> Exec(c resp.Connection, cmdLine [][]<span class="type">byte</span>) (result resp.Reply) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close graceful shutdown database</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mdb *Database)</span></span> Close() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mdb *Database)</span></span> AfterClientClose(c resp.Connection) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execSelect</span><span class="params">(c resp.Connection, mdb *Database, args [][]<span class="type">byte</span>)</span></span> resp.Reply &#123;&#125;</span><br></pre></td></tr></table></figure>然后将<code>resp/handler/handler.go</code>中的初始化数据库改为上述实现的数据库即可。<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>到目前为止一个单体的redis应用已基本完成，可以暂不关注每个方法的具体实现，但是一定要理解整个调用逻辑，做到融会贯通。首先处理TCP连接，选择对应的handler，由handler初始化database，同时对conn封装，选择对应的数据库执行命令，在项目一开始运行的时候会将代码中已实现的命令注册到全局表中。接下来将实现redis的持久化与集群的相关功能。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;本系列文章记录如何基于go语言实现Redis，从整体设计到具体细节实现，不仅可以有效的锻炼自己的编码能力，又能加深对redis的认识。文章主</summary>
      
    
    
    
    <category term="go" scheme="https://zcej.github.io/categories/go/"/>
    
    <category term="项目实战" scheme="https://zcej.github.io/categories/go/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    
    
  </entry>
  
  <entry>
    <title>项目实战：go语言实现redis(一)</title>
    <link href="https://zcej.github.io/2022/05/08/go/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%EF%BC%9Ago%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0redis(%E4%B8%80)/"/>
    <id>https://zcej.github.io/2022/05/08/go/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%EF%BC%9Ago%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0redis(%E4%B8%80)/</id>
    <published>2022-05-08T14:41:18.000Z</published>
    <updated>2022-06-28T16:06:11.479Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>本系列文章记录如何基于go语言实现Redis，从整体设计到具体细节实现，不仅可以有效的锻炼自己的编码能力，又能加深对redis的认识。文章主要从整体设计思路入手，记录关键的设计步骤，详细的实现可以参考<a href="https://github.com/zcej/go-redis">github</a>上的相关代码。主体上有下面几个部分：</p><ul><li><p>**TCP服务器(一)**：支持同时监听多个TCP连接，并进行相关处理</p></li><li><p>**Redis协议解析器(一)**：实现相关Handler，命令解析及响应处理</p></li><li><p>内存数据库(二)</p></li><li><p>Redis持久化(三)</p></li><li><p>Redis集群(四)</p><h2 id="实现TCP服务器"><a href="#实现TCP服务器" class="headerlink" title="实现TCP服务器"></a>实现TCP服务器</h2><p>项目初始化，主要包括相关配置，日志处理，以及定义相关接口或结构体。当前目录结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">├─config</span><br><span class="line">│  config.go</span><br><span class="line">│</span><br><span class="line">├─interface</span><br><span class="line">│  └─tcp</span><br><span class="line">│     handler.go</span><br><span class="line">│</span><br><span class="line">├─lib</span><br><span class="line">│</span><br><span class="line">├─tcp</span><br><span class="line">│   echo.go</span><br><span class="line">│   server.go</span><br><span class="line">│ </span><br><span class="line">| go.mod</span><br><span class="line">| main.go</span><br><span class="line">| redis.conf</span><br></pre></td></tr></table></figure><h3 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h3><h4 id="配置文件解析"><a href="#配置文件解析" class="headerlink" title="配置文件解析"></a>配置文件解析</h4><p>在<code>config/config.go</code>文件中定义Redis相关服务端属性如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> config</span><br><span class="line"></span><br><span class="line"><span class="comment">// ServerProperties defines global config properties</span></span><br><span class="line"><span class="keyword">type</span> ServerProperties <span class="keyword">struct</span> &#123;</span><br><span class="line">    Bind           <span class="type">string</span>   <span class="string">`cfg:&quot;bind&quot;`</span></span><br><span class="line">    Port           <span class="type">int</span>      <span class="string">`cfg:&quot;port&quot;`</span></span><br><span class="line">    AppendOnly     <span class="type">bool</span>     <span class="string">`cfg:&quot;appendOnly&quot;`</span></span><br><span class="line">    AppendFilename <span class="type">string</span>   <span class="string">`cfg:&quot;appendFilename&quot;`</span></span><br><span class="line">    MaxClients     <span class="type">int</span>      <span class="string">`cfg:&quot;maxclients&quot;`</span></span><br><span class="line">    RequirePass    <span class="type">string</span>   <span class="string">`cfg:&quot;requirepass&quot;`</span></span><br><span class="line">    Databases      <span class="type">int</span>      <span class="string">`cfg:&quot;databases&quot;`</span></span><br><span class="line"></span><br><span class="line">    Peers          []<span class="type">string</span> <span class="string">`cfg:&quot;peers&quot;`</span></span><br><span class="line">    Self           <span class="type">string</span>   <span class="string">`cfg:&quot;self&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Properties holds global config properties</span></span><br><span class="line"><span class="keyword">var</span> Properties *ServerProperties</span><br></pre></td></tr></table></figure><p>另外，还需要实现配置文件解析的相关方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SetupConfig read config file and store properties into Properties</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetupConfig</span><span class="params">(configFilename <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    file, err := os.Open(configFilename)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    Properties = parse(file)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parse</span><span class="params">(src io.Reader)</span></span> *ServerProperties &#123;</span><br><span class="line">    config := &amp;ServerProperties&#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了防止没有配置文件的情况下也能正常初始化，可以添加如下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// default config</span></span><br><span class="line">    Properties = &amp;ServerProperties&#123;</span><br><span class="line">        Bind:       <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">        Port:       <span class="number">6379</span>,</span><br><span class="line">        AppendOnly: <span class="literal">false</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h4><p>在<code>interface/tcp/handler.go</code>中需要定义相关接口，以规范化处理tcp的连接：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handler represents application server over tcp</span></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">    Handle(ctx context.Context, conn net.Conn)</span><br><span class="line">    Close() <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TCP服务实现"><a href="#TCP服务实现" class="headerlink" title="TCP服务实现"></a>TCP服务实现</h3><h4 id="并发处理tcp连接"><a href="#并发处理tcp连接" class="headerlink" title="并发处理tcp连接"></a>并发处理tcp连接</h4><p>在<code>tcp/server.go</code>中实现以下两个函数，用于处理tcp连接，此处主要依赖标准库<code>net</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Config stores tcp handler properties</span></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">    Address    <span class="type">string</span>        <span class="string">`yaml:&quot;address&quot;`</span></span><br><span class="line">    MaxConnect <span class="type">uint32</span>        <span class="string">`yaml:&quot;max-connect&quot;`</span></span><br><span class="line">    Timeout    time.Duration <span class="string">`yaml:&quot;timeout&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ListenAndServeWithSignal binds port and handle requests, blocking until receive stop signal</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServeWithSignal</span><span class="params">(cfg *Config, handler tcp.Handler)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    closeChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    ...</span><br><span class="line">    listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, cfg.Address)</span><br><span class="line">    ...</span><br><span class="line">    ListenAndServe(listener, handler, closeChan)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ListenAndServe binds port and handle requests, blocking until close</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(listener net.Listener, handler tcp.Handler, closeChan &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        &lt;-closeChan</span><br><span class="line">        listener.Close()</span><br><span class="line">        handler.Close()</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        conn, err := listener.Accept()</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            handler.Handle(ctx, conn)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="main函数入口实现"><a href="#main函数入口实现" class="headerlink" title="main函数入口实现"></a>main函数入口实现</h4><p>此时<code>main.go</code>中需要调用的函数已基本实现，后续修改只需传入对应的Handler即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;go-redis/config&quot;</span></span><br><span class="line">    <span class="string">&quot;go-redis/lib/logger&quot;</span></span><br><span class="line">    <span class="string">&quot;go-redis/tcp&quot;</span></span><br><span class="line">    EchoHandler <span class="string">&quot;go-redis/tcp&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> configFile <span class="type">string</span> = <span class="string">&quot;redis.conf&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> defaultProperties = &amp;config.ServerProperties&#123;</span><br><span class="line">    Bind: <span class="string">&quot;0.0.0.0&quot;</span>,</span><br><span class="line">    Port: <span class="number">6379</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fileExists</span><span class="params">(filename <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    info, err := os.Stat(filename)</span><br><span class="line">    <span class="keyword">return</span> err == <span class="literal">nil</span> &amp;&amp; !info.IsDir()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    logger.Setup(&amp;logger.Settings&#123;</span><br><span class="line">        Path:       <span class="string">&quot;logs&quot;</span>,</span><br><span class="line">        Name:       <span class="string">&quot;godis&quot;</span>,</span><br><span class="line">        Ext:        <span class="string">&quot;log&quot;</span>,</span><br><span class="line">        TimeFormat: <span class="string">&quot;2006-01-02&quot;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> fileExists(configFile) &#123;</span><br><span class="line">        config.SetupConfig(configFile)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        config.Properties = defaultProperties</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err := tcp.ListenAndServeWithSignal(</span><br><span class="line">        &amp;tcp.Config&#123;</span><br><span class="line">            Address: fmt.Sprintf(<span class="string">&quot;%s:%d&quot;</span>,</span><br><span class="line">                config.Properties.Bind,</span><br><span class="line">                config.Properties.Port),</span><br><span class="line">        &#125;,</span><br><span class="line">        EchoHandler.MakeHandler())</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        logger.Error(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="echoHandler示例"><a href="#echoHandler示例" class="headerlink" title="echoHandler示例"></a>echoHandler示例</h4><p>新建文件<code>tcp/echo.go</code>，定义结构体<code>EchoHandler</code>与<code>EchoClient</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EchoHandler echos received line to client, using for test</span></span><br><span class="line"><span class="keyword">type</span> EchoHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">    activeConn sync.Map</span><br><span class="line">    closing    atomic.Boolean</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MakeHandler creates EchoHandler</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeHandler</span><span class="params">()</span></span> *EchoHandler &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;EchoHandler&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EchoClient is client for EchoHandler, using for test</span></span><br><span class="line"><span class="keyword">type</span> EchoClient <span class="keyword">struct</span> &#123;</span><br><span class="line">    Conn    net.Conn</span><br><span class="line">    Waiting wait.Wait</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close close connection</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *EchoClient)</span></span> Close() <span class="type">error</span> &#123;</span><br><span class="line">    c.Waiting.WaitWithTimeout(<span class="number">10</span> * time.Second)</span><br><span class="line">    c.Conn.Close()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>EchoHandler</code>实现了接口<code>Handler</code>，主要是将接收到的数据原样返回，详情如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle echos received line to client</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *EchoHandler)</span></span> Handle(ctx context.Context, conn net.Conn) &#123;</span><br><span class="line">    ...</span><br><span class="line">    reader := bufio.NewReader(conn)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// may occurs: client EOF, client timeout, server early close</span></span><br><span class="line">        msg, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        ....</span><br><span class="line">        b := []<span class="type">byte</span>(msg)</span><br><span class="line">        _, _ = conn.Write(b)</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close stops echo handler</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *EchoHandler)</span></span> Close() <span class="type">error</span> &#123;</span><br><span class="line">    h.closing.Set(<span class="literal">true</span>)</span><br><span class="line">    h.activeConn.Range(<span class="function"><span class="keyword">func</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;, val <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        client := key.(*EchoClient)</span><br><span class="line">        _ = client.Close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现Redis协议解析器"><a href="#实现Redis协议解析器" class="headerlink" title="实现Redis协议解析器"></a>实现Redis协议解析器</h2><p>本章节主要新增了redis相关命令的解析，具体执行，以及响应处理等，相关目录结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">├─config</span><br><span class="line">│  config.go</span><br><span class="line">│</span><br><span class="line">├─database</span><br><span class="line">│  echo_database.go</span><br><span class="line">│</span><br><span class="line">├─interface</span><br><span class="line">│  ├─database</span><br><span class="line">│  │  database.go</span><br><span class="line">│  │</span><br><span class="line">│  ├─resp</span><br><span class="line">│  │  conn.go</span><br><span class="line">│  │  reply.go</span><br><span class="line">│  │</span><br><span class="line">│  └─tcp</span><br><span class="line">│     handler.go</span><br><span class="line">│</span><br><span class="line">├─lib</span><br><span class="line">│</span><br><span class="line">├─resp</span><br><span class="line">│  ├─connection</span><br><span class="line">│  │  conn.go</span><br><span class="line">│  │</span><br><span class="line">│  ├─handler</span><br><span class="line">│  │  handler.go</span><br><span class="line">│  │</span><br><span class="line">│  ├─parser</span><br><span class="line">│  │      parser.go</span><br><span class="line">│  │</span><br><span class="line">│  └─reply</span><br><span class="line">│     consts.go</span><br><span class="line">│     errors.go</span><br><span class="line">│     reply.go</span><br><span class="line">│</span><br><span class="line">└─tcp</span><br><span class="line">│   echo.go</span><br><span class="line">│   server.go</span><br><span class="line">│ </span><br><span class="line">| go.mod</span><br><span class="line">| main.go</span><br><span class="line">| redis.conf</span><br></pre></td></tr></table></figure><h3 id="redis网络协议认识"><a href="#redis网络协议认识" class="headerlink" title="redis网络协议认识"></a>redis网络协议认识</h3></li><li><p>正常回复：以”+”开头，以”\r\n”结尾的字符串形式</p></li><li><p>错误回复：以”-“开头，以”\r\n”结尾的字符串形式</p></li><li><p>整数：以”:”开头，以”\r\n”结尾的字符串形式</p></li><li><p>多行字符串：以”$”开头，后面跟实际发送的字节数，以”\r\n”结尾</p></li><li><p>数组：以”*”开头，后面跟成员个数</p><h3 id="接口定义及实现"><a href="#接口定义及实现" class="headerlink" title="接口定义及实现"></a>接口定义及实现</h3><h4 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h4><p>在<code>interface/resp/conn.go</code>中定义连接，主要包含三个方法，写数据、获取当前所在数据库的索引，以及选择数据库：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Connection represents a connection with redis client</span></span><br><span class="line"><span class="keyword">type</span> Connection <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write([]<span class="type">byte</span>) <span class="type">error</span></span><br><span class="line">    GetDBIndex() <span class="type">int</span> <span class="comment">// used for multi database</span></span><br><span class="line">    SelectDB(<span class="type">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>resp/connection/conn.go</code>中创建Connection结构体并实现Connection接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Connection represents a connection with a redis-cli</span></span><br><span class="line"><span class="keyword">type</span> Connection <span class="keyword">struct</span> &#123;</span><br><span class="line">    conn         net.Conn</span><br><span class="line">    waitingReply wait.Wait  <span class="comment">// waiting until reply finished</span></span><br><span class="line">    mu           sync.Mutex <span class="comment">// lock while handler sending response</span></span><br><span class="line">    selectedDB   <span class="type">int</span>        <span class="comment">// selected db</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewConn</span><span class="params">(conn net.Conn)</span></span> *Connection &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Connection&#123;conn: conn,&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RemoteAddr returns the remote network address</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Connection)</span></span> RemoteAddr() net.Addr &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close disconnect with the client</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Connection)</span></span> Close() <span class="type">error</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write sends response to client over tcp connection</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Connection)</span></span> Write(b []<span class="type">byte</span>) <span class="type">error</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetDBIndex returns selected db</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Connection)</span></span> GetDBIndex() <span class="type">int</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SelectDB selects a database</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Connection)</span></span> SelectDB(dbNum <span class="type">int</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="Reply"><a href="#Reply" class="headerlink" title="Reply"></a>Reply</h4><p>在<code>interface/resp/reply.go</code>中定义接口Reply，用于处理基于resp协议的响应，主要包含<code>ToBytes</code>方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reply is the interface of redis serialization protocol message</span></span><br><span class="line"><span class="keyword">type</span> Reply <span class="keyword">interface</span> &#123;</span><br><span class="line">    ToBytes() []<span class="type">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ErrorReply is an error and redis.Reply</span></span><br><span class="line"><span class="keyword">type</span> ErrorReply <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="type">string</span></span><br><span class="line">    ToBytes() []<span class="type">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>resp/reply</code>下创建以下三个文件，分别用于实现具体的相关处理：</p></li><li><p><code>consts.go</code>：定义一些固定不变的响应</p></li><li><p><code>reply.go</code>：定义正常执行命令时的响应</p></li><li><p><code>errors.go</code>：定义发生错误时的响应</p></li></ul><p><code>consts.go</code>中的文件内容如下，其中的结构体都需要实现Reply接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PongReply is +PONG</span></span><br><span class="line"><span class="keyword">type</span> PongReply <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OkReply is +OK</span></span><br><span class="line"><span class="keyword">type</span> OkReply <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NullBulkReply is empty string</span></span><br><span class="line"><span class="keyword">type</span> NullBulkReply <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EmptyMultiBulkReply is a empty list</span></span><br><span class="line"><span class="keyword">type</span> EmptyMultiBulkReply <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NoReply respond nothing, for commands like subscribe</span></span><br><span class="line"><span class="keyword">type</span> NoReply <span class="keyword">struct</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><code>reply.go</code>中的文件内容如下，其中的结构体都需要实现Reply接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BulkReply stores a binary-safe string</span></span><br><span class="line"><span class="keyword">type</span> BulkReply <span class="keyword">struct</span> &#123;</span><br><span class="line">    Arg []<span class="type">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MultiBulkReply stores a list of string</span></span><br><span class="line"><span class="keyword">type</span> MultiBulkReply <span class="keyword">struct</span> &#123;</span><br><span class="line">    Args [][]<span class="type">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// StatusReply stores a simple status string</span></span><br><span class="line"><span class="keyword">type</span> StatusReply <span class="keyword">struct</span> &#123;</span><br><span class="line">    Status <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IntReply stores an int64 number</span></span><br><span class="line"><span class="keyword">type</span> IntReply <span class="keyword">struct</span> &#123;</span><br><span class="line">    Code <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// StandardErrReply represents handler error</span></span><br><span class="line"><span class="keyword">type</span> StandardErrReply <span class="keyword">struct</span> &#123;</span><br><span class="line">    Status <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>errors.go</code>中的文件内容如下，其中的结构体都需要实现Reply接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UnknownErrReply represents UnknownErr</span></span><br><span class="line"><span class="keyword">type</span> UnknownErrReply <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ArgNumErrReply represents wrong number of arguments for command</span></span><br><span class="line"><span class="keyword">type</span> ArgNumErrReply <span class="keyword">struct</span> &#123;</span><br><span class="line">    Cmd <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SyntaxErrReply represents meeting unexpected arguments</span></span><br><span class="line"><span class="keyword">type</span> SyntaxErrReply <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WrongTypeErrReply represents operation against a key holding the wrong kind of value</span></span><br><span class="line"><span class="keyword">type</span> WrongTypeErrReply <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ProtocolErrReply represents meeting unexpected byte during parse requests</span></span><br><span class="line"><span class="keyword">type</span> ProtocolErrReply <span class="keyword">struct</span> &#123;</span><br><span class="line">    Msg <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Database"><a href="#Database" class="headerlink" title="Database"></a>Database</h4><p>在<code>interface/database/database.go</code>定义接口Database，规范不同的数据库实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Database is the interface for redis style storage engine</span></span><br><span class="line"><span class="keyword">type</span> Database <span class="keyword">interface</span> &#123;</span><br><span class="line">    Exec(client resp.Connection, args [][]<span class="type">byte</span>) resp.Reply</span><br><span class="line">    AfterClientClose(c resp.Connection)</span><br><span class="line">    Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="命令解析实现"><a href="#命令解析实现" class="headerlink" title="命令解析实现"></a>命令解析实现</h3><p>在文件<code>resp/parser/parser.go</code>实现下面的功能：</p><h4 id="响应流式处理"><a href="#响应流式处理" class="headerlink" title="响应流式处理"></a>响应流式处理</h4><ul><li><p><code>Payload</code>：包含正常响应或错误</p></li><li><p><code>readState</code>：解析器状态</p></li><li><p><code>ParseStream</code>：返回数据类型为<code>Payload</code>的channel</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Payload stores redis.Reply or error</span></span><br><span class="line"><span class="keyword">type</span> Payload <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data resp.Reply</span><br><span class="line">    Err  <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> readState <span class="keyword">struct</span> &#123;</span><br><span class="line">    readingMultiLine  <span class="type">bool</span></span><br><span class="line">    expectedArgsCount <span class="type">int</span></span><br><span class="line">    msgType           <span class="type">byte</span></span><br><span class="line">    args              [][]<span class="type">byte</span></span><br><span class="line">    bulkLen           <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *readState)</span></span> finished() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.expectedArgsCount &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(s.args) == s.expectedArgsCount</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ParseStream reads data from io.Reader and send payloads through channel</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseStream</span><span class="params">(reader io.Reader)</span></span> &lt;-<span class="keyword">chan</span> *Payload &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> *Payload)</span><br><span class="line">    <span class="keyword">go</span> parse0(reader, ch)</span><br><span class="line">    <span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="命令读取及具体解析"><a href="#命令读取及具体解析" class="headerlink" title="命令读取及具体解析"></a>命令读取及具体解析</h4></li><li><p><code>readLine</code>：精确读取一行数据</p></li><li><p><code>parseMultiBulkHeader</code>：处理多行数据(“*”号开始)，改变解析器状态</p></li><li><p><code>parseBulkHeader</code>：处理单个数据(“$”号开始)，改变解析器状态</p></li><li><p><code>parseSingleLineReply</code>：处理客户端发送+ok -err  :5的情况</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readLine</span><span class="params">(bufReader *bufio.Reader, state *readState)</span></span> ([]<span class="type">byte</span>, <span class="type">bool</span>, <span class="type">error</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseMultiBulkHeader</span><span class="params">(msg []<span class="type">byte</span>, state *readState)</span></span> <span class="type">error</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseBulkHeader</span><span class="params">(msg []<span class="type">byte</span>, state *readState)</span></span> <span class="type">error</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseSingleLineReply</span><span class="params">(msg []<span class="type">byte</span>)</span></span> (resp.Reply, <span class="type">error</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="解析实现"><a href="#解析实现" class="headerlink" title="解析实现"></a>解析实现</h4></li><li><p><code>readBody</code>：去除其他字符，解析命令内容</p></li><li><p><code>parse0</code>：根据读取到的数据调用不同的解析方法，并将结果返回Payload的channel</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// read the non-first lines of multi bulk reply or bulk reply</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readBody</span><span class="params">(msg []<span class="type">byte</span>, state *readState)</span></span> <span class="type">error</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parse0</span><span class="params">(reader io.Reader, ch <span class="keyword">chan</span>&lt;- *Payload)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="实现RespHandler"><a href="#实现RespHandler" class="headerlink" title="实现RespHandler"></a>实现RespHandler</h3><p>在TCP层面处理用户发过来的数据，并调用resp协议解析器进行解析，然后根据对应的db去实际执行相关的命令，主要在Handle方法中实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RespHandler implements tcp.Handler and serves as a redis handler</span></span><br><span class="line"><span class="keyword">type</span> RespHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">    activeConn sync.Map <span class="comment">// *client -&gt; placeholder</span></span><br><span class="line">    db         databaseface.Database</span><br><span class="line">    closing    atomic.Boolean <span class="comment">// refusing new client and new request</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MakeHandler creates a RespHandler instance</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeHandler</span><span class="params">()</span></span> *RespHandler &#123;</span><br><span class="line">    <span class="keyword">var</span> db databaseface.Database</span><br><span class="line">    db = database.NewEchoDatabase()</span><br><span class="line">    <span class="keyword">return</span> &amp;RespHandler&#123;</span><br><span class="line">        db: db,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *RespHandler)</span></span> closeClient(client *connection.Connection) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle receives and executes redis commands</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *RespHandler)</span></span> Handle(ctx context.Context, conn net.Conn) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close stops handler</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *RespHandler)</span></span> Close() <span class="type">error</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="EchoDatabase示例"><a href="#EchoDatabase示例" class="headerlink" title="EchoDatabase示例"></a>EchoDatabase示例</h3><p>在<code>database/echo_database.go</code>中简单实现一个数据库，其实现了Database接口。这里只是方便做简单测试，下一篇文章将记录如何实现redis的内存数据库：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> EchoDatabase <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewEchoDatabase</span><span class="params">()</span></span> *EchoDatabase &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;EchoDatabase&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e EchoDatabase)</span></span> Exec(client resp.Connection, args [][]<span class="type">byte</span>) resp.Reply &#123;</span><br><span class="line">    <span class="keyword">return</span> reply.MakeMultiBulkReply(args)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e EchoDatabase)</span></span> AfterClientClose(c resp.Connection) &#123;</span><br><span class="line">    logger.Info(<span class="string">&quot;EchoDatabase AfterClientClose&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e EchoDatabase)</span></span> Close() &#123;</span><br><span class="line">    logger.Info(<span class="string">&quot;EchoDatabase Close&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;本系列文章记录如何基于go语言实现Redis，从整体设计到具体细节实现，不仅可以有效的锻炼自己的编码能力，又能加深对redis的认识。文章主</summary>
      
    
    
    
    <category term="go" scheme="https://zcej.github.io/categories/go/"/>
    
    <category term="项目实战" scheme="https://zcej.github.io/categories/go/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    
    
  </entry>
  
  <entry>
    <title>go语言实现大根堆、小根堆及堆排序</title>
    <link href="https://zcej.github.io/2022/03/18/go/go%E5%AE%9E%E7%8E%B0%E5%A4%A7%E6%A0%B9%E5%A0%86%E3%80%81%E5%B0%8F%E6%A0%B9%E5%A0%86%E5%8F%8A%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>https://zcej.github.io/2022/03/18/go/go%E5%AE%9E%E7%8E%B0%E5%A4%A7%E6%A0%B9%E5%A0%86%E3%80%81%E5%B0%8F%E6%A0%B9%E5%A0%86%E5%8F%8A%E5%A0%86%E6%8E%92%E5%BA%8F/</id>
    <published>2022-03-18T13:07:38.000Z</published>
    <updated>2022-06-28T16:24:38.505Z</updated>
    
    <content type="html"><![CDATA[<p>二叉堆是一种特殊的堆，它满足两个性质：结构性和堆序性</p><ul><li>结构性：二叉堆是一棵完全二叉树，完全二叉树可以用一个数组表示，不需要指针，所以效率更高。当用数组表示时，数组中任一位置i上的元素，其左子树在位置2i上，右子树在位置2i+1上，其父节点在位置i&#x2F;2上。</li><li>堆序性质：堆的最小值或最大值在根节点上，所以可以快速找到最大值或最小值。</li></ul><p>最大堆和最小堆是二叉堆的两种形式：</p><ul><li>最大堆：根节点的键值是所有堆节点键值中最大者的堆。</li><li>最小堆：根节点的键值是所有堆节点键值中最小者的堆。</li></ul><h2 id="最小堆实现"><a href="#最小堆实现" class="headerlink" title="最小堆实现"></a>最小堆实现</h2><h3 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h3><p>当向最小堆插入元素时：</p><blockquote><ul><li>将元素插入末尾</li><li>判断该元素是否需要上移(与父节点比较，如果比父节点小则上移)</li><li>重复上述步骤，直到满足最小堆特性</li></ul></blockquote><p>当向最小堆删除元素时：</p><blockquote><ul><li>删除堆顶元素</li><li>判断目前的堆顶元素是否需要下调(与子节点比较，和其中较小的节点交换位置)</li><li>重复上述步骤，直到满足最小堆特性</li></ul></blockquote><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>下面以求数据流中第k大的元素为问题实现一个最小堆，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> minHeap <span class="keyword">struct</span> &#123;</span><br><span class="line">    k    <span class="type">int</span>   <span class="comment">// 容量</span></span><br><span class="line">    heap []<span class="type">int</span> <span class="comment">// heap数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createMinHeap</span><span class="params">(k <span class="type">int</span>, nums []<span class="type">int</span>)</span></span> *minHeap &#123;</span><br><span class="line">    heap := &amp;minHeap&#123;k: k, heap: []<span class="type">int</span>&#123;&#125;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, n := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        heap.add(n)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> heap</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *minHeap)</span></span> add(num <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(m.heap) &lt; m.k &#123;</span><br><span class="line">        m.heap = <span class="built_in">append</span>(m.heap, num)</span><br><span class="line">        m.up(<span class="built_in">len</span>(m.heap) - <span class="number">1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> num &gt; m.heap[<span class="number">0</span>] &#123;</span><br><span class="line">        m.heap[<span class="number">0</span>] = num</span><br><span class="line">        m.down(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素上浮</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *minHeap)</span></span> up(i <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">        parent := (i - <span class="number">1</span>) &gt;&gt; <span class="number">1</span> <span class="comment">// 找到父节点在heap数组中的位置</span></span><br><span class="line">        <span class="comment">// 如果比父节点元素小，则交换位置并更新索引</span></span><br><span class="line">        <span class="keyword">if</span> m.heap[parent] &gt; m.heap[i] &#123;</span><br><span class="line">            m.heap[parent], m.heap[i] = m.heap[i], m.heap[parent]</span><br><span class="line">            i = parent</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> <span class="comment">// 当前节点比父节点小，满足最小堆性质，退出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素下沉(包括切片中第一个元素，索引为0)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *minHeap)</span></span> down(i <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="number">2</span>*i+<span class="number">1</span> &lt; <span class="built_in">len</span>(m.heap) &#123; <span class="comment">// 左子节点越界，则退出循环</span></span><br><span class="line">        child := <span class="number">2</span>*i + <span class="number">1</span> <span class="comment">// 左子节点在heap切片中的位置</span></span><br><span class="line">        <span class="keyword">if</span> child+<span class="number">1</span> &lt; <span class="built_in">len</span>(m.heap) &amp;&amp; m.heap[child+<span class="number">1</span>] &lt; m.heap[child] &#123;</span><br><span class="line">            child++ <span class="comment">// 如果右子节点没有越界，且值比左子节点更小，则选择下沉右子节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将当前元素与子节点最大元素对比，然后交换并更新索引</span></span><br><span class="line">        <span class="keyword">if</span> m.heap[i] &gt; m.heap[child] &#123;</span><br><span class="line">            m.heap[child], m.heap[i] = m.heap[i], m.heap[child]</span><br><span class="line">            i = child</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> <span class="comment">// 子节点都比自己大，满足最小堆属性，退出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>如果要求输出数据流中的第k大元素，正好可以使用最小堆实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> KthLargest <span class="keyword">struct</span> &#123;</span><br><span class="line">    heap *minHeap</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(k <span class="type">int</span>, nums []<span class="type">int</span>)</span></span> KthLargest &#123;</span><br><span class="line">    <span class="keyword">return</span> KthLargest&#123;heap: createMinHeap(k, nums)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(k *KthLargest)</span></span> Add(val <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    k.heap.add(val)</span><br><span class="line">    <span class="keyword">return</span> k.heap.heap[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用heap包实现"><a href="#使用heap包实现" class="headerlink" title="使用heap包实现"></a>使用heap包实现</h2><p>heap源码中定义了一个Interface接口，该接口一共包含5个方法，定义一个实现了该接口的结构体就实现了一个二叉堆。<br><code>container/heap/heap.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Note that Push and Pop in this interface are for package heap&#x27;s</span></span><br><span class="line"><span class="comment">// implementation to call. To add and remove things from the heap,</span></span><br><span class="line"><span class="comment">// use heap.Push and heap.Pop.</span></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    sort.Interface</span><br><span class="line">    Push(x <span class="keyword">interface</span>&#123;&#125;) <span class="comment">// add x as element Len()</span></span><br><span class="line">    Pop() <span class="keyword">interface</span>&#123;&#125;   <span class="comment">// remove and return element Len() - 1.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sort/sort.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An implementation of Interface can be sorted by the routines in this package.</span></span><br><span class="line"><span class="comment">// The methods refer to elements of the underlying collection by integer index.</span></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Len is the number of elements in the collection.</span></span><br><span class="line">    Len() <span class="type">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Less reports whether the element with index i</span></span><br><span class="line">    <span class="comment">// must sort before the element with index j.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// If both Less(i, j) and Less(j, i) are false,</span></span><br><span class="line">    <span class="comment">// then the elements at index i and j are considered equal.</span></span><br><span class="line">    <span class="comment">// Sort may place equal elements in any order in the final result,</span></span><br><span class="line">    <span class="comment">// while Stable preserves the original input order of equal elements.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Less must describe a transitive ordering:</span></span><br><span class="line">    <span class="comment">//  - if both Less(i, j) and Less(j, k) are true, then Less(i, k) must be true as well.</span></span><br><span class="line">    <span class="comment">//  - if both Less(i, j) and Less(j, k) are false, then Less(i, k) must be false as well.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Note that floating-point comparison (the &lt; operator on float32 or float64 values)</span></span><br><span class="line">    <span class="comment">// is not a transitive ordering when not-a-number (NaN) values are involved.</span></span><br><span class="line">    <span class="comment">// See Float64Slice.Less for a correct implementation for floating-point values.</span></span><br><span class="line">    Less(i, j <span class="type">int</span>) <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Swap swaps the elements with indexes i and j.</span></span><br><span class="line">    Swap(i, j <span class="type">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个最大堆，实现上述接口如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MaxHeap []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MaxHeap)</span></span> Len() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(h)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MaxHeap)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> h[i] &gt; h[j] <span class="comment">// 因为实现最大堆，所以使用大于号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *MaxHeap)</span></span> Swap(i, j <span class="type">int</span>) &#123;</span><br><span class="line">    (*h)[i], (*h)[j] = (*h)[j], (*h)[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *MaxHeap)</span></span> Push(x <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    *h = <span class="built_in">append</span>(*h, x.(<span class="type">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pop 弹出堆顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *MaxHeap)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">    res := (*h)[<span class="built_in">len</span>(*h)<span class="number">-1</span>]</span><br><span class="line">    *h = (*h)[:<span class="built_in">len</span>(*h)<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    h := &amp;MaxHeap&#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>&#125;</span><br><span class="line">    heap.Init(h)</span><br><span class="line">    heap.Push(h, <span class="number">8</span>)</span><br><span class="line">    <span class="keyword">for</span> h.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d &quot;</span>, heap.Pop(h))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序是一种选择排序，它的最坏、最好、平均时间复杂度均为O(nlogn)，它也是不稳定排序。</p><blockquote><ul><li>排序的过程主要由构建初始堆，交换堆顶元素和末尾元素并重建堆两部分组成</li><li>升序使用最大堆，每次和末尾元素交换，然后重新构建最大堆，整体数组减一；反之降序使用最小堆</li><li>堆构建从第一个非叶子节点开始，也就是<code>len/2 - 1</code>所在位置的元素</li></ul></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxHeap</span><span class="params">(nums []<span class="type">int</span>, length <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> length &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    &#125;</span><br><span class="line">    parent := length/<span class="number">2</span> + <span class="number">1</span> <span class="comment">// 第一个非叶子节点</span></span><br><span class="line">    <span class="keyword">for</span> i := parent; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="comment">// 比较三个节点的大小并将较大的节点上浮</span></span><br><span class="line">        max := i</span><br><span class="line">        leftChild := <span class="number">2</span>*i + <span class="number">1</span></span><br><span class="line">        rightChild := <span class="number">2</span>*i + <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> leftChild &lt;= length<span class="number">-1</span> &amp;&amp; nums[leftChild] &gt; nums[max] &#123;</span><br><span class="line">            max = leftChild</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> rightChild &lt;= length<span class="number">-1</span> &amp;&amp; nums[rightChild] &gt; nums[max] &#123;</span><br><span class="line">            max = rightChild</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> max != i &#123;</span><br><span class="line">            nums[i], nums[max] = nums[max], nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortHeap</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    length := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i++ &#123;</span><br><span class="line">        lastLength := length - i <span class="comment">// 剔除已经排完序的元素</span></span><br><span class="line">        nums = maxHeap(nums, lastLength)  <span class="comment">// 重新构建最大堆</span></span><br><span class="line">        nums[<span class="number">0</span>], nums[lastLength<span class="number">-1</span>] = nums[lastLength<span class="number">-1</span>], nums[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    nums := []<span class="type">int</span>&#123;<span class="number">8</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">9</span>&#125;</span><br><span class="line">    fmt.Println(sortHeap(nums))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;二叉堆是一种特殊的堆，它满足两个性质：结构性和堆序性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;结构性：二叉堆是一棵完全二叉树，完全二叉树可以用一个数组表示，不需要指针，所以效率更高。当用数组表示时，数组中任一位置i上的元素，其左子树在位置2i上，右子树在位置2i+1上，其父节点在位置i&amp;</summary>
      
    
    
    
    <category term="go" scheme="https://zcej.github.io/categories/go/"/>
    
    
  </entry>
  
  <entry>
    <title>channel的底层实现</title>
    <link href="https://zcej.github.io/2022/03/05/go/channel%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"/>
    <id>https://zcej.github.io/2022/03/05/go/channel%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-03-05T11:43:21.000Z</published>
    <updated>2022-05-23T09:46:25.833Z</updated>
    
    <content type="html"><![CDATA[<p>本文基于go版本1.16</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>其底层数据结构为runtime包下的一个hchan的结构体，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">qcount   <span class="type">uint</span>           <span class="comment">// total data in the queue</span></span><br><span class="line">dataqsiz <span class="type">uint</span>           <span class="comment">// size of the circular queue</span></span><br><span class="line">buf      unsafe.Pointer <span class="comment">// points to an array of dataqsiz elements</span></span><br><span class="line">elemsize <span class="type">uint16</span></span><br><span class="line">closed   <span class="type">uint32</span></span><br><span class="line">elemtype *_type <span class="comment">// element type</span></span><br><span class="line">sendx    <span class="type">uint</span>   <span class="comment">// send index</span></span><br><span class="line">recvx    <span class="type">uint</span>   <span class="comment">// receive index</span></span><br><span class="line">recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line">sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line"><span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Do not change another G&#x27;s status while holding this lock</span></span><br><span class="line"><span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line"><span class="comment">// with stack shrinking.</span></span><br><span class="line">lock mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">first *sudog</span><br><span class="line">last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li><code>buf</code>指向底层循环数组，只有缓冲型的channel才有</li><li><code>sendx, recvx</code>均指向底层循环数组，表示当前可以发送和接收的元素位置索引值（相对于底层数组）</li><li><code>sendq, recvq</code>分别表示向channel读取或发送数据而阻塞的goroutine队列</li><li><code>waitq</code>是sudog的一个双向链表（sudog实际上是对goroutine的封装）</li><li><code>lock</code>用来保证每个读channel或写channel的操作都是原子的</li></ul></blockquote><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>使用<code>make</code>能创建一个能收能发的channel：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无缓冲通道</span></span><br><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有缓冲通道</span></span><br><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>通过汇编分析（go complie），找到最终创建chan的函数是位于runtime&#x2F;chan.go下的函数<code>makechan</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">maxAlign  = <span class="number">8</span></span><br><span class="line">hchanSize = unsafe.Sizeof(hchan&#123;&#125;) + <span class="type">uintptr</span>(-<span class="type">int</span>(unsafe.Sizeof(hchan&#123;&#125;))&amp;(maxAlign<span class="number">-1</span>))</span><br><span class="line">debugChan = <span class="literal">false</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="type">int</span>)</span></span> *hchan &#123;</span><br><span class="line">elem := t.elem</span><br><span class="line"></span><br><span class="line"><span class="comment">// compiler checks this but be safe.</span></span><br><span class="line"><span class="keyword">if</span> elem.size &gt;= <span class="number">1</span>&lt;&lt;<span class="number">16</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;makechan: invalid channel element type&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> hchanSize%maxAlign != <span class="number">0</span> || elem.align &gt; maxAlign &#123;</span><br><span class="line">throw(<span class="string">&quot;makechan: bad alignment&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mem, overflow := math.MulUintptr(elem.size, <span class="type">uintptr</span>(size))</span><br><span class="line"><span class="keyword">if</span> overflow || mem &gt; maxAlloc-hchanSize || size &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;makechan: size out of range&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers.</span></span><br><span class="line"><span class="comment">// buf points into the same allocation, elemtype is persistent.</span></span><br><span class="line"><span class="comment">// SudoG&#x27;s are referenced from their owning thread so they can&#x27;t be collected.</span></span><br><span class="line"><span class="comment">// TODO(dvyukov,rlh): Rethink when collector can move allocated objects.</span></span><br><span class="line"><span class="keyword">var</span> c *hchan</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> mem == <span class="number">0</span>:</span><br><span class="line"><span class="comment">// Queue or element size is zero.</span></span><br><span class="line">c = (*hchan)(mallocgc(hchanSize, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line"><span class="comment">// Race detector uses this location for synchronization.</span></span><br><span class="line">c.buf = c.raceaddr()</span><br><span class="line"><span class="keyword">case</span> elem.ptrdata == <span class="number">0</span>:</span><br><span class="line"><span class="comment">// Elements do not contain pointers.</span></span><br><span class="line"><span class="comment">// Allocate hchan and buf in one call.</span></span><br><span class="line">c = (*hchan)(mallocgc(hchanSize+mem, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// Elements contain pointers.</span></span><br><span class="line">c = <span class="built_in">new</span>(hchan)</span><br><span class="line">c.buf = mallocgc(mem, elem, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.elemsize = <span class="type">uint16</span>(elem.size)</span><br><span class="line">c.elemtype = elem</span><br><span class="line">c.dataqsiz = <span class="type">uint</span>(size)</span><br><span class="line">lockInit(&amp;c.lock, lockRankHchan)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debugChan &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;makechan: chan=&quot;</span>, c, <span class="string">&quot;; elemsize=&quot;</span>, elem.size, <span class="string">&quot;; dataqsiz=&quot;</span>, size, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>, callerpc <span class="type">uintptr</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;  <span class="comment">// 当channel是nil</span></span><br><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>  <span class="comment">// 非阻塞直接返回false，表示发送失败</span></span><br><span class="line">&#125;</span><br><span class="line">gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanSendNilChan, traceEvGoStop, <span class="number">2</span>)  <span class="comment">// 挂起当前goroutine</span></span><br><span class="line">throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debugChan &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;chansend: chan=&quot;</span>, c, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">racereadpc(c.raceaddr(), callerpc, funcPC(chansend))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fast path: check for failed non-blocking operation without acquiring the lock.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// After observing that the channel is not closed, we observe that the channel is</span></span><br><span class="line"><span class="comment">// not ready for sending. Each of these observations is a single word-sized read</span></span><br><span class="line"><span class="comment">// (first c.closed and second full()).</span></span><br><span class="line"><span class="comment">// Because a closed channel cannot transition from &#x27;ready for sending&#x27; to</span></span><br><span class="line"><span class="comment">// &#x27;not ready for sending&#x27;, even if the channel is closed between the two observations,</span></span><br><span class="line"><span class="comment">// they imply a moment between the two when the channel was both not yet closed</span></span><br><span class="line"><span class="comment">// and not ready for sending. We behave as if we observed the channel at that moment,</span></span><br><span class="line"><span class="comment">// and report that the send cannot proceed.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// It is okay if the reads are reordered here: if we observe that the channel is not</span></span><br><span class="line"><span class="comment">// ready for sending and then observe that it is not closed, that implies that the</span></span><br><span class="line"><span class="comment">// channel wasn&#x27;t closed during the first observation. However, nothing here</span></span><br><span class="line"><span class="comment">// guarantees forward progress. We rely on the side effects of lock release in</span></span><br><span class="line"><span class="comment">// chanrecv() and closechan() to update this thread&#x27;s view of c.closed and full().</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 快速检测非阻塞且channel未关闭情况下的失败场景（详情看下述full函数）：</span></span><br><span class="line">    <span class="comment">// 1. 对于无缓冲channel，接收队列里没有goroutine则发送失败(非阻塞)</span></span><br><span class="line">    <span class="comment">// 2. 对于有缓冲channel，循环数组中已装满元素则发送失败(非阻塞)</span></span><br><span class="line"><span class="keyword">if</span> !block &amp;&amp; c.closed == <span class="number">0</span> &amp;&amp; full(c) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t0 <span class="type">int64</span></span><br><span class="line"><span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">t0 = cputicks()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lock(&amp;c.lock)  <span class="comment">// 锁住channel，并发安全</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;  <span class="comment">// 如果channel关闭了，则解锁并抛出异常</span></span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果接收队列里有goroutine，则直接将要发送的数据拷贝到接收goroutine</span></span><br><span class="line"><span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Found a waiting receiver. We pass the value we want to send</span></span><br><span class="line"><span class="comment">// directly to the receiver, bypassing the channel buffer (if any).</span></span><br><span class="line">send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于有缓冲的channel，如果还有缓冲空间</span></span><br><span class="line"><span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line"><span class="comment">// Space is available in the channel buffer. Enqueue the element to send.</span></span><br><span class="line">qp := chanbuf(c, c.sendx)  <span class="comment">// qp指向buf的sendx位置</span></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">racenotify(c, c.sendx, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line">typedmemmove(c.elemtype, qp, ep)  <span class="comment">// 将数据从ep处拷贝到qp</span></span><br><span class="line">c.sendx++  <span class="comment">// 发送游标值加一</span></span><br><span class="line"><span class="keyword">if</span> c.sendx == c.dataqsiz &#123;  <span class="comment">// 如果发送游标值等于容量值，游标值归0</span></span><br><span class="line">c.sendx = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">c.qcount++  <span class="comment">// 缓冲区的元素数量加一</span></span><br><span class="line">unlock(&amp;c.lock)  <span class="comment">// 解锁</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !block &#123;  <span class="comment">// 如果是非阻塞的，直接返回错误</span></span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// channel满了，发送方会被阻塞。接下来会构造一个sudog</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// Block on the channel. Some receiver will complete our operation for us.</span></span><br><span class="line">    gp := getg()  <span class="comment">// 获取当前goroutine的指针</span></span><br><span class="line">mysg := acquireSudog()</span><br><span class="line">mysg.releasetime = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">mysg.releasetime = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line"><span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">mysg.elem = ep</span><br><span class="line">mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">mysg.g = gp</span><br><span class="line">mysg.isSelect = <span class="literal">false</span></span><br><span class="line">mysg.c = c</span><br><span class="line">gp.waiting = mysg</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">c.sendq.enqueue(mysg)  <span class="comment">// 当前goroutine进入发送等待队列</span></span><br><span class="line"><span class="comment">// Signal to anyone trying to shrink our stack that we&#x27;re about</span></span><br><span class="line"><span class="comment">// to park on a channel. The window between when this G&#x27;s status</span></span><br><span class="line"><span class="comment">// changes and when we set gp.activeStackChans is not safe for</span></span><br><span class="line"><span class="comment">// stack shrinking.</span></span><br><span class="line">atomic.Store8(&amp;gp.parkingOnChan, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 挂起当前goroutine</span></span><br><span class="line">gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanSend, traceEvGoBlockSend, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// Ensure the value being sent is kept alive until the</span></span><br><span class="line"><span class="comment">// receiver copies it out. The sudog has a pointer to the</span></span><br><span class="line"><span class="comment">// stack object, but sudogs aren&#x27;t considered as roots of the</span></span><br><span class="line"><span class="comment">// stack tracer.</span></span><br><span class="line">KeepAlive(ep)</span><br><span class="line"></span><br><span class="line"><span class="comment">// someone woke us up.</span></span><br><span class="line"><span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">throw(<span class="string">&quot;G waiting list is corrupted&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">gp.waiting = <span class="literal">nil</span></span><br><span class="line">gp.activeStackChans = <span class="literal">false</span></span><br><span class="line">closed := !mysg.success</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">mysg.c = <span class="literal">nil</span></span><br><span class="line">releaseSudog(mysg)</span><br><span class="line"><span class="keyword">if</span> closed &#123;</span><br><span class="line"><span class="keyword">if</span> c.closed == <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;chansend: spurious wakeup&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">full</span><span class="params">(c *hchan)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="comment">// c.dataqsiz is immutable (never written after the channel is created)</span></span><br><span class="line"><span class="comment">// so it is safe to read at any time during channel operation.</span></span><br><span class="line"><span class="keyword">if</span> c.dataqsiz == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// Assumes that a pointer read is relaxed-atomic.</span></span><br><span class="line"><span class="keyword">return</span> c.recvq.first == <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Assumes that a uint read is relaxed-atomic.</span></span><br><span class="line"><span class="keyword">return</span> c.qcount == c.dataqsiz</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if !block &amp;&amp; c.closed == 0 &amp;&amp; full(c) &#123;</span></span><br><span class="line"><span class="comment">//        return false</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>这里有一个点需要注意，结合在<code>chansend</code>中调用<code>full</code>的地方上的英文注释进行分析，在得知channel未被关闭的情况下(<code>c.closed==0</code>)，去获取<code>c.recvq.first</code>和<code>c.qcount</code>的值时为什么不需要加锁(假设这个期间channe被关闭，则前后条件实际上是不一致的)？</p><ul><li>因为一个已经关闭的channel不能将channel状态从<code>ready for sending</code>变成<code>not ready for sending</code>，意味着在两个观测之间有一个时刻，通道既没有被关闭，也没有准备好发送，此时直接返回false也是没有问题的</li><li>然后其会依赖<code>chanrecv()</code>和<code>closechan()</code>中锁释放的副作用来更新这个线程的<code>c.closed</code>和<code>full</code></li></ul></blockquote><p>如果从等待接收队列recvq里出队一个sudog(代表一个goroutine)，说明此时channel是空的，没有元素，所以才会有等待接收者。这时会调用send函数将元素直接从发送者的栈拷贝到接收者的栈，关键操作由<code>sendDirect</code>函数完成。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// send processes a send operation on an empty channel c.</span></span><br><span class="line"><span class="comment">// The value ep sent by the sender is copied to the receiver sg.</span></span><br><span class="line"><span class="comment">// The receiver is then woken up to go on its merry way.</span></span><br><span class="line"><span class="comment">// Channel c must be empty and locked.  send unlocks c with unlockf.</span></span><br><span class="line"><span class="comment">// sg must already be dequeued from c.</span></span><br><span class="line"><span class="comment">// ep must be non-nil and point to the heap or the caller&#x27;s stack.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span></span>, skip <span class="type">int</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line"><span class="keyword">if</span> c.dataqsiz == <span class="number">0</span> &#123;</span><br><span class="line">racesync(c, sg)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Pretend we go through the buffer, even though</span></span><br><span class="line"><span class="comment">// we copy directly. Note that we need to increment</span></span><br><span class="line"><span class="comment">// the head/tail locations only when raceenabled.</span></span><br><span class="line">racenotify(c, c.recvx, <span class="literal">nil</span>)</span><br><span class="line">racenotify(c, c.recvx, sg)</span><br><span class="line">c.recvx++</span><br><span class="line"><span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">c.recvx = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">c.sendx = c.recvx <span class="comment">// c.sendx = (c.sendx+1) % c.dataqsiz</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// sg.elem指向接收到的值存放的位置，如val &lt;-ch，指的就是&amp;val</span></span><br><span class="line"><span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">sendDirect(c.elemtype, sg, ep)  <span class="comment">// 直接拷贝内存（从发送者到接收者）</span></span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">gp := sg.g  <span class="comment">// sudo上绑定的goroutine</span></span><br><span class="line">unlockf()</span><br><span class="line">gp.param = unsafe.Pointer(sg)</span><br><span class="line">sg.success = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">goready(gp, skip+<span class="number">1</span>)  <span class="comment">// 唤醒接收的goroutine</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看<code>sendDirect</code>函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sends and receives on unbuffered or empty-buffered channels are the</span></span><br><span class="line"><span class="comment">// only operations where one running goroutine writes to the stack of</span></span><br><span class="line"><span class="comment">// another running goroutine. The GC assumes that stack writes only</span></span><br><span class="line"><span class="comment">// happen when the goroutine is running and are only done by that</span></span><br><span class="line"><span class="comment">// goroutine. Using a write barrier is sufficient to make up for</span></span><br><span class="line"><span class="comment">// violating that assumption, but the write barrier has to work.</span></span><br><span class="line"><span class="comment">// typedmemmove will call bulkBarrierPreWrite, but the target bytes</span></span><br><span class="line"><span class="comment">// are not in the heap, so that will not help. We arrange to call</span></span><br><span class="line"><span class="comment">// memmove and typeBitsBulkBarrier instead.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendDirect</span><span class="params">(t *_type, sg *sudog, src unsafe.Pointer)</span></span> &#123;</span><br><span class="line"><span class="comment">// src is on our stack, dst is a slot on another stack.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Once we read sg.elem out of sg, it will no longer</span></span><br><span class="line"><span class="comment">// be updated if the destination&#x27;s stack gets copied (shrunk).</span></span><br><span class="line"><span class="comment">// So make sure that no preemption points can happen between read &amp; use.</span></span><br><span class="line">dst := sg.elem</span><br><span class="line">typeBitsBulkBarrier(t, <span class="type">uintptr</span>(dst), <span class="type">uintptr</span>(src), t.size)</span><br><span class="line"><span class="comment">// No need for cgo write barrier checks because dst is always</span></span><br><span class="line"><span class="comment">// Go memory.</span></span><br><span class="line">memmove(dst, src, t.size)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里涉及到一个goroutine直接写另一个goroutine栈的操作，一般而言，不同goroutine的栈是各自独有的。而这也违反了GC的一些假设。为了不出问题，写的过程中增加了写屏障，保证正确的完成写操作。这样做的好处是减少了一次内存拷贝，不用先拷贝到channel的buf，直接由发送者到接收者，减少了中间一层，效率得以提高。然后解锁，唤醒接收者，等待调度器的光临，接收者得以重见天日，可以继续执行接收操作后续代码了。</p><h2 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h2><p>接收操作有两种写法，一种带”ok”，表示channel是否被关闭；一种不带”ok”，这种写法当接收到相应类型的零值时无法知道是真实的发送者发送者发送过来的值，还是channel被关闭后，返回给接收者默认类型的零值。经过编译器的处理后，这两种写法对应源码以下的两个函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entry points for &lt;- c from compiled code</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv1</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;</span><br><span class="line">chanrecv(c, elem, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv2</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> (received <span class="type">bool</span>) &#123;</span><br><span class="line">_, received = chanrecv(c, elem, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有上述源码可见，最终都会调用<code>chanrecv</code>这个函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// chanrecv receives on channel c and writes the received data to ep.</span></span><br><span class="line"><span class="comment">// ep may be nil, in which case received data is ignored.</span></span><br><span class="line"><span class="comment">// If block == false and no elements are available, returns (false, false).</span></span><br><span class="line"><span class="comment">// Otherwise, if c is closed, zeros *ep and returns (true, false).</span></span><br><span class="line"><span class="comment">// Otherwise, fills in *ep with an element and returns (true, true).</span></span><br><span class="line"><span class="comment">// A non-nil ep must point to the heap or the caller&#x27;s stack.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>)</span></span> (selected, received <span class="type">bool</span>) &#123;</span><br><span class="line"><span class="comment">// raceenabled: don&#x27;t need to check ep, as it is always on the stack</span></span><br><span class="line"><span class="comment">// or is new memory allocated by reflect.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debugChan &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;chanrecv: chan=&quot;</span>, c, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;  <span class="comment">// 如果是nil的channel</span></span><br><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fast path: check for failed non-blocking operation without acquiring the lock.</span></span><br><span class="line"><span class="keyword">if</span> !block &amp;&amp; empty(c) &#123;</span><br><span class="line"><span class="comment">// After observing that the channel is not ready for receiving, we observe whether the</span></span><br><span class="line"><span class="comment">// channel is closed.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Reordering of these checks could lead to incorrect behavior when racing with a close.</span></span><br><span class="line"><span class="comment">// For example, if the channel was open and not empty, was closed, and then drained,</span></span><br><span class="line"><span class="comment">// reordered reads could incorrectly indicate &quot;open and empty&quot;. To prevent reordering,</span></span><br><span class="line"><span class="comment">// we use atomic loads for both checks, and rely on emptying and closing to happen in</span></span><br><span class="line"><span class="comment">// separate critical sections under the same lock.  This assumption fails when closing</span></span><br><span class="line"><span class="comment">// an unbuffered channel with a blocked send, but that is an error condition anyway.</span></span><br><span class="line"><span class="keyword">if</span> atomic.Load(&amp;c.closed) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// Because a channel cannot be reopened, the later observation of the channel</span></span><br><span class="line"><span class="comment">// being not closed implies that it was also not closed at the moment of the</span></span><br><span class="line"><span class="comment">// first observation. We behave as if we observed the channel at that moment</span></span><br><span class="line"><span class="comment">// and report that the receive cannot proceed.</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// The channel is irreversibly closed. Re-check whether the channel has any pending data</span></span><br><span class="line"><span class="comment">// to receive, which could have arrived between the empty and closed checks above.</span></span><br><span class="line"><span class="comment">// Sequential consistency is also required here, when racing with such a send.</span></span><br><span class="line"><span class="keyword">if</span> empty(c) &#123;</span><br><span class="line"><span class="comment">// The channel is irreversibly closed and empty.</span></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">raceacquire(c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemclr(c.elemtype, ep)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t0 <span class="type">int64</span></span><br><span class="line"><span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">t0 = cputicks()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &amp;&amp; c.qcount == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">raceacquire(c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemclr(c.elemtype, ep)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Found a waiting sender. If buffer is size 0, receive value</span></span><br><span class="line"><span class="comment">// directly from sender. Otherwise, receive from head of queue</span></span><br><span class="line"><span class="comment">// and add sender&#x27;s value to the tail of the queue (both map to</span></span><br><span class="line"><span class="comment">// the same buffer slot because the queue is full).</span></span><br><span class="line">recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有缓冲channel，buf里面有元素，可以正常接收</span></span><br><span class="line"><span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// Receive directly from queue</span></span><br><span class="line">qp := chanbuf(c, c.recvx)</span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">racenotify(c, c.recvx, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;  <span class="comment">// 不忽略要接收的值，不是&quot;&lt;-ch&quot;，而是&quot;val &lt;-ch&quot;，ep指向val</span></span><br><span class="line">typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">&#125;</span><br><span class="line">typedmemclr(c.elemtype, qp)  <span class="comment">// 清理掉循环数组里相应位置的值</span></span><br><span class="line">c.recvx++  <span class="comment">// 接收游标向前移动</span></span><br><span class="line"><span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">c.recvx = <span class="number">0</span>  <span class="comment">// 接收游标归零</span></span><br><span class="line">&#125;</span><br><span class="line">c.qcount--</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// no sender available: block on this channel.</span></span><br><span class="line">gp := getg()</span><br><span class="line">mysg := acquireSudog()</span><br><span class="line">mysg.releasetime = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">mysg.releasetime = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line"><span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">mysg.elem = ep</span><br><span class="line">mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">gp.waiting = mysg</span><br><span class="line">mysg.g = gp</span><br><span class="line">mysg.isSelect = <span class="literal">false</span></span><br><span class="line">mysg.c = c</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">c.recvq.enqueue(mysg)</span><br><span class="line"><span class="comment">// Signal to anyone trying to shrink our stack that we&#x27;re about</span></span><br><span class="line"><span class="comment">// to park on a channel. The window between when this G&#x27;s status</span></span><br><span class="line"><span class="comment">// changes and when we set gp.activeStackChans is not safe for</span></span><br><span class="line"><span class="comment">// stack shrinking.</span></span><br><span class="line">atomic.Store8(&amp;gp.parkingOnChan, <span class="number">1</span>)</span><br><span class="line">gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanReceive, traceEvGoBlockRecv, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// someone woke us up</span></span><br><span class="line"><span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">throw(<span class="string">&quot;G waiting list is corrupted&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">gp.waiting = <span class="literal">nil</span></span><br><span class="line">gp.activeStackChans = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">success := mysg.success</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">mysg.c = <span class="literal">nil</span></span><br><span class="line">releaseSudog(mysg)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, success</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closechan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;close of nil channel&quot;</span>))  <span class="comment">// 关闭一个nil的channel直接panic</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;close of closed channel&quot;</span>))  <span class="comment">// 关闭一个已经关闭的channel，panic</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">callerpc := getcallerpc()</span><br><span class="line">racewritepc(c.raceaddr(), callerpc, funcPC(closechan))</span><br><span class="line">racerelease(c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.closed = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> glist gList</span><br><span class="line"></span><br><span class="line"><span class="comment">// release all readers</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">sg := c.recvq.dequeue()</span><br><span class="line"><span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemclr(c.elemtype, sg.elem)</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">gp := sg.g</span><br><span class="line">gp.param = unsafe.Pointer(sg)</span><br><span class="line">sg.success = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">raceacquireg(gp, c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line">glist.push(gp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// release all writers (they will panic)</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">sg := c.sendq.dequeue()</span><br><span class="line"><span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">gp := sg.g</span><br><span class="line">gp.param = unsafe.Pointer(sg)</span><br><span class="line">sg.success = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">raceacquireg(gp, c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line">glist.push(gp)</span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ready all Gs now that we&#x27;ve dropped the channel lock.</span></span><br><span class="line"><span class="keyword">for</span> !glist.empty() &#123;</span><br><span class="line">gp := glist.pop()</span><br><span class="line">gp.schedlink = <span class="number">0</span></span><br><span class="line">goready(gp, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><ul><li>close逻辑比较简单，对于一个channel，recvq和sendq中分别保存了阻塞的发送者和接收者。关闭channel后，对于等待接收者而言，会收到一个相应类型的零值。对于等待发送者，会直接panic。所以，在不了解channel还有没有接收者的情况下，不能贸然关闭channel。</li><li>close函数先上一把大锁，接着把所有挂在这个channel上的sender和receiver全都连成一个sudog链表，再解锁。最后再将所有的sudog全都唤醒。</li><li>唤醒之后，该干什么干什么。sender会继续执行chansend函数里goparkunlock函数之后的代码，当检测到channel已经关闭了则会panic。receiver则会进行后续的扫尾工作，然后返回，这里selected会返回true，received会根据channel是否关闭返回不同的值。</li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文基于go版本1.16&lt;/p&gt;
&lt;h2 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h2&gt;&lt;p&gt;其底层数据结构为runtime包下的一个hchan的结构体，如下：&lt;/p&gt;
&lt;fig</summary>
      
    
    
    
    <category term="go" scheme="https://zcej.github.io/categories/go/"/>
    
    
  </entry>
  
  <entry>
    <title>go语言变量逃逸分析</title>
    <link href="https://zcej.github.io/2022/02/12/go/go%E8%AF%AD%E8%A8%80%E5%8F%98%E9%87%8F%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/"/>
    <id>https://zcej.github.io/2022/02/12/go/go%E8%AF%AD%E8%A8%80%E5%8F%98%E9%87%8F%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</id>
    <published>2022-02-12T07:16:09.000Z</published>
    <updated>2022-06-28T16:22:59.830Z</updated>
    
    <content type="html"><![CDATA[<p>go实现了内存的自动管理，其主要包括两个动作：分配与释放。为了更好的理解逃逸分析，需要对堆和栈有一定的了解。</p><h2 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h2><p>应用程序的内存载体，可以简单分为堆和栈。</p><p>在go中，栈的内存是由编译器进行分配和释放，栈区往往存储着函数参数、局部变量和调用函数帧，它们随着函数的创建而分配，函数的退出而销毁。一个goroutine对应一个栈，栈是调用栈的简称。一个栈通常又包含了许多栈帧，它描述的函数之间的调用关系，每一帧对应一次尚未返回的函数调用，它本身也是以栈形式存放数据。</p><p>与栈不同的是，应用程序在运行时只会存在一个堆。狭隘的说，内存管理只是针对堆内存而言的。程序在运行期间可以主动从堆上申请内存，这些内存通过go的内存分配器分配，并由垃圾回收器回收。</p><p>另外，对于堆内存的回收，还需要通过标记清除阶段，如三色标记法。但是对于栈上的内存而言，其分配和释放非常廉价。简单的说，它只需要两个cpu指令，一个是分配入栈，一个是栈内释放，而这只需要借助栈相关的寄存器即可完成。</p><h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><p>对于一个对象是被分配在堆上还是栈上，<a href="https://go.dev/doc/faq#stack_or_heap">官网</a>上也有这样的回答：</p><ul><li>如果可以，go编译器会尽可能将变量分配到栈上。但是，当编译器无法证明函数返回后，该变量没有被引用，那么编译器就必须在堆上分配该变量，以此避免悬挂指针。另外如果局部变量非常大，也会将其分配在堆上。</li><li>而go编译器则是通过逃逸分析去选择堆或者是栈，逃逸分析的基本思想如下：检查变量的生命周期是否是完全可知的，如果通过检查，则可以在栈上分配。否则，就是逃逸，必须在堆上进行分配。</li></ul><p>可以通过命令<code>go build -gcflags &quot;-m -l&quot;</code>来查看逃逸分析结果：</p><ul><li>-m：打印逃逸分析信息</li><li>-l：禁止内联优化</li></ul><p>常见的逃逸情况如下所示：</p><h3 id="情况一：变量类型不确定"><a href="#情况一：变量类型不确定" class="headerlink" title="情况一：变量类型不确定"></a>情况一：变量类型不确定</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">666</span></span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出如下</span></span><br><span class="line"><span class="comment">// $ go build -gcflags &quot;-m -l&quot; main.go</span></span><br><span class="line"><span class="comment">// # command-line-arguments</span></span><br><span class="line"><span class="comment">// ./main.go:7:13: ... argument does not escape</span></span><br><span class="line"><span class="comment">// ./main.go:7:13: a escapes to heap</span></span><br></pre></td></tr></table></figure><p>变量a发生了逃逸是因为其被传入了<code>fmt.Println</code>中，这个方法参数自己发生了逃逸。</p><blockquote><ul><li><code>func Println(a ...interface&#123;&#125;) (n int, err error)</code></li><li>因为<code>fmt.Println</code>函数参数为<code>interface</code>类型，编译期无法确定参数的具体类型，故分配在堆上</li></ul></blockquote><h3 id="情况二：暴露给外部指针"><a href="#情况二：暴露给外部指针" class="headerlink" title="情况二：暴露给外部指针"></a>情况二：暴露给外部指针</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> *<span class="type">int</span> &#123;</span><br><span class="line">    a := <span class="number">666</span></span><br><span class="line">    <span class="keyword">return</span> &amp;a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _ = foo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// # command-line-arguments</span></span><br><span class="line"><span class="comment">// .\main.go:4:2: moved to heap: a</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>变量存在外部引用则必定分配到堆上。</p><h3 id="情况三：变量所占内存较大"><a href="#情况三：变量所占内存较大" class="headerlink" title="情况三：变量所占内存较大"></a>情况三：变量所占内存较大</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10000</span>, <span class="number">10000</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        s[i] = i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    foo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// # command-line-arguments</span></span><br><span class="line"><span class="comment">// .\main.go:4:11: make([]int, 10000, 10000) escapes to heap</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里需要注意，在go中执行用户代码的goroutine是一种用户态线程，其调用栈内存被称为用户栈，它其实也是从堆区分配的，但是我们仍然可以将其看作和系统栈一样的内存空间，它的分配和释放都是通过编译器完成的。与其对应的是系统栈，它的分配和释放是操作系统完成的。在GMP模型中，一个M对应一个系统栈(也称为M的g0栈)，M上的多个goroutine会共享该系统栈。</p><ul><li><p>不同架构的系统栈最大限制不同，以x86_64为例，其系统栈最大为8mb</p></li><li><p>我们常说的goroutine初始大小为2kb，说的是用户栈，可在<code>runtime/stack.go</code>中找到</p></li><li><p>在go中大对象的范围为大于32kb，即上述代码中的n达到8192，就会逃逸</p><h3 id="情况四：变量大小不确定"><a href="#情况四：变量大小不确定" class="headerlink" title="情况四：变量大小不确定"></a>情况四：变量大小不确定</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    n := <span class="number">1</span></span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        s[i] = i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    foo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// # command-line-arguments</span></span><br><span class="line"><span class="comment">// .\main.go:5:11: make([]int, n) escapes to heap</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这次，在<code>make</code>方法中，没有直接指定大小，而是填入了变量<code>n</code>，这时go逃逸分析也会将其分配到堆区去。可见，为了保证内存的绝对安全，go的编译器可能会将一些变量不合时宜地分配到堆上，但是因为这些对象最终也会被垃圾收集器处理，所以也能接受。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2></li><li><p>发生逃逸的情况还有很多，理解其思想才是最为重要的。</p></li><li><p>理解逃逸分析可以帮助我们写出更好的程序，知道变量分配在堆栈上的差别，则尽可能写出分配在栈上的代码，堆上的变量变少了，可以减轻内存分配的开销，减小gc的压力，提高程序的运行速度。</p></li><li><p>你会发现有些go上线项目，它们在函数传参的时候，并没有传递结构体指针，而是直接传递的结构体。这个做法，虽然它需要值拷贝，但是这是在栈上完成的操作，开销远比变量逃逸后动态的在堆上分配内存少的多。当然这个做法不是绝对的，如果结构体较大，传递指针将更加合适。</p></li><li><p>从gc的角度来看，指针传递是个双刃剑，需要谨慎使用，否则线上调优解决gc延时会让人崩溃。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;go实现了内存的自动管理，其主要包括两个动作：分配与释放。为了更好的理解逃逸分析，需要对堆和栈有一定的了解。&lt;/p&gt;
&lt;h2 id=&quot;堆和栈&quot;&gt;&lt;a href=&quot;#堆和栈&quot; class=&quot;headerlink&quot; title=&quot;堆和栈&quot;&gt;&lt;/a&gt;堆和栈&lt;/h2&gt;&lt;p&gt;应用程序</summary>
      
    
    
    
    <category term="go" scheme="https://zcej.github.io/categories/go/"/>
    
    
  </entry>
  
  <entry>
    <title>channel到底需不需要手动关闭</title>
    <link href="https://zcej.github.io/2021/12/26/go/channel%E5%88%B0%E5%BA%95%E9%9C%80%E4%B8%8D%E9%9C%80%E8%A6%81%E6%89%8B%E5%8A%A8%E5%85%B3%E9%97%AD%EF%BC%9F/"/>
    <id>https://zcej.github.io/2021/12/26/go/channel%E5%88%B0%E5%BA%95%E9%9C%80%E4%B8%8D%E9%9C%80%E8%A6%81%E6%89%8B%E5%8A%A8%E5%85%B3%E9%97%AD%EF%BC%9F/</id>
    <published>2021-12-25T16:31:29.000Z</published>
    <updated>2022-05-23T09:41:33.091Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前景提要"><a href="#前景提要" class="headerlink" title="前景提要"></a>前景提要</h2><p>下面的代码是《go语言圣经》这本书的其中一个案例，其中主协程和子协程兼具生产消费两种身份了，最终当没有新的消息时代码会阻塞住，而书中没有给出该案例的终止方式，自己也是思考了很久，看来还是对go的channel理解不够深，在使用channel的时候一定要有自己的思考，不然可能会引发很多问题，小到程序莫名其妙的panic，大到出现goroutine以及channel的泄露等等！</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">crawl</span><span class="params">(url <span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    urls, err := links.Extract(url) <span class="comment">// 书中其他章节, 具体逻辑是提取网页中所有a标签的链接</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Print(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> urls</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">worklist := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="type">string</span>)  <span class="comment">// lists of URLs, may have duplicates</span></span><br><span class="line">unseenLinks := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>) <span class="comment">// de-duplicated URLs</span></span><br><span class="line">    urls := []<span class="type">string</span>&#123;<span class="string">&quot;http://xxxx.com&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add command-line arguments to worklist.</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; worklist &lt;- urls &#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create 20 crawler goroutines to fetch each unseen link.</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> link := <span class="keyword">range</span> unseenLinks &#123;</span><br><span class="line">foundLinks := crawl(link)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; worklist &lt;- foundLinks &#125;()</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The main goroutine de-duplicates worklist items</span></span><br><span class="line"><span class="comment">// and sends the unseen ones to the crawlers.</span></span><br><span class="line">seen := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)</span><br><span class="line"><span class="keyword">for</span> list := <span class="keyword">range</span> worklist &#123;</span><br><span class="line">        <span class="keyword">for</span> _, link := <span class="keyword">range</span> list &#123;</span><br><span class="line">            <span class="keyword">if</span> !seen[link] &#123;</span><br><span class="line">seen[link] = <span class="literal">true</span></span><br><span class="line">unseenLinks &lt;- link</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>虽然上述并发案例书中未提及如何终止的问题，不过书里也提供了另外一种并发方式且可自动终止，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tokens is a counting semaphore used to</span></span><br><span class="line"><span class="comment">// enforce a limit of 20 concurrent requests.</span></span><br><span class="line"><span class="keyword">var</span> tokens = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">crawl</span><span class="params">(w work, mutex sync.Locker)</span></span> []work &#123;</span><br><span class="line">    fmt.Println(url)</span><br><span class="line">tokens &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// acquire a token</span></span><br><span class="line">urls, err := links.Extract(w.url)</span><br><span class="line">&lt;-tokens <span class="comment">// release the token</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Print(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> urls</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">worklist := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="type">string</span>)</span><br><span class="line"><span class="keyword">var</span> n <span class="type">int</span> <span class="comment">// number of pending sends to worklist</span></span><br><span class="line">    url := []<span class="type">string</span>&#123;<span class="string">&quot;http://xxxx.com&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// start</span></span><br><span class="line">n++</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; worklist &lt;- []work&#123;url&#125; &#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// crawl the web concurrently</span></span><br><span class="line">visited := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> ; n &gt; <span class="number">0</span>; n-- &#123;</span><br><span class="line">works := &lt;-worklist</span><br><span class="line"><span class="keyword">for</span> _, w := <span class="keyword">range</span> works &#123;</span><br><span class="line"><span class="keyword">if</span> !visited[w.url] &#123;</span><br><span class="line">visited[w.url] = <span class="literal">true</span></span><br><span class="line">n++</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(w work)</span></span> &#123;</span><br><span class="line">worklist &lt;- crawl(w, &amp;lock)</span><br><span class="line">&#125;(w)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种实现方式很巧妙，使用了计数器n进行了限制，主协程在n减为0的时候会终止，子协程也会随之退出。这里的channel在没有被goroutine引用的时候也会被gc所销毁，结合第一个没有终止的案例，我们必须手动去关闭掉生产消费，让程序达到所有消息消费完后自动终止的目的。那么以下知识点就是必须要掌握的！</p><p><a href="https://juejin.cn/post/7033671944587182087">https://juejin.cn/post/7033671944587182087</a></p><h2 id="什么情况下关闭channel会引发panic？"><a href="#什么情况下关闭channel会引发panic？" class="headerlink" title="什么情况下关闭channel会引发panic？"></a>什么情况下关闭channel会引发panic？</h2><p>示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 关闭未初始化的chan</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCloseNilChan</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> errCh <span class="keyword">chan</span> <span class="type">error</span></span><br><span class="line"><span class="built_in">close</span>(errCh)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// panic: close of nil channel</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 关闭已经关闭的chan</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestRepeatClosingChan</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">errCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">error</span>)</span><br><span class="line"><span class="built_in">close</span>(errCh)</span><br><span class="line"><span class="built_in">close</span>(errCh)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// panic: close of closed channel</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 关闭chan后发送数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSendOnClosingChan</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">errCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">error</span>)</span><br><span class="line"><span class="built_in">close</span>(errCh)</span><br><span class="line">errCh &lt;- errors.New(<span class="string">&quot;chan error&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// panic: send on closed channel</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 发送数据时关闭chan</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCloseOnSendingToChan</span><span class="params">(t *testing.T)</span></span>  &#123;</span><br><span class="line">errCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">error</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">errCh &lt;- errors.New(<span class="string">&quot;chan error&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line"><span class="built_in">close</span>(errCh)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// panic: send on closed channel</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结， 下述四种情况下关闭channel会引发panic：</p><ol><li>关闭未初始化的channel</li><li>关闭已经关闭的channel</li><li>在关闭channel后发送数据</li><li>在发送数据时关闭channel</li></ol></blockquote><p>另外，可总结出以下规律：</p><ul><li>只能让channel的唯一发送者关闭此channel</li><li>如果有多个发送者，应该使用专门的信号通知stop channel<h2 id="是否有必要关闭channel？不关闭又如何？"><a href="#是否有必要关闭channel？不关闭又如何？" class="headerlink" title="是否有必要关闭channel？不关闭又如何？"></a>是否有必要关闭channel？不关闭又如何？</h2><h3 id="当channel的发送次数等于接收次数"><a href="#当channel的发送次数等于接收次数" class="headerlink" title="当channel的发送次数等于接收次数"></a>当channel的发送次数等于接收次数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 当channel的发送次数等于接收次数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestIsCloseChannelNecessary_on_equal</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;NumGoroutine:&quot;</span>, runtime.NumGoroutine())</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// sender</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">ch &lt;- i</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// receiver</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;NumGoroutine:&quot;</span>, runtime.NumGoroutine())</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// NumGoroutine: 2</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// NumGoroutine: 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>channel的发送次数等于接收次数时，发送者的goroutine和接收者的goroutine分别会在发送和接收结束时结束自己的goroutine，用于传输数据的channel也会由于代码没有使用被垃圾收集器回收。所以该种情况下不需手动关闭chanel。<h3 id="当channel的发送次数大于-x2F-小于接收次数"><a href="#当channel的发送次数大于-x2F-小于接收次数" class="headerlink" title="当channel的发送次数大于&#x2F;小于接收次数"></a>当channel的发送次数大于&#x2F;小于接收次数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 当channel的发送次数大于/小于接收次数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestIsCloseChannelNecessary_on_more_equal</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;NumGoroutine:&quot;</span>, runtime.NumGoroutine())</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// sender</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;exit 1&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">ch &lt;- i</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// receiver</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;exit 2&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;NumGoroutine:&quot;</span>, runtime.NumGoroutine())</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// NumGoroutine: 2</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">    <span class="comment">//   exit 2</span></span><br><span class="line"><span class="comment">// NumGoroutine: 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>channel的发送次数大于接收次数时，发送者goroutine会等待接收者接收而一直阻塞。所以发送者goroutine一直未退出，channel也会由于一直被发送者使用而无法被垃圾回收。未退出的goroutine和channel会造成内存泄露等问题。<blockquote><p>总结：</p><ul><li>在只有一个发送者和一个接收者的情况下，只要确保发送者或接收者不会阻塞，不关闭channel是可行的。</li><li>在无法判断channel的发送次数和接收次数时，应当在合适的时机关闭channel。</li><li>另外使用for range从channel取值的时候，需要手动close掉channel，否则消费者会一直阻塞进而panic抛出错误，会被判定为死锁。</li></ul></blockquote></li></ul><h2 id="如何判断channel是否关闭？"><a href="#如何判断channel是否关闭？" class="headerlink" title="如何判断channel是否关闭？"></a>如何判断channel是否关闭？</h2><blockquote><p>channel关闭后继续读取该chennel不会阻塞，而是返回对应类型的零值。</p></blockquote><h3 id="使用channel的多重返回值-如err-ok-x3D-lt-errCh"><a href="#使用channel的多重返回值-如err-ok-x3D-lt-errCh" class="headerlink" title="使用channel的多重返回值(如err, ok :&#x3D; &lt;- errCh)"></a>使用channel的多重返回值(如err, ok :&#x3D; &lt;- errCh)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 使用channel的返回值判断其是否关闭</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReadFromClosedChan</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> errCh = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">error</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(errCh)</span><br><span class="line">errCh &lt;- errors.New(<span class="string">&quot;chan error&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">err, ok := &lt;-errCh;</span><br><span class="line">fmt.Println(i, err, ok)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// 0 chan error true</span></span><br><span class="line"><span class="comment">// 1 &lt;nil&gt; false</span></span><br><span class="line"><span class="comment">// 2 &lt;nil&gt; false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>err, ok :&#x3D; &lt;- errCh的第二个值ok返回false表示该channel已关闭。</p><h3 id="使用for-range简化语法"><a href="#使用for-range简化语法" class="headerlink" title="使用for range简化语法"></a>使用for range简化语法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 使用for range简化语法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReadFromClosedChan2</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> errCh = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">error</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(errCh)</span><br><span class="line">errCh &lt;- errors.New(<span class="string">&quot;chan error&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> err := <span class="keyword">range</span> errCh &#123;</span><br><span class="line">fmt.Println(i, err)</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// 0 chan error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何优雅的关闭channel"><a href="#如何优雅的关闭channel" class="headerlink" title="如何优雅的关闭channel?"></a>如何优雅的关闭channel?</h2><p>详细案例参考文章：<a href="https://gfw.go101.org/article/channel-closing.html">https://gfw.go101.org/article/channel-closing.html</a></p><blockquote><p>在使用单通道的函数中错误的关闭channel的话，编译的时候就会报错</p></blockquote><p>参考上述文章，针对常规情况下需要关闭channel的四种场景，做了以下总结：</p><ul><li>一个发送者，一个接收者：发送者关闭channel；接收者使用select或for range判断channel是否关闭</li><li>一个发送者，多个接收者：同上</li><li>多个发送者，一个接收者：接收者接收完后，使用专门的信号channel关闭；发送者使用select监听该信号channel是否关闭</li><li>多个发送者，多个接收者：任意一方或第三方使用专门的信号channel关闭；发送者，接收者都使用select监听该信号channel是否关闭<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>回到开头例举的爬虫案例，个人进行了改写，主要是添加了超过递归深度时的退出以及超时退出和使用信号channel通知所用生产消费的goroutine关闭。具体代码如下，还有很多完善的点，以后理解更深后再进行修改：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> work <span class="keyword">struct</span> &#123;</span><br><span class="line">url   <span class="type">string</span></span><br><span class="line">depth <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">crawl</span><span class="params">(w work, quit <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> []work &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;depth: %d, url: %s\n&quot;</span>, w.depth, w.url)</span><br><span class="line"><span class="keyword">if</span> w.depth &gt; <span class="number">3</span> &#123;</span><br><span class="line">quit &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">urls, err := links.Extract(w.url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Print(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> works []work</span><br><span class="line"><span class="keyword">for</span> _, url := <span class="keyword">range</span> urls &#123;</span><br><span class="line">works = <span class="built_in">append</span>(works, work&#123;url, w.depth + <span class="number">1</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> works</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//!+</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">worklist := <span class="built_in">make</span>(<span class="keyword">chan</span> []work)  <span class="comment">// lists of URLs, may have duplicates</span></span><br><span class="line">unseenLinks := <span class="built_in">make</span>(<span class="keyword">chan</span> work) <span class="comment">// de-duplicated URLs</span></span><br><span class="line">stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)  <span class="comment">// signal chan to stop all goroutine</span></span><br><span class="line"></span><br><span class="line">quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">urls := work&#123;<span class="string">&quot;http://zorelworld.com/&quot;</span>, <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add command-line arguments to worklist.</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; worklist &lt;- []work&#123;urls&#125; &#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create 20 crawler goroutines to fetch each unseen link.</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> link, _ := &lt;-unseenLinks:</span><br><span class="line">foundLinks := crawl(link, quit)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;worklist &lt;- foundLinks&#125;()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The main goroutine de-duplicates worklist items</span></span><br><span class="line"><span class="comment">// and sends the unseen ones to the crawlers.</span></span><br><span class="line">seen := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> list := &lt;-worklist:</span><br><span class="line"><span class="keyword">for</span> _, link := <span class="keyword">range</span> list &#123;</span><br><span class="line"><span class="keyword">if</span> !seen[link.url] &#123;</span><br><span class="line">seen[link.url] = <span class="literal">true</span></span><br><span class="line">unseenLinks &lt;- link</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> &lt;-quit:</span><br><span class="line">fmt.Println(<span class="string">&quot;Exit, 111&quot;</span>)</span><br><span class="line"><span class="built_in">close</span>(stopCh)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">3</span> * time.Second): <span class="comment">// 如果上面的ch一直没数据会阻塞, 那么select也会检测其他case条件, 检测到后3s超时退出</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Exit, timeout&quot;</span>)</span><br><span class="line"><span class="built_in">close</span>(stopCh)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前景提要&quot;&gt;&lt;a href=&quot;#前景提要&quot; class=&quot;headerlink&quot; title=&quot;前景提要&quot;&gt;&lt;/a&gt;前景提要&lt;/h2&gt;&lt;p&gt;下面的代码是《go语言圣经》这本书的其中一个案例，其中主协程和子协程兼具生产消费两种身份了，最终当没有新的消息时代码会阻塞住</summary>
      
    
    
    
    <category term="go" scheme="https://zcej.github.io/categories/go/"/>
    
    
  </entry>
  
  <entry>
    <title>关于channel和goroutine的内存泄漏问题</title>
    <link href="https://zcej.github.io/2021/11/19/go/%E5%85%B3%E4%BA%8Echannel%E5%92%8Cgoroutine%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98/"/>
    <id>https://zcej.github.io/2021/11/19/go/%E5%85%B3%E4%BA%8Echannel%E5%92%8Cgoroutine%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98/</id>
    <published>2021-11-19T15:18:41.000Z</published>
    <updated>2022-06-28T16:12:40.717Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要了解为关闭channel情况下所引发的内存泄露问题。</p><h2 id="一个发送者导致的内存泄露"><a href="#一个发送者导致的内存泄露" class="headerlink" title="一个发送者导致的内存泄露"></a>一个发送者导致的内存泄露</h2><p>主要原因是接收者提前退出了，导致发送者一直阻塞，最后导致了goroutine泄露，如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestLeakOfMemory</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;NumGoroutine:&quot;</span>, runtime.NumGoroutine())</span><br><span class="line">    chanLeakOfMemory()</span><br><span class="line">    time.Sleep(time.Second * <span class="number">3</span>) <span class="comment">// 等待 goroutine 执行，防止过早输出结果</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;NumGoroutine:&quot;</span>, runtime.NumGoroutine())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanLeakOfMemory</span><span class="params">()</span></span> &#123;</span><br><span class="line">    errCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">error</span>) <span class="comment">// (1)</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// (5)</span></span><br><span class="line">        time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">        errCh &lt;- errors.New(<span class="string">&quot;chan error&quot;</span>) <span class="comment">// (2)</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(time.Second): <span class="comment">// (3) 大家也经常在这里使用 &lt;-ctx.Done()</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;超时&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> err = &lt;-errCh: <span class="comment">// (4)</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Println(<span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>上述代码分析：</p><ul><li>由于没有发送方想errCh发送数据，故代码在(4)处阻塞</li><li>当(3)处超时后，函数退出且(4)处代码并未接收成功</li><li>之后(2)开始执行，由于errCh没有接收者，故一直阻塞在(2)出</li><li>因为(2)出的代码所在协程一直没有退出，故发生了内存泄露</li></ul></blockquote><p>这种情况处理起来也较为简单，只需将channel设置为有缓冲的就行。例如将(1)处代码改为<code>errCh := make(chan error, 1)</code>即可。</p><h2 id="多个发送者导致的内存泄露"><a href="#多个发送者导致的内存泄露" class="headerlink" title="多个发送者导致的内存泄露"></a>多个发送者导致的内存泄露</h2><p>产生原因也和上述相同，当接收者提前退出了，那么至少有一个goroutine无法退出，进而造成内存泄露。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestLeakOfMemory2</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;NumGoroutine:&quot;</span>, runtime.NumGoroutine())</span><br><span class="line">    chanLeakOfMemory2()</span><br><span class="line">    time.Sleep(time.Second * <span class="number">3</span>) <span class="comment">// 等待 goroutine 执行，防止过早输出结果</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;NumGoroutine:&quot;</span>, runtime.NumGoroutine())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanLeakOfMemory2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ich := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>) <span class="comment">// (3)</span></span><br><span class="line">    <span class="comment">// sender</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="built_in">close</span>(ich)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">            ich &lt;- i</span><br><span class="line">            time.Sleep(time.Millisecond) <span class="comment">// 控制一下，别发太快</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// receiver</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ctx, cancel := context.WithTimeout(context.Background(), time.Second)</span><br><span class="line">        <span class="keyword">defer</span> cancel()</span><br><span class="line">        <span class="keyword">for</span> i := <span class="keyword">range</span> ich &#123; <span class="comment">// (2)</span></span><br><span class="line">            <span class="keyword">if</span> ctx.Err() != <span class="literal">nil</span> &#123; <span class="comment">// (1)</span></span><br><span class="line">            fmt.Println(ctx.Err())</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            fmt.Println(i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>尽管上述代码使用了有缓冲的channel，依然可能会出现接收者提前退出，导致有缓冲channel的缓存队列被占满，阻塞在第101个位置。这种情况需要使用一个额外的stop channel来结束发送者所在的goroutine，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestLeakOfMemory2</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;NumGoroutine:&quot;</span>, runtime.NumGoroutine())</span><br><span class="line">    chanLeakOfMemory2()</span><br><span class="line">    time.Sleep(time.Second * <span class="number">3</span>) <span class="comment">// 等待 goroutine 执行，防止过早输出结果</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;NumGoroutine:&quot;</span>, runtime.NumGoroutine())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanLeakOfMemory2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ich := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br><span class="line">    stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="comment">// sender</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="built_in">close</span>(ich)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">            <span class="keyword">case</span> ich &lt;- i:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            time.Sleep(time.Millisecond) <span class="comment">// 控制一下，别发太快</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// receiver</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ctx, cancel := context.WithTimeout(context.Background(), time.Second)</span><br><span class="line">        <span class="keyword">defer</span> cancel()</span><br><span class="line">        <span class="keyword">for</span> i := <span class="keyword">range</span> ich &#123;</span><br><span class="line">            <span class="keyword">if</span> ctx.Err() != <span class="literal">nil</span> &#123;</span><br><span class="line">                fmt.Println(ctx.Err())</span><br><span class="line">                <span class="built_in">close</span>(stopCh)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            fmt.Println(i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不论发送者发送一次还是多次，如果接收者在接收完channel中的数据之前退出，那么就会造成内存泄露。如果接收者需要在channel关闭之前退出，为了防止内存泄露，在发送者与接收者一对一时，应设置channel缓冲队列为1；在发送者与接收者一对多或多对多时，应使用专门的stop channel通知发送者关闭相应channel。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文主要了解为关闭channel情况下所引发的内存泄露问题。&lt;/p&gt;
&lt;h2 id=&quot;一个发送者导致的内存泄露&quot;&gt;&lt;a href=&quot;#一个发送者导致的内存泄露&quot; class=&quot;headerlink&quot; title=&quot;一个发送者导致的内存泄露&quot;&gt;&lt;/a&gt;一个发送者导致的内存泄露</summary>
      
    
    
    
    <category term="go" scheme="https://zcej.github.io/categories/go/"/>
    
    
  </entry>
  
  <entry>
    <title>关于channel发生死锁的情况总结</title>
    <link href="https://zcej.github.io/2021/11/03/go/%E5%85%B3%E4%BA%8Echannel%E5%8F%91%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E6%83%85%E5%86%B5%E6%80%BB%E7%BB%93/"/>
    <id>https://zcej.github.io/2021/11/03/go/%E5%85%B3%E4%BA%8Echannel%E5%8F%91%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E6%83%85%E5%86%B5%E6%80%BB%E7%BB%93/</id>
    <published>2021-11-03T13:09:18.000Z</published>
    <updated>2022-06-28T16:13:32.202Z</updated>
    
    <content type="html"><![CDATA[<p>时刻提醒自己必须深入理解channel的特性，有自己的思考，而不是死记硬背。之后可以阅读熟悉下channel的底层实现原理。</p><h2 id="向无缓冲的channel发送-x2F-接收数据"><a href="#向无缓冲的channel发送-x2F-接收数据" class="headerlink" title="向无缓冲的channel发送&#x2F;接收数据"></a>向无缓冲的channel发送&#x2F;接收数据</h2><p>无缓冲的channel必须有接收才能发送，下述代码在执行的时候会引发deadlock错误</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    ch &lt;- <span class="number">1</span>  <span class="comment">// 这一行代码会引发死锁</span></span><br><span class="line">    <span class="comment">// &lt;-ch  // 直接取值也会引发死锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方法是启用一个goroutine去接收值，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    ret := &lt;-c</span><br><span class="line">    fmt.Println(ret)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> recv(ch)</span><br><span class="line">    ch &lt;- <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思考：下述情况会引发死锁吗？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ch &lt;- <span class="number">1</span></span><br><span class="line">    &#125;()</span><br><span class="line">    time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是不会引发死锁，虽然子协程一直阻塞在传值语句，但是和主协程之间并无产生联系，当主协程退出的时候子协程也就跟着退出了。<br>延伸：如果主协程和子协程之间建立了联系会产生死锁吗？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span>, <span class="type">int</span>)</span><br><span class="line">    ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span>, <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ch2 &lt;- <span class="number">21</span></span><br><span class="line">        ch1 &lt;- <span class="number">11</span></span><br><span class="line">    &#125;()</span><br><span class="line">    &lt;-ch1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输出有缓冲的channel中所有的值"><a href="#输出有缓冲的channel中所有的值" class="headerlink" title="输出有缓冲的channel中所有的值"></a>输出有缓冲的channel中所有的值</h2><p>当读取完channel中的数据后，继续读取的操作会造成阻塞，且阻塞发生在主协程中，故会引发阻塞。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">    ch &lt;- <span class="number">1</span></span><br><span class="line">    ch &lt;- <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> ch := <span class="keyword">range</span> ch &#123;</span><br><span class="line">        fmt.Println(ch)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方法是发送完所有数据后则关闭channel，或者通过select方法中的default进行处理，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">    ch &lt;- <span class="number">1</span></span><br><span class="line">    ch &lt;- <span class="number">2</span></span><br><span class="line">    <span class="comment">// solution 1:</span></span><br><span class="line">    <span class="comment">// close(ch)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// solution 2:</span></span><br><span class="line">    <span class="comment">// select &#123;</span></span><br><span class="line">    <span class="comment">// case v := &lt;-ch:</span></span><br><span class="line">    <span class="comment">//     fmt.Println(v)</span></span><br><span class="line">    <span class="comment">// default:</span></span><br><span class="line">    <span class="comment">//     fmt.Println(&quot;nothing in channel&quot;)    </span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">for</span> ch := <span class="keyword">range</span> ch &#123;</span><br><span class="line">        fmt.Println(ch)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="过度向有缓冲的channel写入数据"><a href="#过度向有缓冲的channel写入数据" class="headerlink" title="过度向有缓冲的channel写入数据"></a>过度向有缓冲的channel写入数据</h2><p>写入数据超过channel的容量的时候，也会引发死锁。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">    ch &lt;- <span class="number">1</span></span><br><span class="line">    ch &lt;- <span class="number">2</span></span><br><span class="line">    ch &lt;- <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方法是通过select方法中的default进行处理：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">    ch &lt;- <span class="number">1</span></span><br><span class="line">    ch &lt;- <span class="number">2</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> ch &lt;- <span class="number">3</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;ok&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;wrong&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上述提到的死锁，是指在程序的主协程中发生的情况，如果上述情况是发生在非主协程中，读取或者写入的情况是发生阻塞的，而不是死锁(此时需要考虑是否需要主动关闭子协程)。实际上，阻塞情况省去了我们加锁的步骤，反而是更加有利于代码编写，要合理的运用阻塞。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;时刻提醒自己必须深入理解channel的特性，有自己的思考，而不是死记硬背。之后可以阅读熟悉下channel的底层实现原理。&lt;/p&gt;
&lt;h2 id=&quot;向无缓冲的channel发送-x2F-接收数据&quot;&gt;&lt;a href=&quot;#向无缓冲的channel发送-x2F-接收数据&quot; cl</summary>
      
    
    
    
    <category term="go" scheme="https://zcej.github.io/categories/go/"/>
    
    
  </entry>
  
  <entry>
    <title>如何主动关闭goroutine</title>
    <link href="https://zcej.github.io/2021/10/22/go/%E5%A6%82%E4%BD%95%E4%B8%BB%E5%8A%A8%E5%85%B3%E9%97%ADgoroutine%EF%BC%9F/"/>
    <id>https://zcej.github.io/2021/10/22/go/%E5%A6%82%E4%BD%95%E4%B8%BB%E5%8A%A8%E5%85%B3%E9%97%ADgoroutine%EF%BC%9F/</id>
    <published>2021-10-22T12:22:41.000Z</published>
    <updated>2022-06-28T16:08:48.495Z</updated>
    
    <content type="html"><![CDATA[<p>在学习go语言channel中，读到最多的一句话便是<strong>通过通信共享内存，而不是通过共享内存来进行通信（Do not communicate by sharing memory；instead，share memory by communicating.）</strong>那么如何来理解这句话呢？个人理解通过共享内存来通信的话必须保证数据的安全及正确性，即需要通过加锁等手段进行控制，但是此种方式带来的性能开销以及可能造成的死锁问题处理起来较为繁琐。而go语言则通过channel来通信，通过通信来传递内存数据，个人认为更加优雅简洁与高效。<br>很多情况下我们需要主动关闭goroutine，那么如何实现呢？</p><h2 id="使用channel进行控制"><a href="#使用channel进行控制" class="headerlink" title="使用channel进行控制"></a>使用channel进行控制</h2><h3 id="for-range结构"><a href="#for-range结构" class="headerlink" title="for-range结构"></a>for-range结构</h3><p>for-range从channel上获取值，直到channel关闭。该结构对于从单一通道上获取数据去执行某些任务是十分方便的，如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">producer</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        data := i * i</span><br><span class="line">        fmt.Println(<span class="string">&quot;生产者生产数据：&quot;</span>, data)</span><br><span class="line">        out &lt;- data</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consumer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> data := <span class="keyword">range</span> in &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;消费者得到数据：&quot;</span>, data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> producer(ch)</span><br><span class="line">    consumer(ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="for-select结构"><a href="#for-select结构" class="headerlink" title="for-select结构"></a>for-select结构</h3><p>当channel比较多时，for-range结构就不是很方便了。此时可以使用for-select，select能够让goroutine在多个通信操作上等待（可以理解为监听多个channel）。</p><h4 id="指定一个退出的channel"><a href="#指定一个退出的channel" class="headerlink" title="指定一个退出的channel"></a>指定一个退出的channel</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">producer</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="type">int</span>, exit <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        data := i * i</span><br><span class="line">        fmt.Println(<span class="string">&quot;生产者生产数据：&quot;</span>, data)</span><br><span class="line">        out &lt;- data</span><br><span class="line">    &#125;</span><br><span class="line">    exit &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consumer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="type">int</span>, exit <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-exit:</span><br><span class="line">            fmt.Println(<span class="string">&quot;收到退出信号&quot;</span>)</span><br><span class="line">            <span class="comment">// 不建议使用goto语句</span></span><br><span class="line">            <span class="keyword">return</span>  <span class="comment">// 必须return, 否则goroutine不会结束</span></span><br><span class="line">        <span class="keyword">case</span> data := &lt;-in:</span><br><span class="line">            fmt.Println(<span class="string">&quot;消费者得到数据：&quot;</span>, data)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    exitCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">go</span> producer(ch, exitCh)</span><br><span class="line">    consumer(ch, exitCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多个channel都关闭才能退出"><a href="#多个channel都关闭才能退出" class="headerlink" title="多个channel都关闭才能退出"></a>多个channel都关闭才能退出</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">producer</span><span class="params">(out1, out2 <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        data := i * i</span><br><span class="line">        fmt.Println(<span class="string">&quot;生产者生产数据：&quot;</span>, data)</span><br><span class="line">        out1 &lt;- data</span><br><span class="line">        time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">        out2 &lt;- data * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(out1)</span><br><span class="line">    <span class="built_in">close</span>(out2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consumer</span><span class="params">(in1, in2 &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> data, ok := &lt;-in1:</span><br><span class="line">            <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                fmt.Println(<span class="string">&quot;收到ch1关闭信号&quot;</span>)</span><br><span class="line">                in1 = <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">            fmt.Println(<span class="string">&quot;消费者得到数据：&quot;</span>, data)</span><br><span class="line">        <span class="keyword">case</span> data, ok := &lt;-in2:</span><br><span class="line">            <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                fmt.Println(<span class="string">&quot;收到ch2关闭信号&quot;</span>)</span><br><span class="line">                in2 = <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">            fmt.Println(<span class="string">&quot;消费者得到数据：&quot;</span>, data)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> in1 == <span class="literal">nil</span> &amp;&amp; in2 == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> producer(ch1, ch2)</span><br><span class="line">    consumer(ch1, ch2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用content包进行控制"><a href="#使用content包进行控制" class="headerlink" title="使用content包进行控制"></a>使用content包进行控制</h2><p>context是官方提供的用于控制多个goroutine协作的包。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">producer</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="type">int</span>, ctx context.Context, cancel context.CancelFunc)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        data := i * i</span><br><span class="line">        fmt.Println(<span class="string">&quot;生产者生产数据：&quot;</span>, data)</span><br><span class="line">        out &lt;- data</span><br><span class="line">    &#125;</span><br><span class="line">    subCtx, _ := context.WithCancel(ctx)</span><br><span class="line">    <span class="keyword">go</span> consumer2(subCtx)</span><br><span class="line">    cancel()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consumer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="type">int</span>, ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> data := &lt;-in:</span><br><span class="line">            fmt.Println(<span class="string">&quot;消费者得到数据：&quot;</span>, data)</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            fmt.Println(<span class="string">&quot;收到结束信号&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span>  <span class="comment">// 必须return, 防止goroutine泄露</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consumer2</span><span class="params">(ctx context.Context)</span></span>  &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            fmt.Println(<span class="string">&quot;收到结束信号, consumer2&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span>  <span class="comment">// 必须return, 防止goroutine泄露</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> producer(ch, ctx, cancel)</span><br><span class="line">    consumer(ch, ctx)</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在实际开发过程中，不会简单的启动goroutine就结束了。往往是需要有效的管理多个goroutine之间的协作，此时掌握如何主动关闭goroutine就显得尤为重要了。不仅如此，还需要学会分析go语言运行性能，下一个目标就是学习go语言中的性能大杀器pprof。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在学习go语言channel中，读到最多的一句话便是&lt;strong&gt;通过通信共享内存，而不是通过共享内存来进行通信（Do not communicate by sharing memory；instead，share memory by communicating.）&lt;/s</summary>
      
    
    
    
    <category term="go" scheme="https://zcej.github.io/categories/go/"/>
    
    
  </entry>
  
  <entry>
    <title>如何控制并发速率</title>
    <link href="https://zcej.github.io/2021/10/11/go/%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91%E9%80%9F%E7%8E%87%EF%BC%9F/"/>
    <id>https://zcej.github.io/2021/10/11/go/%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91%E9%80%9F%E7%8E%87%EF%BC%9F/</id>
    <published>2021-10-11T14:31:19.000Z</published>
    <updated>2022-06-28T16:09:56.259Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么需要控制"><a href="#为什么需要控制" class="headerlink" title="为什么需要控制"></a>为什么需要控制</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; math.MaxInt32; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            fmt.Println(i)</span><br><span class="line">            time.Sleep(time.Second)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过高的并发会将系统资源消耗殆尽，导致程序运行最终panic，关键的报错信息如下：<br><code>panic: too many concurrent operations on a single file or socket (max 1048575)</code></p><blockquote><ul><li>导致出现上述错误的原因是源自fmt.Printf函数输出到标准输出，标准输出也可以视为文件，总之就是系统的资源被耗尽了。</li><li>就算注释掉fmt.Printf函数，也会因为内存不足而最终崩溃。</li></ul></blockquote><h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>解决的主要方式就是限制并发的协程数量。</p><h3 id="使用带缓冲的channel进行控制"><a href="#使用带缓冲的channel进行控制" class="headerlink" title="使用带缓冲的channel进行控制"></a>使用带缓冲的channel进行控制</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            log.Println(i)</span><br><span class="line">            time.Sleep(time.Second)</span><br><span class="line">            &lt;-ch</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>创建一个缓冲区大小为3的channel，在没有被接收的情况下，最多发送3个消息则被阻塞</li><li>开启协程前，调用<code>ch &lt;- struct&#123;&#125;&#123;&#125;</code>，若缓冲区满则阻塞</li><li>协程任务结束，调用<code>&lt;-ch</code>释放缓冲区</li></ul></blockquote><h3 id="利用第三方库"><a href="#利用第三方库" class="headerlink" title="利用第三方库"></a>利用第三方库</h3><p>目前有很多第三方库实现了协程池，可以很方便的用来控制协程的并发数量，如<code>Jeffail/tunny</code>，<code>panjf2000/ants</code>，以<code>tunny</code>举例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pool := tunny.NewFunc(<span class="number">3</span>, <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">        log.Println(i)</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">defer</span> pool.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> pool.Process(i)</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(time.Second * <span class="number">4</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li><code>tunny.NewFunc(3, f)</code>第一个参数是协程池的大小(poolSize)，第二个参数是协程运行的函数(worker)</li><li><code>pool.Process(i)</code>将参数i传递给协程池定义好的worker处理</li><li><code>pool.Close()</code>关闭协程池</li></ul></blockquote><h2 id="调整系统资源上限"><a href="#调整系统资源上限" class="headerlink" title="调整系统资源上限"></a>调整系统资源上限</h2><h3 id="ulimit"><a href="#ulimit" class="headerlink" title="ulimit"></a>ulimit</h3><p>有些情况下，即使我们有效的限制了协程的并发数量，但是仍旧出现某一类资源不足的问题，例如：</p><ul><li>too many open files</li><li>out of memory</li></ul><p>操作系统通常会限制同时打开文件数量，栈空间大小等，<code>ulimit -a</code>可以看到系统的当前设置：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# ulimit -a</span><br><span class="line">core file size          (blocks, -c) unlimited</span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">scheduling priority             (-e) <span class="number">0</span></span><br><span class="line">file size               (blocks, -f) unlimited</span><br><span class="line">pending signals                 (-i) <span class="number">14997</span></span><br><span class="line">max locked memory       (kbytes, -l) <span class="number">64</span></span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) <span class="number">100001</span></span><br><span class="line">pipe size            (<span class="number">512</span> bytes, -p) <span class="number">8</span></span><br><span class="line">POSIX message queues     (bytes, -q) <span class="number">819200</span></span><br><span class="line"><span class="built_in">real</span>-time priority              (-r) <span class="number">0</span></span><br><span class="line">stack size              (kbytes, -s) <span class="number">8192</span></span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) <span class="number">14997</span></span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line">file locks                      (-x) unlimited</span><br></pre></td></tr></table></figure><p>进而进行按需调整即可。</p><h3 id="虚拟内存virtual-memory"><a href="#虚拟内存virtual-memory" class="headerlink" title="虚拟内存virtual memory"></a>虚拟内存virtual memory</h3><p>虚拟内存是一项非常常见的技术，当内存不足时，将磁盘映射为内存使用，比如linux下的交换分区(swap space)。在linux上创建并使用交换分区是一件非常简单的事情：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo fallocate -l 20G /mnt/.swapfile # 创建 20G 空文件</span><br><span class="line">sudo mkswap /mnt/.swapfile    # 转换为交换分区文件</span><br><span class="line">sudo chmod 600 /mnt/.swapfile # 修改权限为 600</span><br><span class="line">sudo swapon /mnt/.swapfile    # 激活交换分区</span><br><span class="line">free -m # 查看当前内存使用情况(包括交换分区)</span><br></pre></td></tr></table></figure><p>关闭交换分区也非常简单：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo swapoff /mnt/.swapfile</span><br><span class="line">rm -rf /mnt/.swapfile</span><br></pre></td></tr></table></figure><p>磁盘的 I&#x2F;O 读写性能和内存条相差是非常大的，例如 DDR3 的内存条读写速率很容易达到 20GB&#x2F;s，但是 SSD 固态硬盘的读写性能通常只能达到 0.5GB&#x2F;s，相差 40倍之多。因此，使用虚拟内存技术将硬盘映射为内存使用，显然会对性能产生一定的影响。如果应用程序只是在较短的时间内需要较大的内存，那么虚拟内存能够有效避免 out of memory 的问题。如果应用程序长期高频度读写大量内存，那么虚拟内存对性能的影响就比较明显了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;为什么需要控制&quot;&gt;&lt;a href=&quot;#为什么需要控制&quot; class=&quot;headerlink&quot; title=&quot;为什么需要控制&quot;&gt;&lt;/a&gt;为什么需要控制&lt;/h2&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gu</summary>
      
    
    
    
    <category term="go" scheme="https://zcej.github.io/categories/go/"/>
    
    
  </entry>
  
  <entry>
    <title>go语言实现爬虫(三)</title>
    <link href="https://zcej.github.io/2021/09/16/go/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%EF%BC%9Ago%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%88%AC%E8%99%AB(%E4%B8%89)/"/>
    <id>https://zcej.github.io/2021/09/16/go/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%EF%BC%9Ago%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%88%AC%E8%99%AB(%E4%B8%89)/</id>
    <published>2021-09-15T16:12:23.000Z</published>
    <updated>2022-06-28T16:18:26.065Z</updated>
    
    <content type="html"><![CDATA[<h2 id="添加grpc"><a href="#添加grpc" class="headerlink" title="添加grpc"></a>添加grpc</h2><p>简单编写proto文件：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;./;proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">service </span><span class="title class_">Crawler</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> Start (StartReq) <span class="keyword">returns</span> (TaskInfoResp) </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> Stop (TaskInfoReq) <span class="keyword">returns</span> (TaskInfoResp) </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> Status (TaskInfoReq) <span class="keyword">returns</span> (TaskInfoResp) </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> Pause (TaskInfoReq) <span class="keyword">returns</span> (TaskInfoResp) </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> Resume (TaskInfoReq) <span class="keyword">returns</span> (TaskInfoResp) </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> Result (TaskInfoReq) <span class="keyword">returns</span> (TaskInfoResp) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">StartReq</span> &#123;</span><br><span class="line">    <span class="type">string</span> taskID = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">repeated</span> <span class="type">string</span> urls = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int32</span> threads = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int32</span> timeout = <span class="number">4</span>;</span><br><span class="line">    <span class="type">int32</span> depth = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">TaskInfoReq</span> &#123;</span><br><span class="line">    <span class="type">string</span> taskID = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">TaskInfoResp</span> &#123;</span><br><span class="line">    <span class="type">int32</span> code = <span class="number">1</span>;</span><br><span class="line">    <span class="type">string</span> msg = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">repeated</span> <span class="type">string</span> data = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;添加grpc&quot;&gt;&lt;a href=&quot;#添加grpc&quot; class=&quot;headerlink&quot; title=&quot;添加grpc&quot;&gt;&lt;/a&gt;添加grpc&lt;/h2&gt;&lt;p&gt;简单编写proto文件：&lt;/p&gt;
&lt;figure class=&quot;highlight protobuf&quot;&gt;&lt;t</summary>
      
    
    
    
    <category term="go" scheme="https://zcej.github.io/categories/go/"/>
    
    
  </entry>
  
  <entry>
    <title>go语言实现爬虫(二)</title>
    <link href="https://zcej.github.io/2021/09/13/go/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%EF%BC%9Ago%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%88%AC%E8%99%AB(%E4%BA%8C)/"/>
    <id>https://zcej.github.io/2021/09/13/go/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%EF%BC%9Ago%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%88%AC%E8%99%AB(%E4%BA%8C)/</id>
    <published>2021-09-13T13:05:57.000Z</published>
    <updated>2022-06-28T16:21:25.740Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用gin封装"><a href="#使用gin封装" class="headerlink" title="使用gin封装"></a>使用gin封装</h2><p>项目目录结构如下：</p><ul><li><p><code>api</code>：主要业务逻辑实现，结合gin的上下文进行封装</p></li><li><p><code>config</code>：项目主要配置文件</p></li><li><p><code>global</code>：全局变量管理</p></li><li><p><code>model</code>：结构体定义的地方</p></li><li><p><code>proto</code>：定义proto文件，存放其生成的go文件</p></li><li><p><code>router</code>：路由控制</p></li><li><p><code>storage</code>：运行日志存储及临时结果存放</p></li><li><p><code>util</code>：常用的工具类封装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">├─api</span><br><span class="line">│  │  base.go</span><br><span class="line">│  │</span><br><span class="line">│  └─crawler</span><br><span class="line">│      │  crawl.go</span><br><span class="line">│      │</span><br><span class="line">│      └─links</span><br><span class="line">│         links.go</span><br><span class="line">│</span><br><span class="line">├─config</span><br><span class="line">│      settings.go</span><br><span class="line">│</span><br><span class="line">├─global</span><br><span class="line">│      global.go</span><br><span class="line">│</span><br><span class="line">├─model</span><br><span class="line">│  ├─request</span><br><span class="line">│  │      request.go</span><br><span class="line">│  │</span><br><span class="line">│  └─response</span><br><span class="line">│         response.go</span><br><span class="line">│</span><br><span class="line">├─proto</span><br><span class="line">│      crawler.proto</span><br><span class="line">│</span><br><span class="line">├─router</span><br><span class="line">│      router.go</span><br><span class="line">│</span><br><span class="line">├─storage</span><br><span class="line">│  ├─logs</span><br><span class="line">│  └─tasks</span><br><span class="line">│─utils</span><br><span class="line">│   └─writer</span><br><span class="line">│         write_data.go</span><br><span class="line">│  go.mod</span><br><span class="line">│  go.sum</span><br><span class="line">│  main.go</span><br><span class="line">│  readme.md</span><br></pre></td></tr></table></figure><h2 id="完善各控制流程"><a href="#完善各控制流程" class="headerlink" title="完善各控制流程"></a>完善各控制流程</h2><p>任务定义及初始化如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> work <span class="keyword">struct</span> &#123;</span><br><span class="line">    url       <span class="type">string</span> <span class="comment">// 网页链接</span></span><br><span class="line">    currDepth <span class="type">int</span>    <span class="comment">// 当前深度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> WlcTask <span class="keyword">struct</span> &#123;</span><br><span class="line">    taskID         <span class="type">string</span>          <span class="comment">// 任务ID</span></span><br><span class="line">    workList       <span class="keyword">chan</span> []work     <span class="comment">// 存放每一个链接下一层的所有链接</span></span><br><span class="line">    workListBak    <span class="keyword">chan</span> []work     <span class="comment">// workList的备份, 用于任务的暂停与恢复</span></span><br><span class="line">    unVisitedLinks <span class="keyword">chan</span> work       <span class="comment">// 存放未访问过的链接</span></span><br><span class="line">    stopSignalCh   <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;   <span class="comment">// 用于通知所有生产消费的goroutine退出, 防止内存泄露</span></span><br><span class="line">    quitCh         <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;   <span class="comment">// 用于主动停止任务, 通过递归深度判断</span></span><br><span class="line">    statusCh       <span class="keyword">chan</span> <span class="type">string</span>     <span class="comment">// 用于记录任务状态变化</span></span><br><span class="line">    visited        <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span> <span class="comment">// 标记已访问过的链接</span></span><br><span class="line">    startUrl       []work          <span class="comment">// 开始链接</span></span><br><span class="line">    concurrency    <span class="type">int</span>             <span class="comment">// 并发数量</span></span><br><span class="line">    timeOut        <span class="type">int</span>             <span class="comment">// 超时时间设置</span></span><br><span class="line">    depth          <span class="type">int</span>             <span class="comment">// 递归深度</span></span><br><span class="line">    currDepth      <span class="type">int</span>             <span class="comment">// 当前递归深度</span></span><br><span class="line">    status         <span class="type">string</span>          <span class="comment">// 任务状态 created running stopped finished pausing resuming</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWclTask</span><span class="params">(wlcReq *request.WlcTaskReq)</span></span> *WlcTask &#123;</span><br><span class="line">    <span class="keyword">var</span> startUrl []work</span><br><span class="line">    <span class="keyword">for</span> _, url := <span class="keyword">range</span> wlcReq.Urls &#123;</span><br><span class="line">        startUrl = <span class="built_in">append</span>(startUrl, work&#123;url: url, currDepth: <span class="number">1</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    workListCh := <span class="built_in">make</span>(<span class="keyword">chan</span> []work)</span><br><span class="line">    <span class="keyword">return</span> &amp;WlcTask&#123;</span><br><span class="line">        taskID:         wlcReq.TaskID,</span><br><span class="line">        workList:       workListCh,</span><br><span class="line">        workListBak:    workListCh,</span><br><span class="line">        unVisitedLinks: <span class="built_in">make</span>(<span class="keyword">chan</span> work),</span><br><span class="line">        stopSignalCh:   <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">        quitCh:         <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">        statusCh:       <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>),</span><br><span class="line">        visited:        <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>),</span><br><span class="line">        startUrl:       startUrl,</span><br><span class="line">        concurrency:    wlcReq.Concurrency,</span><br><span class="line">        timeOut:        wlcReq.Timeout,</span><br><span class="line">        depth:          wlcReq.Depth,</span><br><span class="line">        currDepth:      <span class="number">1</span>,</span><br><span class="line">        status:         config.TaskStatus.Created,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，还针对<code>WlcTask</code>封装了一个改变任务状态的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *WlcTask)</span></span> ChangeTaskStatus() &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-w.stopSignalCh:</span><br><span class="line">            log.Printf(<span class="string">&quot;[Start] record task(%s) status goroutine exit...&quot;</span>, w.taskID)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">case</span> taskStr, ok := &lt;-w.statusCh:</span><br><span class="line">            <span class="keyword">if</span> ok &#123;</span><br><span class="line">                arr := strings.Split(taskStr, <span class="string">&quot;,&quot;</span>)</span><br><span class="line">                w.status = arr[<span class="number">0</span>]</span><br><span class="line">                currDepth, err := strconv.Atoi(arr[<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    log.Println(err)</span><br><span class="line">                &#125;</span><br><span class="line">                log.Printf(<span class="string">&quot;[Start] change task(%s) status to %s, depth is, %d&quot;</span>, w.taskID, w.status, currDepth)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// recode the task info to a json file</span></span><br><span class="line">                task := request.TaskInfo&#123;</span><br><span class="line">                    Status:    arr[<span class="number">0</span>],</span><br><span class="line">                    CurrDepth: currDepth,</span><br><span class="line">                &#125;</span><br><span class="line">                writer.TaskInfoWriter(w.taskID, &amp;task)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *WlcTask)</span></span> StartHandler(globalTask <span class="keyword">map</span>[<span class="type">string</span>]*WlcTask) &#123;</span><br><span class="line"><span class="comment">// record the task status change</span></span><br><span class="line">    <span class="keyword">go</span> w.ChangeTaskStatus()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; w.workList &lt;- w.startUrl &#125;()</span><br><span class="line"></span><br><span class="line">    w.statusCh &lt;- fmt.Sprintf(<span class="string">&quot;%s,%d&quot;</span>, config.TaskStatus.Running, w.currDepth)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; w.concurrency; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(num <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;-w.stopSignalCh:</span><br><span class="line">                    log.Printf(<span class="string">&quot;[Start] task(%s) goroutine %d exit...&quot;</span>, w.taskID, num)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">case</span> link, _ := &lt;-w.unVisitedLinks:</span><br><span class="line">                    foundLinks := crawl(link, w.depth, w.quitCh)</span><br><span class="line">                    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; w.workList &lt;- foundLinks &#125;()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> list := &lt;-w.workList:</span><br><span class="line">            <span class="comment">// change taskStatus from resuming to running</span></span><br><span class="line">            <span class="keyword">if</span> w.status != config.TaskStatus.Running &#123;</span><br><span class="line">                w.status = config.TaskStatus.Running</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> _, link := <span class="keyword">range</span> list &#123;</span><br><span class="line">                <span class="keyword">if</span> !w.visited[link.url] &#123;</span><br><span class="line">                    w.visited[link.url] = <span class="literal">true</span></span><br><span class="line">                    w.unVisitedLinks &lt;- link</span><br><span class="line">                    <span class="comment">// write crawl result to file and update currDepth</span></span><br><span class="line">                    writer.TaskResultWriter(fmt.Sprintf(<span class="string">&quot;%s.txt&quot;</span>, w.taskID), fmt.Sprintln(link.url))</span><br><span class="line">                    <span class="keyword">if</span> link.currDepth != w.currDepth &#123;</span><br><span class="line">                        w.currDepth = link.currDepth</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> &lt;-w.quitCh:</span><br><span class="line">            log.Printf(<span class="string">&quot;[Start] task(%s) over than crawl depth, get quit signal and exit&quot;</span>, w.taskID)</span><br><span class="line">            w.statusCh &lt;- fmt.Sprintf(<span class="string">&quot;%s,%d&quot;</span>, config.TaskStatus.Stopped, w.currDepth)</span><br><span class="line">            <span class="built_in">close</span>(w.stopSignalCh)</span><br><span class="line">            <span class="built_in">delete</span>(globalTask, w.taskID)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-time.After(time.Duration(w.timeOut) * time.Second):</span><br><span class="line">            <span class="keyword">if</span> w.status == config.TaskStatus.Pausing || w.status == config.TaskStatus.Resuming &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.Printf(<span class="string">&quot;[Start] task(%s) execute timeout, get timeout signal and exit&quot;</span>, w.taskID)</span><br><span class="line">                w.statusCh &lt;- fmt.Sprintf(<span class="string">&quot;%s,%d&quot;</span>, config.TaskStatus.Finished, w.currDepth)</span><br><span class="line">                <span class="built_in">close</span>(w.stopSignalCh)</span><br><span class="line">                <span class="built_in">delete</span>(globalTask, w.taskID)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h3><p>停止较为简单，直接向退出信号channel发送消息即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *WlcTask)</span></span> StopHandler() &#123;</span><br><span class="line">    w.quitCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="暂停"><a href="#暂停" class="headerlink" title="暂停"></a>暂停</h3><p>暂停的思路是将数据传输的channel赋值为nil，则相关的goroutine会阻塞进而整个执行暂停。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *WlcTask)</span></span> PauseHandler() &#123;</span><br><span class="line">    <span class="keyword">if</span> w.status == config.TaskStatus.Pausing &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;[Pause] task(%s) is already pause, can&#x27;t pause again&quot;</span>, w.taskID)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> w.status == config.TaskStatus.Stopped || w.status == config.TaskStatus.Finished &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;[Pause] task(%s) is closed, can&#x27;t pause&quot;</span>, w.taskID)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    w.statusCh &lt;- fmt.Sprintf(<span class="string">&quot;%s,%d&quot;</span>, config.TaskStatus.Pausing, w.currDepth)</span><br><span class="line">    w.workList = <span class="literal">nil</span></span><br><span class="line">    log.Printf(<span class="string">&quot;[Pause] task(%s) is pausing&quot;</span>, w.taskID)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h3><p>将之前备份好的数据channel重新赋值给当前使用的channel，则相关goroutine会接着运行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *WlcTask)</span></span> ResumingHandler() &#123;</span><br><span class="line">    <span class="keyword">if</span> w.status != config.TaskStatus.Pausing &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;[Resume] task(%s) is not pausing, can&#x27;t resume&quot;</span>, w.taskID)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    w.workList = w.workListBak</span><br><span class="line">    w.statusCh &lt;- fmt.Sprintf(<span class="string">&quot;%s,%d&quot;</span>, config.TaskStatus.Resuming, w.currDepth)</span><br><span class="line">    log.Printf(<span class="string">&quot;[Resume] task(%s) is resuming&quot;</span>, w.taskID)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="状态及结果获取"><a href="#状态及结果获取" class="headerlink" title="状态及结果获取"></a>状态及结果获取</h3><p>状态获取：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *WlcTask)</span></span> StatusHandler() (status <span class="type">string</span>, currDepth <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> w.status, w.currDepth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果获取：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ResultHandler</span><span class="params">(taskID <span class="type">string</span>)</span></span> (links []<span class="type">string</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    f, err := ioutil.ReadFile(taskID + <span class="string">&quot;.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    links = strings.Split(<span class="type">string</span>(f), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> links[:<span class="built_in">len</span>(links)<span class="number">-1</span>], <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2></li><li><p>本文使用的是channel控制整个流程，当换成标准库context时如何编写？</p></li><li><p>路由的地方有重复性的地方，考虑如何优化？</p></li><li><p>当前项目未自定义错误，如何完善整个项目的异常处理？</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;使用gin封装&quot;&gt;&lt;a href=&quot;#使用gin封装&quot; class=&quot;headerlink&quot; title=&quot;使用gin封装&quot;&gt;&lt;/a&gt;使用gin封装&lt;/h2&gt;&lt;p&gt;项目目录结构如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;api&lt;/code&gt;：主要业务逻辑实</summary>
      
    
    
    
    <category term="go" scheme="https://zcej.github.io/categories/go/"/>
    
    
  </entry>
  
  <entry>
    <title>go语言实现爬虫(一)</title>
    <link href="https://zcej.github.io/2021/09/06/go/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%EF%BC%9Ago%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%88%AC%E8%99%AB(%E4%B8%80)/"/>
    <id>https://zcej.github.io/2021/09/06/go/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%EF%BC%9Ago%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%88%AC%E8%99%AB(%E4%B8%80)/</id>
    <published>2021-09-06T11:47:11.000Z</published>
    <updated>2022-06-28T16:17:38.631Z</updated>
    
    <content type="html"><![CDATA[<p>本项目适合在快速学习完go语言后的一个简单练手，主要达成以下功能：</p><ul><li>能够递归的抓取网页链接，通过递归深度进行控制停止</li><li>支持爬取的并发控制，超时处理，以及其执行过程的暂停与恢复</li><li>基于gin提供restful的api接口，包括启动，停止，暂停，恢复，查看状态，获取结果等</li><li>提供grpc远程调用功能，并调研grpc-gateway，简单做一个学习案例<blockquote><p>注：本文仅总结了重要的部分，还需不断进行完善，具体项目点击<a href="https://gitee.com/cejz/web-link-crawler.git">链接</a>查看。</p></blockquote></li></ul><h2 id="页面解析"><a href="#页面解析" class="headerlink" title="页面解析"></a>页面解析</h2><p>依赖模块<code>golang.org/x/net/html</code>，<code>Extract</code>函数向给定URL发起HTTP GET请求，解析HTML并返回HTML文档中存在的链接，如果要在此部分添加或删除规则，那么可以修改此函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Extract</span><span class="params">(url <span class="type">string</span>)</span></span> ([]<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    resp, err := http.Get(url)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> resp.StatusCode != http.StatusOK &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;getting %s: %s&quot;</span>, url, resp.Status)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    doc, err := html.Parse(resp.Body)</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;parsing %s as HTML: %v&quot;</span>, url, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> links []<span class="type">string</span></span><br><span class="line">    visitNode := <span class="function"><span class="keyword">func</span><span class="params">(n *html.Node)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> n.Type == html.ElementNode &amp;&amp; n.Data == <span class="string">&quot;a&quot;</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> _, a := <span class="keyword">range</span> n.Attr &#123;</span><br><span class="line">                <span class="keyword">if</span> a.Key != <span class="string">&quot;href&quot;</span> &#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                link, err := resp.Request.URL.Parse(a.Val)</span><br><span class="line">                <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="keyword">continue</span> <span class="comment">// ignore bad URLs</span></span><br><span class="line">                &#125;</span><br><span class="line">                links = <span class="built_in">append</span>(links, link.String())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    forEachNode(doc, visitNode, <span class="literal">nil</span>)</span><br><span class="line">    <span class="comment">//forEachNode(doc, startElement, endElement)</span></span><br><span class="line">    <span class="keyword">return</span> links, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forEachNode</span><span class="params">(n *html.Node, pre, post <span class="keyword">func</span>(n *html.Node)</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> pre != <span class="literal">nil</span> &#123;</span><br><span class="line">        pre(n)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> c := n.FirstChild; c != <span class="literal">nil</span>; c = c.NextSibling &#123;</span><br><span class="line">        forEachNode(c, pre, post)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> post != <span class="literal">nil</span> &#123;</span><br><span class="line">        post(n)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> depth <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startElement</span><span class="params">(n *html.Node)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n.Type == html.ElementNode &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%*s&lt;%s&gt;\n&quot;</span>, depth*<span class="number">2</span>, <span class="string">&quot;&quot;</span>, n.Data)</span><br><span class="line">        depth++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">endElement</span><span class="params">(n *html.Node)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n.Type == html.ElementNode &#123;</span><br><span class="line">        depth--</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%*s&lt;/%s&gt;\n&quot;</span>, depth*<span class="number">2</span>, <span class="string">&quot;&quot;</span>, n.Data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后再根据广度优先遍历的思想新建一个函数<code>breadthFirst</code>，breadthFirst对每个worklist元素调用f，并将返回的内容添加到worklist中，对每一个元素，最多调用一次f。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">breadthFirst</span><span class="params">(f <span class="keyword">func</span>(item <span class="type">string</span>)</span></span> []<span class="type">string</span>, worklist []<span class="type">string</span>) &#123;</span><br><span class="line">    seen := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(worklist) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        items := worklist</span><br><span class="line">        worklist = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">for</span> _, item := <span class="keyword">range</span> items &#123;</span><br><span class="line">            <span class="keyword">if</span> !seen[item] &#123;</span><br><span class="line">                seen[item] = <span class="literal">true</span></span><br><span class="line">                worklist = <span class="built_in">append</span>(worklist, f(item)...)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">crawl</span><span class="params">(urlStr <span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    fmt.Println(urlStr)</span><br><span class="line">    list, err := links.Extract(urlStr)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Print(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//// extract same domain</span></span><br><span class="line">    <span class="comment">//var filterList []string</span></span><br><span class="line">    <span class="comment">//u, _ := url.Parse(urlStr)</span></span><br><span class="line">    <span class="comment">//for _, link := range list &#123;</span></span><br><span class="line">    <span class="comment">//  l, _ := url.Parse(link)</span></span><br><span class="line">    <span class="comment">//  if u.Hostname() == l.Hostname() &#123;</span></span><br><span class="line">    <span class="comment">//      filterList = append(filterList, link)</span></span><br><span class="line">    <span class="comment">//  &#125;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    urls := []<span class="type">string</span>&#123;<span class="string">&quot;http://www.xxxx.com&quot;</span>&#125;</span><br><span class="line">    breadthFirst(crawl, urls)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><p>在go语言中实现并发较为简单，只需要在函数定义前加上关键字go即可。对于爬虫而言，过高的并行度也不是一个好的做法，如何合理的控制并发速率也成为了当前需要控制的重点，下面介绍两种并发控制方式。</p><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><p>利用有缓冲的channel控制并发，并灵活的通过一个计数器n来控制程序自动结束。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tokens is a counting semaphore used to</span></span><br><span class="line"><span class="comment">// enforce a limit of 20 concurrent requests.</span></span><br><span class="line"><span class="keyword">var</span> tokens = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">crawl</span><span class="params">(url <span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    fmt.Println(url)</span><br><span class="line">    tokens &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// acquire a token</span></span><br><span class="line">    list, err := links.Extract(url)</span><br><span class="line">    &lt;-tokens <span class="comment">// release the token</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Print(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    worklist := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="type">string</span>)</span><br><span class="line">    <span class="keyword">var</span> n <span class="type">int</span></span><br><span class="line">    url := <span class="string">&quot;http://www.xxxx.com&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// start</span></span><br><span class="line">    n++</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; worklist &lt;- []<span class="type">string</span>&#123;url&#125; &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// crawl the web concurrently</span></span><br><span class="line">    visited := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> ; n &gt; <span class="number">0</span>; n-- &#123;</span><br><span class="line">        list := &lt;-worklist</span><br><span class="line">        <span class="keyword">for</span> _, link := <span class="keyword">range</span> list &#123;</span><br><span class="line">            <span class="keyword">if</span> !visited[link] &#123;</span><br><span class="line">                visited[link] = <span class="literal">true</span></span><br><span class="line">                n++</span><br><span class="line">                <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(link <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">                    worklist &lt;- crawl(link)</span><br><span class="line">                &#125;(link)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p>使用一定数量常驻goroutine控制并发，并在channel中没有数据后一定时间内超时退出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    worklist := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="type">string</span>)  <span class="comment">// lists of URLs, may have duplicates</span></span><br><span class="line">    unseenLinks := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>) <span class="comment">// de-duplicated URLs</span></span><br><span class="line">    <span class="comment">// Add command-line arguments to worklist.</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; worklist &lt;- os.Args[<span class="number">1</span>:] &#125;()</span><br><span class="line">    <span class="comment">// Create 20 crawler goroutines to fetch each unseen link.</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> link := <span class="keyword">range</span> unseenLinks &#123;</span><br><span class="line">                foundLinks := crawl(link)</span><br><span class="line">                <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; worklist &lt;- foundLinks &#125;()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// The main goroutine de-duplicates worklist items</span></span><br><span class="line">    <span class="comment">// and sends the unseen ones to the crawlers.</span></span><br><span class="line">    seen := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> list := &lt;-worklist &#123;</span><br><span class="line">            <span class="keyword">for</span> _, link := <span class="keyword">range</span> list &#123;</span><br><span class="line">                <span class="keyword">if</span> !seen[link] &#123;</span><br><span class="line">                    seen[link] = <span class="literal">true</span></span><br><span class="line">                    unseenLinks &lt;- link</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> &lt;- time.After(<span class="number">3</span> * time.Second)</span><br><span class="line">            fmt.Println(<span class="string">&quot;Exit, timeout&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="递归深度"><a href="#递归深度" class="headerlink" title="递归深度"></a>递归深度</h2><p>要控制抓取的递归深度可以从crawl函数入手，将url进行封装，添加一个depth属性，当获取这个url的下一层链接时则对depth进行加一。另外还需添加一个信号控制channel，当递归层数满足要求时，发送信号控制程序退出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> work <span class="keyword">struct</span> &#123;</span><br><span class="line">    url   <span class="type">string</span></span><br><span class="line">    depth <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">crawl</span><span class="params">(w work, quit <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> []work &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;depth: %d, url: %s\n&quot;</span>, w.depth, w.url)</span><br><span class="line">    <span class="keyword">if</span> w.depth &gt; <span class="number">3</span> &#123;</span><br><span class="line">        quit &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    urls, err := links.Extract(w.url)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Print(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> works []work</span><br><span class="line">    <span class="keyword">for</span> _, url := <span class="keyword">range</span> urls &#123;</span><br><span class="line">        works = <span class="built_in">append</span>(works, work&#123;url, w.depth + <span class="number">1</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> works</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本项目适合在快速学习完go语言后的一个简单练手，主要达成以下功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;能够递归的抓取网页链接，通过递归深度进行控制停止&lt;/li&gt;
&lt;li&gt;支持爬取的并发控制，超时处理，以及其执行过程的暂停与恢复&lt;/li&gt;
&lt;li&gt;基于gin提供restful的api</summary>
      
    
    
    
    <category term="go" scheme="https://zcej.github.io/categories/go/"/>
    
    
  </entry>
  
  <entry>
    <title>go语言中string和[]byte之间的转换</title>
    <link href="https://zcej.github.io/2021/08/29/go/go%E8%AF%AD%E8%A8%80%E4%B8%ADstring%E5%92%8C[]byte%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/"/>
    <id>https://zcej.github.io/2021/08/29/go/go%E8%AF%AD%E8%A8%80%E4%B8%ADstring%E5%92%8C[]byte%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/</id>
    <published>2021-08-29T14:52:38.000Z</published>
    <updated>2022-06-28T16:22:22.880Z</updated>
    
    <content type="html"><![CDATA[<p>在项目实际运用中发现数据量较大时，通过pprof进行性能分析发现string到byte的标准转换内存消耗十分大，后使用了unsafe包进行强转后性能有了很大的提升，在此记录下。</p><h2 id="转换方式"><a href="#转换方式" class="headerlink" title="转换方式"></a>转换方式</h2><h3 id="标准转换"><a href="#标准转换" class="headerlink" title="标准转换"></a>标准转换</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string to []byte</span></span><br><span class="line">s1 := <span class="string">&quot;hello&quot;</span></span><br><span class="line">b := []<span class="type">byte</span>(s1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// []byte to string</span></span><br><span class="line">s2 := <span class="type">string</span>(b)</span><br></pre></td></tr></table></figure><h3 id="强转换"><a href="#强转换" class="headerlink" title="强转换"></a>强转换</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">string2bytes</span><span class="params">(s <span class="type">string</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *(*[]<span class="type">byte</span>)(unsafe.Pointer(&amp;s))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bytes2string</span><span class="params">(b []<span class="type">byte</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *(*<span class="type">string</span>)(unsafe.Pointer(&amp;b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark_NormalString2Bytes</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    x := <span class="string">&quot;Test Normal String 2 Bytes With Go!&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        _ = []<span class="type">byte</span>(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark_Bytes2String</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    x := []<span class="type">byte</span>(<span class="string">&quot;Test Unsafe Bytes 2 String With Go!&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        _ = bytes2string(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark_NormalString2Bytes</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    x := <span class="string">&quot;Test Normal String 2 Bytes With Go!&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        _ = []<span class="type">byte</span>(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark_String2Bytes</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    x := <span class="string">&quot;Test Normal String 2 Bytes With Go!&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        _ = string2bytes(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">D:\goproject\study_go\study_unsafe\test_byte_string&gt;go test -bench=&quot;.&quot; -benchmem</span><br><span class="line">goos: windows</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: study_go/study_unsafe/test_byte_string</span><br><span class="line">cpu: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz</span><br><span class="line">Benchmark_NormalBytes2String-12         43473496                28.20 ns/op           48 B/op          1 allocs/op</span><br><span class="line">Benchmark_Bytes2String-12               1000000000               0.2593 ns/op          0 B/op          0 allocs/op</span><br><span class="line">Benchmark_NormalString2Bytes-12         31570804                35.06 ns/op           48 B/op          1 allocs/op</span><br><span class="line">Benchmark_String2Bytes-12               1000000000               0.2626 ns/op          0 B/op          0 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok      study_go/study_unsafe/test_byte_string  4.436s</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>由上述可见，强转换性能明显优于标准转换</p></blockquote><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>首先需要了解<code>string</code>和<code>slice</code>的底层数据结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data <span class="type">uintptr</span></span><br><span class="line">    Len  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data <span class="type">uintptr</span></span><br><span class="line">    Len  <span class="type">int</span></span><br><span class="line">    Cap  <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>在go中，任何类型的指针*T都可以转化为unsafe.Pointer类型的指针，它可以存储任何变量的地址</li><li>unsafe.Pointer类型的指针也可以转换回普通指针，而且不必和之前的类型*T相同</li><li>unsafe.Pointer类型还可以转换为uintptr类型，该类型保存了指针所指向地址的数值，从而可以对地址进行数值计算。</li></ul></blockquote><h2 id="思考总结"><a href="#思考总结" class="headerlink" title="思考总结"></a>思考总结</h2><p>为什么强转换性能比标准转换好？</p><blockquote><p>对于标准转换，无论是从[]byte转string还是从string转[]byte都会涉及到底层数组的拷贝。而强转换是直接替换指针的指向，从而使得string和[]byte指向同一个底层数组。故后者的性能会更好</p></blockquote><p>在上述测试中，当数据较大时，标准转换会有一次分配内存的操作，从而导致其性能更差，而为什么强转换不受影响？</p><blockquote><p>标准转换时，当数据长度大于32个字节时，需要通过mallocgc申请新的内存，之后再进行数据拷贝工作。而强转换只是更改指针的指向。故当数据较大时，两者性能差距越明显。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在项目实际运用中发现数据量较大时，通过pprof进行性能分析发现string到byte的标准转换内存消耗十分大，后使用了unsafe包进行强转后性能有了很大的提升，在此记录下。&lt;/p&gt;
&lt;h2 id=&quot;转换方式&quot;&gt;&lt;a href=&quot;#转换方式&quot; class=&quot;headerl</summary>
      
    
    
    
    <category term="go" scheme="https://zcej.github.io/categories/go/"/>
    
    
  </entry>
  
  <entry>
    <title>go语言中的数据结构</title>
    <link href="https://zcej.github.io/2021/08/21/go/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://zcej.github.io/2021/08/21/go/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2021-08-21T15:01:04.000Z</published>
    <updated>2022-06-28T16:21:51.794Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr1 := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;    <span class="comment">// 显示指定数组大小</span></span><br><span class="line">arr2 := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span> ,<span class="number">3</span>&#125;  <span class="comment">// 使用[...]T声明数组</span></span><br></pre></td></tr></table></figure><blockquote><p><code>[...]T</code>初始化数组的方式是go语言提供的一种语法糖，最终也会转化为具体元素数量</p></blockquote><p>在不考虑逃逸分析的情况下，如果数组中元素个数小于等于4个，则所有的变量会直接在栈上初始化；反之如果数组元素大于4个，变量就会在静态存储去初始化然后拷贝到栈上。</p><h3 id="访问和赋值"><a href="#访问和赋值" class="headerlink" title="访问和赋值"></a>访问和赋值</h3><ul><li>无论是在栈上还是静态存储区，数组在内存中都是一连串的内存空间。我们通过指向数组开头的指针、元素的数量以及元素类型占的空间大小表示数组。</li><li>数组和字符串的一些简单的越界错误都会在编译期间发现。如使用整数或常量访问数组，但是如果使用变量去访问数组或字符串时，编译器就无法提前发现错误，此时会在运行时阻止不合法的访问。<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3>对数组的访问和赋值同时需要依赖编译器和运行时支持，其大多数操作在编译期间都会转换成直接读写内存，在中间代码生成期间，编译器还会插入运行时方法<code>runtime.panicIndex</code>防止发生越界错误。<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3>切片在运行时由<code>reflect.SliceHeader</code>结构体表示，如下：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data <span class="type">uintptr</span>  <span class="comment">// 指向数组的指针</span></span><br><span class="line">    Len  <span class="type">int</span>      <span class="comment">// 当前切片的长度</span></span><br><span class="line">    Cap  <span class="type">int</span>      <span class="comment">// 当前切片的容量, 即Data数组的大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3>有以下三种初始化切片的方式：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 通过下标的方式获得数组或切片的一部分</span></span><br><span class="line">arr[<span class="number">0</span>:<span class="number">3</span>] or slice[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用字面量初始化新的切片</span></span><br><span class="line">slice := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用make关键字</span></span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><blockquote><ul><li>使用下标：使用下标初始化切片不会拷贝原数组或原切片中的数据，它只会创建一个指向原数组的切片结构体，所以修改新切片的数据也会修改原切片。</li><li>使用字面量：根据切片中的元素数量对底层数组的大小进行推断并创建一个数组，将字面量元素存储到初始化的数组中，创建一个同样指向相同类型的数组指针，将初始化的数组赋值给指针所在的地址，通过[:]操作获取一个底层使用该地址的切片。</li></ul></blockquote></li></ul><h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><p>切片的操作基本都是在编译期间完成的，除了访问切片的长度、容量或者其中的元素之外，编译期间也会将包含<code>range</code>关键字的遍历转换成形式更简单的循环。</p><h3 id="追加和扩容"><a href="#追加和扩容" class="headerlink" title="追加和扩容"></a>追加和扩容</h3><p>当切片容量不足时，会调用<code>runtime.growslice</code>进行切片扩容。扩容是为切片分配新的内存空间并拷贝原切片中元素的过程，那么新切片的容量如何确定呢？</p><ul><li>如果期望容量大于当前容量的两倍就会使用当前容量</li><li>如果当前切片的长度小于1024就会将容量翻倍</li><li>如果当前切片的长度大于1024就会每次增加25%的容量，直到新容量大于期望容量</li></ul><p>另外上述调用仅会确定切片的大致容量，还需要根据切片中的元素大小进行内存对齐。</p><h3 id="拷贝切片"><a href="#拷贝切片" class="headerlink" title="拷贝切片"></a>拷贝切片</h3><p>无论是编译期间拷贝还是运行时拷贝，两种拷贝方式都会通过<code>runtime.memmove</code>将整块内存的内容拷贝到目标的内存区域中，相比于依次拷贝元素，<code>runtime.memmove</code>能提供更好的性能。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>切片的很多功能都是由运行时实现的，无论是初始化切片，还是对切片进行追加或扩容都需要运行时的支持，需要注意的是在遇到大切片扩容或者复制时可能会发生大规模的内存拷贝，一定要减少类似的操作避免影响程序的性能。</p><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><h3 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h3><p>开放寻址法<br>拉链法</p><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><p>go语言运行时使用了多个数据结构组合表示哈希表，最核心的结构体<code>runtime.hmap</code>如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    count     <span class="type">int</span>  <span class="comment">// 表示当前哈希表中的元素数量</span></span><br><span class="line">    flags     <span class="type">uint8</span></span><br><span class="line">    B         <span class="type">uint8</span>  <span class="comment">// 表示当前哈希表持有的buckets数量(都是2的倍数)</span></span><br><span class="line">    noverflow <span class="type">uint16</span></span><br><span class="line">    hash0     <span class="type">uint32</span>  <span class="comment">// 哈希种子，为哈希函数的结果引入随机性</span></span><br><span class="line"></span><br><span class="line">    buckets    unsafe.Pointer</span><br><span class="line">    oldbuckets unsafe.Pointer  <span class="comment">// 扩容时用于保存之前buckets字段</span></span><br><span class="line">    nevacuate  <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line">    extra *mapextra</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mapextra <span class="keyword">struct</span> &#123;</span><br><span class="line">    overflow    *[]*bmap</span><br><span class="line">    oldoverflow *[]*bmap</span><br><span class="line">    nextOverflow *bmap</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示哈希表<code>runtime.hmap</code>的桶是<code>runtime.bmap</code>，每一个<code>runtime.bmap</code>都能存储8个键值对。当哈希表中存储的数据过多，单个桶已经装满时就会使用<code>extra.nextOverflow</code>中桶存储溢出的数据。<br>这两种不同的桶在内存中都是连续的，分别称之为正常桶和溢出桶</p><h3 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h3><p>字面量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hash := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;</span><br><span class="line">    <span class="string">&quot;1&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&quot;2&quot;</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="string">&quot;5&quot;</span>: <span class="number">6</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用字面量初始化的过程都会使用go语言中的关键字make来创建新的哈希并通过最原始的[]语法向哈希追加元素，另外最终都是调用runtime.makemap。</p></blockquote><h3 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h3><p>扩容<br>在以下两种情况下会进行扩容：</p><ol><li>装载因子已经超过6.5</li><li>哈希使用了太多溢出桶</li></ol><p>小结</p><ul><li>go语言使用了拉链法来解决哈希碰撞的问题实现了哈希表，它的读写等操作都是在编译期间转换成了运行时的函数或方法。哈希在每一个桶中存储键对应哈希的前8位，当对哈希进行操作时，这些tophash就成为可以帮助哈希快速遍历桶中元素的缓存。</li><li>哈希表的每个桶都只能存储8个键值对，一旦当前哈希的某个桶超出8个，新的键值对就会存储到哈希的溢出桶中。随着键值对数量的增加，溢出桶的数量和哈希的装载因子也会逐渐升高，超过一定范围就会触发扩容，扩容会将桶的数量翻倍，元素再分配的过程也是在调用写操作时增量进行的，不会造成性能的瞬时巨大抖动。<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h3>字符串在运行时会使用如下的<code>reflect.StringHeader</code>表示：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data <span class="type">uintptr</span>  <span class="comment">// 指向字节数组的指针</span></span><br><span class="line">    Len  <span class="type">int</span>      <span class="comment">// 数组的大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>字符串是只读的类型，我们并不会直接向字符串追加元素改变其本身的内存空间，所有字符串上的写入操作都是<br>通过拷贝实现的。</p></blockquote></li></ul><h3 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str1 := <span class="string">&quot;this is a string&quot;</span></span><br><span class="line">str2 := <span class="string">`this is another</span></span><br><span class="line"><span class="string">string</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul><li>当解析和序列化json等数据格式时，经常需要将数据在<code>string</code>和<code>[]byte</code>之间来回转换，而类型转换的开销并没有想象的那么小。</li><li>字符串和<code>[]byte</code>中的内容虽然一样，但是字符串的内容是只读的，我们不能通过下标或者其他形式改变其中的数据，而跑<code>[]byte</code>中的内容是可读写的。不过无论从哪种类型转换到另一种都需要拷贝数据，而内存拷贝的性能损耗会随着字符串和<code>[]byte</code>长度的增长而增长。<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3>字符串作为只读的数据类型，我们无法改变其本身的结构，但是在做拼接和类型转换等操作时一定要注意性能的损耗，遇到需要极致性能的场景一定要尽量减少类型转换的次数。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h2&gt;&lt;h3 id=&quot;初始化&quot;&gt;&lt;a href=&quot;#初始化&quot; class=&quot;headerlink&quot; title=&quot;初始化&quot;&gt;&lt;/a&gt;初始化&lt;/h3&gt;&lt;f</summary>
      
    
    
    
    <category term="go" scheme="https://zcej.github.io/categories/go/"/>
    
    
  </entry>
  
  <entry>
    <title>go语言中make和new的区别</title>
    <link href="https://zcej.github.io/2021/08/03/go/go%E8%AF%AD%E8%A8%80%E4%B8%ADmake%E5%92%8Cnew%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://zcej.github.io/2021/08/03/go/go%E8%AF%AD%E8%A8%80%E4%B8%ADmake%E5%92%8Cnew%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2021-08-03T13:11:27.000Z</published>
    <updated>2022-05-23T01:08:55.098Z</updated>
    
    <content type="html"><![CDATA[<ul><li><code>make</code>用于初始化内置的数据结构，如slice，map，channel</li><li><code>new</code>的作用是根据传入的类型分配一片内存空间并返回指向这片内存空间的指针<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">hash := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>, <span class="number">10</span>)</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><blockquote><ol><li><code>slice</code>是一个包含data，cap和len的结构体<code>reflect.SliceHeader</code></li><li><code>hash</code>是一个指向<code>runtime.hmap</code>结构体的指针</li><li><code>ch</code>是一个指向<code>runtime.hchan</code>结构体的指针</li></ol></blockquote></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v <span class="type">int</span></span><br><span class="line">i := &amp;v</span><br></pre></td></tr></table></figure><p>上述代码片段两种初始化方法是等价的，它们都会创建一个指向int零值的指针<br><a name="EFB5f"></a></p><h2 id="make"><a href="#make" class="headerlink" title="make"></a>make</h2><p>在编译期间的类型检查阶段，go语言会将代表<code>make</code>关键字的<code>OMAKE</code>节点根据参数类型的不同转换成了<code>OMAKESLICE</code>、<code>OMAKEMAP</code>和<code>OMAKECHAN</code>三种不同类型的节点，这些节点会调用不同的运行时函数来初始化相应的数据结构。<br><a name="pCKld"></a></p><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p>编译器会在中间代码生成阶段通过以下两个函数处理该关键字：</p><ol><li><code>cmd/compile/internal/gc.callnew</code>会将关键字转换成<code>ONEWOBJ</code>类型的节点</li><li><code>cmd/complie/internal/gc.state.expr</code>会根据申请空间的大小分两种情况处理<ol><li>如果申请的空间为0，就会返回一个表示空指针的<code>zerobase</code>变量</li><li>在遇到其他情况时会将关键字转换成<code>runtime.newobject</code>函数<br><a name="u9JKg"></a><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2>简单总结一下go语言中<code>make</code>和<code>new</code>关键字的实现原理，<code>make</code>关键字的作用是创建切片、哈希表和Channel等内置的数据结构，而<code>new</code>的作用是为类型申请一片内存空间，并返回指向这片内存的指针。</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;code&gt;make&lt;/code&gt;用于初始化内置的数据结构，如slice，map，channel&lt;/li&gt;
&lt;li&gt;&lt;code&gt;new&lt;/code&gt;的作用是根据传入的类型分配一片内存空间并返回指向这片内存空间的指针&lt;figure class=&quot;highlight</summary>
      
    
    
    
    <category term="go" scheme="https://zcej.github.io/categories/go/"/>
    
    
  </entry>
  
  <entry>
    <title>在Django中使用缓存</title>
    <link href="https://zcej.github.io/2020/08/16/django/%E5%9C%A8Django%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98/"/>
    <id>https://zcej.github.io/2020/08/16/django/%E5%9C%A8Django%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98/</id>
    <published>2020-08-16T04:19:21.000Z</published>
    <updated>2022-06-28T16:26:28.416Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><h2 id="缓存是什么-What"><a href="#缓存是什么-What" class="headerlink" title="缓存是什么(What?)"></a>缓存是什么(What?)</h2><blockquote><p>缓存就是数据交换的缓冲区(称作Cache)，是存储数据的临时地方。当用户查询数据，首先在缓存中寻找，如果找到了则直接执行。如果找不到，则去数据库查找。</p><p>缓存的本质就是用空间换时间，牺牲数据的实时性，以服务器内存中的数据暂时代替从数据库读取的数据，减少数据库IO，减轻服务器压力，减少网络延迟，加快页面打开速度。</p></blockquote><p>存储介质访问速度比较　来自Google工程师Jeff Dean的分享，仅供参考：</p><table><thead><tr><th><strong>存储介质</strong></th><th><strong>速度</strong></th></tr></thead><tbody><tr><td>L1 cache reference 读取CPU的一级缓存</td><td>0.5 ns</td></tr><tr><td>Branch mispredict(转移、分支预测)</td><td>5 ns</td></tr><tr><td>L2 cache reference 读取CPU的二级缓存</td><td>7 ns</td></tr><tr><td>Mutex lock&#x2F;unlock 互斥锁\解锁</td><td>100 ns</td></tr><tr><td>Main memory reference 读取内存数据</td><td>100 ns</td></tr><tr><td>Compress 1K bytes with Zippy 1k字节压缩</td><td>10,000 ns</td></tr><tr><td>Send 2K bytes over 1 Gbps network 在1Gbps的网络上发送2k字节</td><td>20,000 ns</td></tr><tr><td>Read 1 MB sequentially from memory 从内存顺序读取1MB</td><td>250,000 ns</td></tr><tr><td>Round trip within same datacenter 从一个数据中心往返一次，ping一下</td><td>500,000 ns</td></tr><tr><td>Disk seek 磁盘搜索</td><td>10,000,000 ns</td></tr><tr><td>Read 1 MB sequentially from network从网络上顺序读取1兆的数据</td><td>10,000,000 ns</td></tr><tr><td>Read 1 MB sequentially from disk 从磁盘里面读出1MB</td><td>30,000,000 ns</td></tr><tr><td>Send packet CA-&gt;Netherlands-&gt;CA 一个包的一次远程访问</td><td>150,000,000 ns</td></tr></tbody></table><p>访问流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">A(读操作_) --&gt; B&#123;查询缓存_&#125;</span><br><span class="line">B --&gt; |有缓存_| C[返回_]</span><br><span class="line"></span><br><span class="line">B --&gt; |无缓存_| D[查询数据库_]</span><br><span class="line"></span><br><span class="line">D --&gt; E[放入缓存_]</span><br></pre></td></tr></table></figure><p>缓存的优点:</p><ol><li>减少了磁盘和网络IO来提高吞吐量，减少计算量(CPU计算)释放CPU，提高系统的响应速度。</li><li>面向切面的处理发出，可以在各层进行插拔，是所有性能优化的最简单有效的解决方案。</li></ol><h2 id="缓存应用场景-Where"><a href="#缓存应用场景-Where" class="headerlink" title="缓存应用场景(Where?)"></a>缓存应用场景(Where?)</h2><ul><li><p>对于数据实时性要求不高<br>对于一些经常访问但是很少改变的数据，读明显多于写，使用缓存就很有必要。比如一些网站配置项。</p></li><li><p>对于性能要求高<br>比如一些秒杀活动场景。</p></li></ul><h2 id="基于DRF快速开始-How"><a href="#基于DRF快速开始-How" class="headerlink" title="基于DRF快速开始(How?)"></a>基于DRF快速开始(How?)</h2><p><code>pip install drf-extensions</code>  </p><blockquote><p>key值计算: {“view_instance”: “”, “view_method”: “”, “request”:””, “args”:””, “kwargs”: “”} –&gt; json –&gt; md5<br><code>\rest_framework_extensions\key_constructor\constructors.py</code>  </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># settings.py  </span></span><br><span class="line">REST_FRAMEWORK_EXTENSIONS = &#123;  </span><br><span class="line">    <span class="string">&#x27;DEFAULT_OBJECT_CACHE_KEY_FUNC&#x27;</span>:  </span><br><span class="line">        <span class="string">&#x27;rest_framework_extensions.utils.default_object_cache_key_func&#x27;</span>,  </span><br><span class="line">    <span class="string">&#x27;DEFAULT_LIST_CACHE_KEY_FUNC&#x27;</span>:  </span><br><span class="line">        <span class="string">&#x27;rest_framework_extensions.utils.default_list_cache_key_func&#x27;</span>,  </span><br><span class="line">    <span class="string">&#x27;DEFAULT_CACHE_RESPONSE_TIMEOUT&#x27;</span>: <span class="number">60</span> * <span class="number">15</span>,  </span><br><span class="line">    <span class="string">&#x27;DEFAULT_CACHE_ERRORS&#x27;</span>: <span class="literal">False</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># views.py  </span></span><br><span class="line"><span class="comment"># usage 1: don&#x27;t overwirte list, retrieve method  </span></span><br><span class="line"><span class="keyword">from</span> rest_framework_extensions.cache.mixins <span class="keyword">import</span> CacheResponseMixin  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StudentViewSet</span>(CacheResponseMixin, viewsets.ModelViewSet):  </span><br><span class="line">    <span class="keyword">pass</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># usage: 2  </span></span><br><span class="line"><span class="keyword">from</span> rest_framework_extensions.cache.decorators <span class="keyword">import</span> cache_response  </span><br><span class="line"><span class="keyword">from</span> rest_framework_extensions.utils <span class="keyword">import</span> default_object_cache_key_func  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StudentViewSet</span>(CacheResponseMixin, viewsets.ModelViewSet):  </span><br><span class="line">  </span><br><span class="line"><span class="meta">    @cache_response(<span class="params">key_func=default_object_cache_key_func, cache_errors=<span class="literal">False</span></span>)  </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">retrieve</span>(<span class="params">self, request, *args, **kwargs</span>):  </span><br><span class="line">        <span class="keyword">pass</span>  </span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">&gt; python自带的缓存机制</span><br><span class="line">```python</span><br><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"></span><br><span class="line"><span class="comment"># @lru_cache(None)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n</span>):  </span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:  </span><br><span class="line">        <span class="keyword">return</span> n  </span><br><span class="line">    <span class="keyword">return</span> fib(n - <span class="number">2</span>) + fib(n - <span class="number">1</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(timeit.timeit(<span class="keyword">lambda</span>: fib(<span class="number">35</span>), number=<span class="number">1</span>))</span><br></pre></td></tr></table></figure><h1 id="一、缓存类型"><a href="#一、缓存类型" class="headerlink" title="一、缓存类型"></a>一、缓存类型</h1><h2 id="1-数据库缓存"><a href="#1-数据库缓存" class="headerlink" title="1. 数据库缓存"></a>1. 数据库缓存</h2><blockquote><p>常用的缓存方案有memcached、redis等 。把经常要从数据库查询的数据，或经常更新的数据放入到缓存中。这样下次查询时，直接从缓存直接返回，减轻数据库压力，提升数据库性能。</p></blockquote><h2 id="2-服务器端缓存"><a href="#2-服务器端缓存" class="headerlink" title="2. 服务器端缓存"></a>2. 服务器端缓存</h2><h3 id="2-1-代理服务器缓存"><a href="#2-1-代理服务器缓存" class="headerlink" title="2.1 代理服务器缓存"></a>2.1 代理服务器缓存</h3><blockquote><p>代理服务器是浏览器和源服务器之间的中间服务器，浏览器先向这个中间服务器发起Web请求，经过处理后(比如权限验证，缓存匹配等)，再将请求转发到源服务器。  </p><p>代理服务器缓存的运作原理跟浏览器的运作原理差不多，只是规模更大。可以把它理解为一个共享缓存，不只为一个用户服务，一般为大量用户提供服务，因此在减少响应时间和带宽使用方面很有效，同一个副本会被重用多次。</p></blockquote><h3 id="2-2-CDN缓存"><a href="#2-2-CDN缓存" class="headerlink" title="2.2 CDN缓存"></a>2.2 CDN缓存</h3><blockquote><p>也叫网关缓存、反向代理缓存。CDN缓存一般是由网站管理员自己部署，为了让他们的网站更容易扩展并获得更好的性能。</p><p>浏览器先向CDN网关发起Web请求，网关服务器后面对应着一台或多台负载均衡源服务器，会根据它们的负载请求，动态将请求转发到合适的源服务器上。  </p><p>虽然这种架构负载均衡源服务器之间的缓存没法共享，但却拥有更好的处扩展性。从浏览器角度来看，整个CDN就是一个源服务器。</p></blockquote><h3 id="2-3-DNS缓存"><a href="#2-3-DNS缓存" class="headerlink" title="2.3 DNS缓存"></a>2.3 DNS缓存</h3><blockquote><p>万维网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。DNS协议运行在UDP协议之上，使用端口号53。</p></blockquote><p><strong>有dns的地方,就有缓存。浏览器、操作系统、Local DNS、根域名服务器，它们都会对DNS结果做一定程度的缓存。</strong></p><p>DNS查询过程如下:</p><ol><li>首先搜索浏览器自身的DNS缓存,如果存在，则域名解析到此完成。</li><li>如果浏览器自身的缓存里面没有找到对应的条目，那么会尝试读取操作系统的hosts文件看是否存在对应的映射关系,如果存在，则域名解析到此完成。</li><li>如果本地hosts文件不存在映射关系，则查找本地DNS服务器(ISP服务器,或者自己手动设置的DNS服务器),如果存在,域名到此解析完成。</li><li>如果本地DNS服务器还没找到的话,它就会向根服务器发出请求,进行递归查询。</li></ol><h2 id="3-浏览器缓存"><a href="#3-浏览器缓存" class="headerlink" title="3. 浏览器缓存"></a>3. 浏览器缓存</h2><blockquote><p>浏览器缓存根据一套与服务器约定的规则进行工作，在同一个会话过程中会检查一次并确定缓存的副本足够新。如果在浏览过程中前进或后退时访问到同一个图片，这些图片可以从浏览器缓存中调出而即时显示。</p></blockquote><h2 id="4-web应用层缓存"><a href="#4-web应用层缓存" class="headerlink" title="4. web应用层缓存"></a>4. web应用层缓存</h2><blockquote><p> 应用层缓存指的是从代码层面上，通过代码逻辑和缓存策略，实现对数据、页面、图片等资源的缓存，可以根据实际情况选择将数据存在文件系统或者内存中，减少数据库查询或者读写瓶颈，提高响应效率。</p></blockquote><h1 id="二、缓存淘汰策略"><a href="#二、缓存淘汰策略" class="headerlink" title="二、缓存淘汰策略"></a>二、缓存淘汰策略</h1><h2 id="1-FIFO"><a href="#1-FIFO" class="headerlink" title="1. FIFO"></a>1. FIFO</h2><p>FIFO (First in First out)， 先进先出。核心原则就是: 如果一个数据最先进入缓存中，则应最早淘汰掉。  </p><h2 id="2-LFU"><a href="#2-LFU" class="headerlink" title="2. LFU"></a>2. LFU</h2><p>LFU (Least Frequently Used)，最不频繁使用，以使用次数作为参考。  </p><blockquote><p>核心思想：<strong>如果数据过去被访问多次，那么将来被访问的几率也更高</strong>。</p></blockquote><h2 id="3-LRU"><a href="#3-LRU" class="headerlink" title="3. LRU"></a>3. LRU</h2><p>LRU(Least Recently Used)，最近最少使用，以时间作为参考。</p><blockquote><p>核心思想：<strong>如果数据最近被访问过，那么将来被访问的频率也更高</strong></p></blockquote><h1 id="三、Django缓存系统"><a href="#三、Django缓存系统" class="headerlink" title="三、Django缓存系统"></a>三、Django缓存系统</h1><p>伪代码解释动态网站生成页面时，缓存是怎么工作的  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">given a URL, <span class="keyword">try</span> finding that page <span class="keyword">in</span> the cache  </span><br><span class="line"><span class="keyword">if</span> the page <span class="keyword">is</span> <span class="keyword">in</span> the cache:  </span><br><span class="line">    <span class="keyword">return</span> the cached page  </span><br><span class="line"><span class="keyword">else</span>:  </span><br><span class="line">    generate the page  </span><br><span class="line">    save the generated page <span class="keyword">in</span> the cache (<span class="keyword">for</span> <span class="built_in">next</span> time)  </span><br><span class="line">    <span class="keyword">return</span> the generated page  </span><br><span class="line">```  </span><br><span class="line"><span class="comment">## 设置缓存  </span></span><br><span class="line"><span class="comment">### django-redis  </span></span><br><span class="line">- 更多详细配置参阅[官方文档](https://github.com/jazzband/django-redis)</span><br><span class="line">- `pip install django-redis`</span><br><span class="line">  </span><br><span class="line">```python</span><br><span class="line">CACHES = &#123;</span><br><span class="line">    <span class="string">&quot;default&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;BACKEND&quot;</span>: <span class="string">&quot;django_redis.cache.RedisCache&quot;</span>,</span><br><span class="line">        <span class="string">&quot;LOCATION&quot;</span>: <span class="string">&quot;redis://127.0.0.1:6379/1&quot;</span>,</span><br><span class="line">        <span class="comment"># &quot;LOCATION&quot;: &quot;redis://username:password@localhost:6379/0&quot;</span></span><br><span class="line">        <span class="string">&quot;OPTIONS&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;CLIENT_CLASS&quot;</span>: <span class="string">&quot;django_redis.client.DefaultClient&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="memcached"><a href="#memcached" class="headerlink" title="memcached"></a>memcached</h3><ul><li>完全基于内存的缓存服务器：  <blockquote><p>是Django支持的最快，最高效的缓存类型。—&gt; Facebook，Wikipedia都有使用其来减少数据库访问并显著提高网站性能<br>缓存的数据存储在内存中，如果服务器崩溃，那么数据将会丢失。  </p></blockquote></li><li><code>pip install python-memached</code>  </li><li><code>pip install pylibmc</code>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># use python-memcached  </span></span><br><span class="line">CACHES = &#123;  </span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: &#123;  </span><br><span class="line">        <span class="string">&#x27;BACKEND&#x27;</span>: <span class="string">&#x27;django.core.cache.backends.memcached.MemcachedCache&#x27;</span>,  </span><br><span class="line">        <span class="string">&#x27;LOCATION&#x27;</span>: <span class="string">&#x27;127.0.0.1:11211&#x27;</span>,  </span><br><span class="line">        <span class="comment"># &#x27;LOCATION&#x27;: &#x27;unix:/tmp/memcached.sock&#x27;,  </span></span><br><span class="line">      </span><br><span class="line">        <span class="comment"># 能在多个服务器上共享缓存，即无需再每台机器上复制缓存值  </span></span><br><span class="line">        <span class="comment"># &#x27;LOCATION&#x27;: [  </span></span><br><span class="line">        <span class="comment"># &#x27;172.19.26.240:11211&#x27;,  </span></span><br><span class="line">        <span class="comment"># &#x27;172.19.26.242:11211&#x27;,  </span></span><br><span class="line">        <span class="comment"># ]  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># use pylibmc  </span></span><br><span class="line">CACHES = &#123;  </span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: &#123;  </span><br><span class="line">        <span class="string">&#x27;BACKEND&#x27;</span>: <span class="string">&#x27;django.core.cache.backends.memcached.PyLibMCCache&#x27;</span>,  </span><br><span class="line">        <span class="string">&#x27;LOCATION&#x27;</span>: <span class="string">&#x27;/tmp/memcached.sock&#x27;</span>,  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">```  </span><br><span class="line"><span class="comment">### 数据库缓存  </span></span><br><span class="line">- 适用于有一个快速，索引正常的数据库服务器。  </span><br><span class="line">- `python manage.py createcachetable`  </span><br><span class="line">```python  </span><br><span class="line">CACHES = &#123;  </span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: &#123;  </span><br><span class="line">        <span class="string">&#x27;BACKEND&#x27;</span>: <span class="string">&#x27;django.core.cache.backends.db.DatabaseCache&#x27;</span>,  </span><br><span class="line">        <span class="string">&#x27;LOCATION&#x27;</span>: <span class="string">&#x27;my_cache_table&#x27;</span>,  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">```  </span><br><span class="line">  </span><br><span class="line"><span class="comment">### 文件系统缓存  </span></span><br><span class="line">- 一个缓存值为一个单独的文件  </span><br><span class="line">- 注意指定目的写权限问题。  </span><br><span class="line">```python  </span><br><span class="line">CACHES = &#123;  </span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: &#123;  </span><br><span class="line">        <span class="string">&#x27;BACKEND&#x27;</span>: <span class="string">&#x27;django.core.cache.backends.filebased.FileBasedCache&#x27;</span>,  </span><br><span class="line">        <span class="string">&#x27;LOCATION&#x27;</span>: <span class="string">&#x27;/var/tmp/django_cache&#x27;</span>,  </span><br><span class="line">        <span class="comment"># &#x27;LOCATION&#x27;: &#x27;c:/foo/bar&#x27;,  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">```  </span><br><span class="line">  </span><br><span class="line"><span class="comment">### 本地内存缓存  </span></span><br><span class="line">- 是默认的缓存方式  </span><br><span class="line">- 使用LRU淘汰策略  </span><br><span class="line">&gt; 每个进程都有其自己的私有缓存实例，意味着不存在跨进程的缓存。  </span><br><span class="line">&gt; 也意味着本地缓存不是特别节省内存，不是生产环境的好选择，但在开发环境表现很好。  </span><br><span class="line">```python  </span><br><span class="line">CACHES = &#123;  </span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: &#123;  </span><br><span class="line">        <span class="string">&#x27;BACKEND&#x27;</span>: <span class="string">&#x27;django.core.cache.backends.locmem.LocMemCache&#x27;</span>,  </span><br><span class="line">        <span class="string">&#x27;LOCATION&#x27;</span>: <span class="string">&#x27;unique-snowflake&#x27;</span>,  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">```  </span><br><span class="line">  </span><br><span class="line"><span class="comment">### 虚拟缓存(用于开发模式)  </span></span><br><span class="line">- 只是实现了缓存接口，并不做其他操作  </span><br><span class="line">- 如果你有一个正式网站在不同地方使用了重型缓存，但你不想在开发环境使用缓存时非常有用。  </span><br><span class="line">```python  </span><br><span class="line">CACHES = &#123;  </span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: &#123;  </span><br><span class="line">        <span class="string">&#x27;BACKEND&#x27;</span>: <span class="string">&#x27;django.core.cache.backends.dummy.DummyCache&#x27;</span>,  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">```  </span><br><span class="line">  </span><br><span class="line"><span class="comment">### 缓存参数  </span></span><br><span class="line">- **`TIMEOUT`**: 超时时间，默认为<span class="number">300</span>秒。设置为`<span class="literal">None</span>`表示永不过时。  </span><br><span class="line">- **`OPTIONS`**: 实现自有的淘汰策略的缓存后端（比如 `locmem`, `filesystem` 和 `database` 后端）将遵循以下选项  </span><br><span class="line">-- **`MAX_ENTRIES`**: 允许缓存的最大条目， 默认为<span class="number">300</span>。  </span><br><span class="line">-- **`CULL_FREQUENCY`**: 当达到最大条目时淘汰的条目数量，默认为<span class="number">3</span>。比率为<span class="number">1</span> / CULL_FREQUENCY，为<span class="number">0</span>是清空整个缓存。  </span><br><span class="line">- **`KEY_PREFIX`**: Django 服务器使用的所有缓存键的字符串。  </span><br><span class="line">- **`VERSION`**: 通过 Django 服务器生成的缓存键的默认版本号。  </span><br><span class="line">- **`KEY_FUNCTION`**: 一个包含指向函数的路径的字符串，该函数定义将如何前缀、版本和键组成最终的缓存键。  </span><br><span class="line">  </span><br><span class="line"><span class="comment">## 站点缓存  </span></span><br><span class="line">```python  </span><br><span class="line">MIDDLEWARE = [  </span><br><span class="line">    <span class="string">&#x27;django.middleware.cache.UpdateCacheMiddleware&#x27;</span>,  </span><br><span class="line">    <span class="string">&#x27;django.middleware.common.CommonMiddleware&#x27;</span>,  </span><br><span class="line">    <span class="string">&#x27;django.middleware.cache.FetchFromCacheMiddleware&#x27;</span>,  </span><br><span class="line">]  </span><br><span class="line">```  </span><br><span class="line">  </span><br><span class="line"><span class="comment">## 视图缓存  </span></span><br><span class="line">&gt; **cache_page**设置的缓存超时优先于Cache-Control头中的<span class="string">&quot;max_age&quot;</span></span><br><span class="line">&gt; 和缓存站点一样，对试图缓存以URL为键。如果多个URL指向相同的试图，每个URL将被单独缓存。</span><br><span class="line">```python  </span><br><span class="line"><span class="keyword">from</span> django.views.decorators.cache <span class="keyword">import</span> cache_page  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@cache_page(<span class="params"><span class="number">60</span> * <span class="number">15</span>, cache=<span class="string">&quot;default&quot;</span>, key_frefix=<span class="string">&quot;site1&quot;</span></span>)  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_view</span>(<span class="params">request</span>):  </span><br><span class="line">    <span class="keyword">pass</span>  </span><br><span class="line">```  </span><br><span class="line">  </span><br><span class="line"><span class="comment">## 底层缓存API  </span></span><br><span class="line">&gt; 以任意级别粒度在缓存中存储对象，如：模型对象的字符串、字典、列表，或者其他(pickle)。</span><br><span class="line"></span><br><span class="line"><span class="comment">### 访问缓存</span></span><br><span class="line">&gt; 可通过`django.core.cache.caches`对象访问在CACHES配置的缓存。</span><br><span class="line">&gt; 重复请求同一个线程里的同一个别名将返回同一个对象。</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="keyword">from</span> django.core.cache <span class="keyword">import</span> caches</span><br><span class="line"></span><br><span class="line">cache1 = caches[<span class="string">&#x27;myalias&#x27;</span>]</span><br><span class="line">cache2 = caches[<span class="string">&#x27;myalias&#x27;</span>]</span><br><span class="line">cache1 <span class="keyword">is</span> cache2  <span class="comment"># True</span></span><br></pre></td></tr></table></figure><blockquote><p>作为快捷方式，默认缓存可以通过<code>django.core.cache.cache</code>引用。<br>等价于<code>caches[&#39;default&#39;]</code></p></blockquote></li></ul><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ul><li><strong>cache.set</strong>(<em>key</em>, <em>value</em>, <em>timeout&#x3D;DEFAULT_TIMEOUT</em>, <em>version&#x3D;None</em>)</li><li><strong>cache.get</strong>(<em>key</em>, <em>default&#x3D;None</em>, <em>version&#x3D;None</em>)</li><li><strong>cache.add</strong>(<em>key</em>, <em>value</em>, <em>timeout&#x3D;DEFAULT_TIMEOUT</em>, <em>version&#x3D;None</em>)</li><li><strong>cache.get_or_set</strong>(<em>key</em>, <em>default</em>, <em>timeout&#x3D;DEFAULT_TIMEOUT</em>, <em>version&#x3D;None</em>)</li><li><strong>cache.get_many</strong>(<em>keys</em>, <em>version&#x3D;None</em>)</li><li><strong>cache.set_many</strong>(<em>dict</em>, <em>timeout</em>)</li><li><strong>cache.delete</strong>(<em>key</em>, <em>version&#x3D;None</em>)</li><li><strong>cache.delete_many</strong>(<em>keys</em>, <em>version&#x3D;None</em>)</li><li><strong>cache.clear</strong>()</li><li><strong>cache.touch</strong>(<em>key</em>, <em>timeout&#x3D;DEFAULT_TIMEOUT</em>, <em>version&#x3D;None</em>)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># delete cache</span></span><br><span class="line"><span class="keyword">from</span> django.core.cache <span class="keyword">import</span> cache</span><br><span class="line"><span class="keyword">from</span> django.utils.cache <span class="keyword">import</span> get_cache_key</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StudentViewSet</span>(CacheResponseMixin, BaseModelViewSet):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, request, *args, **kwargs</span>):</span><br><span class="line">        cache.delete(get_cache_key(request))</span><br></pre></td></tr></table></figure><h2 id="下游缓存"><a href="#下游缓存" class="headerlink" title="下游缓存"></a>下游缓存</h2><p>略</p><h2 id="使用Vary标头"><a href="#使用Vary标头" class="headerlink" title="使用Vary标头"></a>使用Vary标头</h2><p>略</p><h1 id="四、常用的缓存组件"><a href="#四、常用的缓存组件" class="headerlink" title="四、常用的缓存组件"></a>四、常用的缓存组件</h1><h2 id="1-Memcache"><a href="#1-Memcache" class="headerlink" title="1. Memcache"></a>1. Memcache</h2><p><a href="D:/note/centos-memcached.html">详见另一篇笔记</a>。</p><blockquote><p>启动命令：<code>memcached -d -m 10m -p 11211 -u root</code><br>缓存过期策略：当内存容量达到指定值之后，就会基于LRU算法自动删除不使用的缓存。</p></blockquote><h2 id="2-Redis"><a href="#2-Redis" class="headerlink" title="2. Redis"></a>2. Redis</h2><p><a href="D:/note/centos-redis.html">详见另一篇笔记</a>。<br>缓存过期策略：  </p><pre><code class="bash"># MAXMEMORY POLICY: how Redis will select what to remove when maxmemory  # is reached. You can select one from the following behaviors:    # volatile-lru -&gt; Evict using approximated LRU, only keys with an expire set.  # allkeys-lru -&gt; Evict any key using approximated LRU.  # volatile-lfu -&gt; Evict using approximated LFU, only keys with an expire set.  # allkeys-lfu -&gt; Evict any key using approximated LFU.  # volatile-random -&gt; Remove a random key having an expire set.  # allkeys-random -&gt; Remove a random key, any key.  # volatile-ttl -&gt; Remove the key with the nearest expire time (minor TTL)  # noeviction -&gt; Don&#39;t evict anything, just return an error on write operations.  #  # LRU means Least Recently Used  # LFU means Least Frequently Used  #  # Both LRU, LFU and volatile-ttl are implemented using approximated  # randomized algorithms.  #  # Note: with any of the above policies, Redis will return an error on write  # operations, when there are no suitable keys for eviction.  #  # At the date of writing these commands are: set setnx setex append  # incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd  # sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby  # zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby  # getset mset msetnx exec sort  #  # The default is:  #  # maxmemory-policy noeviction  </code></pre><p>  <a href="https://www.cnblogs.com/xuliangxing/p/7151812.html">Redis过期机制参考</a></p><h1 id="五、缓存带来的问题"><a href="#五、缓存带来的问题" class="headerlink" title="五、缓存带来的问题"></a>五、缓存带来的问题</h1><h2 id="1-数据一致性"><a href="#1-数据一致性" class="headerlink" title="1. 数据一致性"></a>1. 数据一致性</h2><ul><li>产生原因：<blockquote><p>①先删除缓存：在写数据库之前，如果有读请求发生，可能导致旧数据入缓存， 引发数据不一致。<br>②先修改数据库：</p><blockquote><p>a.在有缓存的情况下，两个并发的读写操作。写操作在删除缓存的时候，缓存删除失败，读操作此时读到的数据是老数据，引发数据不一致。(此处考虑是删除缓存还是更新缓存)<br>b.在没有缓存的情况下，两个并发的读写操作。读操作没有及时的把数据放入缓存，写操作进来修改了数据库，删除了缓存，然后读操作恢复，把老数据写进了缓存。</p></blockquote></blockquote></li><li>解决方案：<blockquote><p>延迟双删–&gt;改进–&gt;内存队列删除缓存(如果删除缓存失败，可以多次尝试)<br>考虑到系统复杂度，一般情况下先修改数据库，后删除缓存就行。</p></blockquote></li></ul><h2 id="2-缓存击穿"><a href="#2-缓存击穿" class="headerlink" title="2. 缓存击穿"></a>2. 缓存击穿</h2><ul><li>产生原因：<blockquote><p>针对某一key，该缓存在某一时间点过期的时候，刚好有对应这个key的大量并发请求过来，此时请求会直接走到数据库，可能回导致数据库崩溃。</p></blockquote></li><li>解决方案：<blockquote><p>**①使用互斥锁(mutex key)**：使用zookeeper或者Redis实现互斥锁，等待第一个请求创建完缓存之后才允许后续请求继续访问。<br>**②”数据永不过期”**：在value的内部设置一个超时值(timeout1)，timeout1比实际的超时时间小。当从缓存读取到timeout1发现其已经过期时，马上延迟timeout1并重新设置到缓存。然后再从数据库加载数据并这是到缓存中。</p></blockquote></li></ul><h2 id="3-缓存穿透"><a href="#3-缓存穿透" class="headerlink" title="3. 缓存穿透"></a>3. 缓存穿透</h2><ul><li>产生原因：<blockquote><p>由于缓存是不命中时被动写的，且出于容错考虑，如果从数据库查不到数据就不写入缓存，当数据库中本来就不存在的数据一直被请求，在流量大时，数据库可能就会崩溃。</p></blockquote></li><li>解决方案:<blockquote><p><strong>①请求校验</strong>：对请求url进行校验，有可能是恶意攻击。<br><strong>②使用布隆过滤器</strong>：将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层数据库的查询压力。<br><strong>③对空结果进行缓存</strong>：如果查询一个数据返回为空(不管是数据不存在还是系统故障)，仍然将这个空结果进行缓存，但需要设置过期时间。</p></blockquote></li></ul><h2 id="4-缓存雪崩"><a href="#4-缓存雪崩" class="headerlink" title="4. 缓存雪崩"></a>4. 缓存雪崩</h2><ul><li>产生原因：<blockquote><p>由于设置缓存时采用了相同的过期时间(或者服务器宕机)，导致缓存在某一时刻同时失效，请求全部转发到数据库，数据库瞬间压力过重而导致崩溃。</p></blockquote></li><li>解决方案：<blockquote><p><strong>①将过期时间分散</strong>：在过期时间后面加上一个随机数，让key均匀的失效。<br><strong>②使用队列或锁控制</strong>：用队列或者锁让程序执行在压力范围之内，当然这种方案可能会影响并发量。<br><strong>③配置redis高可用，服务降级，缓存数据持久化</strong></p></blockquote></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;快速开始&quot;&gt;&lt;a href=&quot;#快速开始&quot; class=&quot;headerlink&quot; title=&quot;快速开始&quot;&gt;&lt;/a&gt;快速开始&lt;/h1&gt;&lt;h2 id=&quot;缓存是什么-What&quot;&gt;&lt;a href=&quot;#缓存是什么-What&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="django" scheme="https://zcej.github.io/categories/django/"/>
    
    
  </entry>
  
</feed>
