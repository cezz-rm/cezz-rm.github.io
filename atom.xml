<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://zcej.github.io/atom.xml" rel="self"/>
  
  <link href="https://zcej.github.io/"/>
  <updated>2023-05-04T10:41:22.538Z</updated>
  <id>https://zcej.github.io/</id>
  
  <author>
    <name>CeJ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>airflow使用pip或docker compose安装</title>
    <link href="https://zcej.github.io/2023/03/02/python/airflow%E4%BD%BF%E7%94%A8pip%E6%88%96docker%20compose%E5%AE%89%E8%A3%85/"/>
    <id>https://zcej.github.io/2023/03/02/python/airflow%E4%BD%BF%E7%94%A8pip%E6%88%96docker%20compose%E5%AE%89%E8%A3%85/</id>
    <published>2023-03-02T13:11:41.000Z</published>
    <updated>2023-05-04T10:41:22.538Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录当前airflow的两种安装方式，当前最新版本为<code>2.5.1</code>。</p><blockquote><p>注：就目前而言，airflow版本大于2.3.0时，官方推荐python的版本为3.7-3.10，3.11暂不支持。</p></blockquote><p><a name="syKy2"></a></p><h2 id="使用pip安装"><a href="#使用pip安装" class="headerlink" title="使用pip安装"></a>使用pip安装</h2><ol><li><p>安装python</p></li><li><p>创建虚拟环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方式1</span></span><br><span class="line">pyenv virtualenv 3.9.10 venvAirflow</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式2</span></span><br><span class="line">python -m virtualenv venvAirflow</span><br></pre></td></tr></table></figure></li><li><p>安装airflow</p></li></ol><p>默认会安装在<code>~/airflow</code>下，可通过指定环境变量修改，如：<code>export AIRFLOW_HOME=~/airflow</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只包含启动的基础部分内容，扩展包其它方式安装，参照官网</span></span><br><span class="line">pip install apache-airflow</span><br></pre></td></tr></table></figure><ol start="4"><li><p>初始化数据库，默认使用sqlite存储元数据，仅用于测试环境。生产环境下的并发支持需用mysql或psql</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">airflow db init</span><br></pre></td></tr></table></figure><p>初始用户为<code>admin</code>，密码见同目录下文件<code>standalone_admin_password.txt</code></p></li><li><p>启动web服务器</p></li></ol><p>两种方式启动</p><ul><li><p>一键启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">airflow standalone</span><br></pre></td></tr></table></figure></li><li><p>手动运行airflow各个部分：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">airflow db init</span><br><span class="line"></span><br><span class="line">airflow <span class="built_in">users</span> create \</span><br><span class="line">    --username admin \</span><br><span class="line">    --firstname Peter \</span><br><span class="line">    --lastname Parker \</span><br><span class="line">    --role Admin \</span><br><span class="line">    --email spiderman@superhero.org</span><br><span class="line"></span><br><span class="line">airflow webserver --port 8080</span><br><span class="line"></span><br><span class="line">airflow scheduler</span><br></pre></td></tr></table></figure></li></ul><ol start="6"><li>访问web界面</li></ol><p>访问<code>http://localhost:8080</code>，将看到web界面<br><a name="iX95b"></a></p><h2 id="通过docker-compose安装"><a href="#通过docker-compose安装" class="headerlink" title="通过docker-compose安装"></a>通过docker-compose安装</h2><ol><li>检查内存是否足够</li></ol><p>官方建议至少为<code>docker engine</code>分配4GB内存，最好是8GB，通过下述命令检测。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> <span class="string">&quot;debian:bullseye-slim&quot;</span> bash -c <span class="string">&#x27;numfmt --to iec $(echo $(($(getconf _PHYS_PAGES) * $(getconf PAGE_SIZE))))&#x27;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>下载<code>docker-compose.yaml</code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -LfO <span class="string">&#x27;https://airflow.apache.org/docs/apache-airflow/2.5.1/docker-compose.yaml&#x27;</span></span><br></pre></td></tr></table></figure>该文件定义了多个服务：</li></ol><ul><li>airflow-scheduler：调度程序监视所有任务和DAGs，并在任务实例的依赖关系完成后触发</li><li>airflow-webserver：<a href="http://localhost:8080/">http://localhost:8080</a></li><li>airflow-worker：执行调度程序分配的任务</li><li>airflow-init：初始化服务</li><li>postgres：数据库</li><li>redis：消息从scheduler转发到worker的代理broker</li><li>flower：环境监控，<a href="http://localhost:5555/">http://localhost:5555</a></li></ul><ol start="3"><li><p>创建挂载目录及用户设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ./dags ./logs ./plugins</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;AIRFLOW_UID=<span class="subst">$(id -u)</span>&quot;</span> &gt; .<span class="built_in">env</span></span><br></pre></td></tr></table></figure></li><li><p>初始化数据库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker compose up airflow-init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当初始化完成将看到下述输出</span></span><br><span class="line"><span class="comment"># airflow-init_1       | Upgrades done</span></span><br><span class="line"><span class="comment"># airflow-init_1       | Admin user airflow created</span></span><br><span class="line"><span class="comment"># airflow-init_1       | 2.5.1</span></span><br><span class="line"><span class="comment"># start_airflow-init_1 exited with code 0</span></span><br></pre></td></tr></table></figure><p>初始化用户密码为<code>airflow/airflow</code></p></li><li><p>运行airflow</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行docker-compose ps -a看到下述输出则说明正常运行</span></span><br><span class="line"><span class="comment"># CONTAINER ID   IMAGE                  COMMAND                  CREATED          STATUS                    PORTS                              NAMES</span></span><br><span class="line"><span class="comment"># 247ebe6cf87a   apache/airflow:2.5.1   &quot;/usr/bin/dumb-init …&quot;   3 minutes ago    Up 3 minutes (healthy)    8080/tcp                           compose_airflow-worker_1</span></span><br><span class="line"><span class="comment"># ed9b09fc84b1   apache/airflow:2.5.1   &quot;/usr/bin/dumb-init …&quot;   3 minutes ago    Up 3 minutes (healthy)    8080/tcp                           compose_airflow-scheduler_1</span></span><br><span class="line"><span class="comment"># 7cb1fb603a98   apache/airflow:2.5.1   &quot;/usr/bin/dumb-init …&quot;   3 minutes ago    Up 3 minutes (healthy)    0.0.0.0:8080-&gt;8080/tcp             compose_airflow-webserver_1</span></span><br><span class="line"><span class="comment"># 74f3bbe506eb   postgres:13            &quot;docker-entrypoint.s…&quot;   18 minutes ago   Up 17 minutes (healthy)   5432/tcp                           compose_postgres_1</span></span><br><span class="line"><span class="comment"># 0bd6576d23cb   redis:latest           &quot;docker-entrypoint.s…&quot;   10 hours ago     Up 17 minutes (healthy)   0.0.0.0:6379-&gt;6379/tcp             compose_redis_1</span></span><br></pre></td></tr></table></figure></li><li><p>如何使用</p></li></ol><p>在启动airflow后，有以下三种使用方式：</p><ul><li><p>通过CLI命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同样可以使用CLI命令</span></span><br><span class="line">docker-compose run airflow-worker airflow info</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者下载官方提供的命令包装脚本</span></span><br><span class="line">curl -LfO <span class="string">&#x27;https://airflow.apache.org/docs/apache-airflow/2.5.1/airflow.sh&#x27;</span></span><br><span class="line"><span class="built_in">chmod</span> +x airflow.sh</span><br><span class="line"></span><br><span class="line">./airflow.sh info</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时支持进入交互式bash shell，或进入python容器</span></span><br><span class="line">./airflow.sh bash</span><br><span class="line"></span><br><span class="line">./airflow.sh python</span><br></pre></td></tr></table></figure></li><li><p>通过Web页面</p></li></ul><p>使用预设用户密码<code>airflow/airflow</code>进入web页面<code>http://localhost:8080</code></p><ul><li>使用REST API接口</li></ul><p>如下命令简单参考，更详细可查阅官方文档</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ENDPOINT_URL=<span class="string">&quot;http://localhost:8080/&quot;</span></span><br><span class="line">curl -X GET  \</span><br><span class="line">    --user <span class="string">&quot;airflow:airflow&quot;</span> \</span><br><span class="line">    <span class="string">&quot;<span class="variable">$&#123;ENDPOINT_URL&#125;</span>/api/v1/pools&quot;</span></span><br></pre></td></tr></table></figure><ol start="6"><li>清除</li></ol><p>若要停止和删除容器，删除数据卷及镜像的话可参考下述命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose down --volumes --rmi all</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文记录当前airflow的两种安装方式，当前最新版本为&lt;code&gt;2.5.1&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：就目前而言，airflow版本大于2.3.0时，官方推荐python的版本为3.7-3.10，3.11暂不支持。&lt;/p&gt;
&lt;/bloc</summary>
      
    
    
    
    <category term="python" scheme="https://zcej.github.io/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>airflow简单了解</title>
    <link href="https://zcej.github.io/2023/02/27/python/airflow%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3/"/>
    <id>https://zcej.github.io/2023/02/27/python/airflow%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3/</id>
    <published>2023-02-27T05:08:26.000Z</published>
    <updated>2023-05-04T10:39:34.786Z</updated>
    
    <content type="html"><![CDATA[<p><a name="I72P3"></a></p><h3 id="Q：airflow介绍"><a href="#Q：airflow介绍" class="headerlink" title="Q：airflow介绍"></a>Q：airflow介绍</h3><p>是用于任务调度和监控的开源工具，由python编写。以DAG有向无环图的方式组建task任务流，灵活的定义任务间的依赖关系，监控任务的运行状态。强大的web UI，页面功能丰富。</p><blockquote><p>任务流怎么理解，工作流程有一个明确的开始和结束，按一定的间隔运行，就可以用python定义一个dag文件。<br>dag的定义文件，只是一个配置文件，该脚本不能用于任务之间的交叉通信，不过有一个高级特性解决该问题<code>XComs</code>。<br>下面是定义任务依赖关系的方法：</p><ul><li><code>t1.set_upstream(t2)</code></li><li><code>t1.set_downstream([t2, t3])</code></li><li><code>t1 &gt;&gt; [t2, t3]</code></li></ul></blockquote><p>官方的一个简单的dag文件定义如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line"><span class="keyword">from</span> textwrap <span class="keyword">import</span> dedent</span><br><span class="line"></span><br><span class="line"><span class="comment"># The DAG object; we&#x27;ll need this to instantiate a DAG</span></span><br><span class="line"><span class="keyword">from</span> airflow <span class="keyword">import</span> DAG</span><br><span class="line"></span><br><span class="line"><span class="comment"># Operators; we need this to operate!</span></span><br><span class="line"><span class="keyword">from</span> airflow.operators.bash <span class="keyword">import</span> BashOperator</span><br><span class="line"><span class="keyword">with</span> DAG(</span><br><span class="line">    <span class="string">&quot;tutorial&quot;</span>,</span><br><span class="line">    <span class="comment"># These args will get passed on to each operator</span></span><br><span class="line">    <span class="comment"># You can override them on a per-task basis during operator initialization</span></span><br><span class="line">    default_args=&#123;</span><br><span class="line">        <span class="string">&quot;depends_on_past&quot;</span>: <span class="literal">False</span>,</span><br><span class="line">        <span class="string">&quot;email&quot;</span>: [<span class="string">&quot;airflow@example.com&quot;</span>],</span><br><span class="line">        <span class="string">&quot;email_on_failure&quot;</span>: <span class="literal">False</span>,</span><br><span class="line">        <span class="string">&quot;email_on_retry&quot;</span>: <span class="literal">False</span>,</span><br><span class="line">        <span class="string">&quot;retries&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;retry_delay&quot;</span>: timedelta(minutes=<span class="number">5</span>),</span><br><span class="line">        <span class="comment"># &#x27;queue&#x27;: &#x27;bash_queue&#x27;,</span></span><br><span class="line">        <span class="comment"># &#x27;pool&#x27;: &#x27;backfill&#x27;,</span></span><br><span class="line">        <span class="comment"># &#x27;priority_weight&#x27;: 10,</span></span><br><span class="line">        <span class="comment"># &#x27;end_date&#x27;: datetime(2016, 1, 1),</span></span><br><span class="line">        <span class="comment"># &#x27;wait_for_downstream&#x27;: False,</span></span><br><span class="line">        <span class="comment"># &#x27;sla&#x27;: timedelta(hours=2),</span></span><br><span class="line">        <span class="comment"># &#x27;execution_timeout&#x27;: timedelta(seconds=300),</span></span><br><span class="line">        <span class="comment"># &#x27;on_failure_callback&#x27;: some_function,</span></span><br><span class="line">        <span class="comment"># &#x27;on_success_callback&#x27;: some_other_function,</span></span><br><span class="line">        <span class="comment"># &#x27;on_retry_callback&#x27;: another_function,</span></span><br><span class="line">        <span class="comment"># &#x27;sla_miss_callback&#x27;: yet_another_function,</span></span><br><span class="line">        <span class="comment"># &#x27;trigger_rule&#x27;: &#x27;all_success&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    description=<span class="string">&quot;A simple tutorial DAG&quot;</span>,</span><br><span class="line">    schedule=timedelta(days=<span class="number">1</span>),</span><br><span class="line">    start_date=datetime(<span class="number">2021</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">    catchup=<span class="literal">False</span>,</span><br><span class="line">    tags=[<span class="string">&quot;example&quot;</span>],</span><br><span class="line">) <span class="keyword">as</span> dag:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># t1, t2 and t3 are examples of tasks created by instantiating operators</span></span><br><span class="line">    t1 = BashOperator(</span><br><span class="line">        task_id=<span class="string">&quot;print_date&quot;</span>,</span><br><span class="line">        bash_command=<span class="string">&quot;date&quot;</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    t2 = BashOperator(</span><br><span class="line">        task_id=<span class="string">&quot;sleep&quot;</span>,</span><br><span class="line">        depends_on_past=<span class="literal">False</span>,</span><br><span class="line">        bash_command=<span class="string">&quot;sleep 5&quot;</span>,</span><br><span class="line">        retries=<span class="number">3</span>,</span><br><span class="line">    )</span><br><span class="line">    t1.doc_md = dedent(</span><br><span class="line">        <span class="string">&quot;&quot;&quot;\</span></span><br><span class="line"><span class="string">    #### Task Documentation</span></span><br><span class="line"><span class="string">    You can document your task using the attributes `doc_md` (markdown),</span></span><br><span class="line"><span class="string">    `doc` (plain text), `doc_rst`, `doc_json`, `doc_yaml` which gets</span></span><br><span class="line"><span class="string">    rendered in the UI&#x27;s Task Instance Details page.</span></span><br><span class="line"><span class="string">    ![img](http://montcs.bloomu.edu/~bobmon/Semesters/2012-01/491/import%20soul.png)</span></span><br><span class="line"><span class="string">    **Image Credit:** Randall Munroe, [XKCD](https://xkcd.com/license.html)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    dag.doc_md = __doc__  <span class="comment"># providing that you have a docstring at the beginning of the DAG; OR</span></span><br><span class="line">    dag.doc_md = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    This is a documentation placed anywhere</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>  <span class="comment"># otherwise, type it like this</span></span><br><span class="line">    templated_command = dedent(</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &#123;% for i in range(5) %&#125;</span></span><br><span class="line"><span class="string">        echo &quot;&#123;&#123; ds &#125;&#125;&quot;</span></span><br><span class="line"><span class="string">        echo &quot;&#123;&#123; macros.ds_add(ds, 7)&#125;&#125;&quot;</span></span><br><span class="line"><span class="string">    &#123;% endfor %&#125;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    t3 = BashOperator(</span><br><span class="line">        task_id=<span class="string">&quot;templated&quot;</span>,</span><br><span class="line">        depends_on_past=<span class="literal">False</span>,</span><br><span class="line">        bash_command=templated_command,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    t1 &gt;&gt; [t2, t3]</span><br></pre></td></tr></table></figure><p><a name="Qwi1p"></a></p><h3 id="Q：airflow基本功能"><a href="#Q：airflow基本功能" class="headerlink" title="Q：airflow基本功能"></a>Q：airflow基本功能</h3><ol><li><p>任务调度：支持按时间计划、依赖关系或手动触发等方式调度任务。</p></li><li><p>任务监控：可以查看任务执行情况，如执行时间、任务状态、失败原因等。</p></li><li><p>依赖关系管理：支持设置任务间的依赖关系，确保任务的执行顺序。</p></li><li><p>数据流图：提供数据流图，方便用户清晰地查看任务间的依赖关系。</p></li><li><p>任务执行：支持将任务提交到不同的执行环境，如本地、云环境等。</p></li><li><p>高度定制：支持自定义插件，以扩展Airflow的功能。</p></li><li><p>权限管理：支持对用户进行权限管理，确保任务的安全性。</p></li><li><p>Web界面：提供易于使用的Web界面，方便用户进行任务调度、监控、配置等操作。</p></li><li><p>任务扩展：支持任务扩展，可以根据需求增加任务类型。</p></li><li><p>数据库存储：支持使用数据库存储任务信息，方便用户对任务信息进行查询和维护。</p></li><li><p>任务记录：支持对任务的执行情况进行详细记录，以便用户查询和分析。</p></li><li><p>电子邮件通知：支持对任务的执行情况进行电子邮件通知，以便用户及时了解任务执行情况。</p></li><li><p>多租户支持：支持多租户，可以将不同的任务隔离开来，保证各个任务的安全性和独立性。</p></li><li><p>可靠性：支持多种高可靠性策略，如任务重试、任务隔离等，确保任务的可靠性。</p></li><li><p>安全性：支持多种安全措施，如用户认证、数据加密等，确保系统的安全性。</p></li><li><p>故障恢复：支持故障恢复，在系统出现故障时，可以自动恢复任务的执行。</p></li><li><p>API支持：提供丰富的API，方便用户通过代码编程方式对任务进行操作。</p></li><li><p>可扩展性：提供可扩展的架构，可以根据业务需求进行扩展。</p></li><li><p>报表生成：支持报表生成，方便用户查询和分析任务执行情况。</p></li><li><p>日志管理：支持日志管理，方便用户查询和分析系统运行情况。</p></li><li><p>可视化管理：提供可视化的任务管理界面，方便用户对任务进行监控和管理。</p></li><li><p>支持多种语言：支持多种语言，如Python、Java、C++等，方便用户编写任务代码。<br><a name="v3jqJ"></a></p><h3 id="Q：airflow应用场景"><a href="#Q：airflow应用场景" class="headerlink" title="Q：airflow应用场景"></a>Q：airflow应用场景</h3></li><li><p>数据管道：用于编排数据管道，从数据源获取数据，并在进行数据处理、转换、存储等操作后将数据存储到目标数据库。</p></li><li><p>数据分析：用于编排数据分析任务，将数据从数据库中抽取，并进行数据分析、可视化等操作。</p></li><li><p>模型训练：用于编排模型训练任务，将数据从数据库中抽取，并使用机器学习模型进行训练。</p></li><li><p>定时任务：用于编排定时任务，定期执行一些固定的任务，如数据备份、定期清理等。</p></li><li><p>其他自动化任务：用于编排其他自动化任务，如文件转换、数据同步等。<br><a name="rz9YU"></a></p><h3 id="Q：airflow有哪些组件"><a href="#Q：airflow有哪些组件" class="headerlink" title="Q：airflow有哪些组件"></a>Q：airflow有哪些组件</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/21799731/1675825200916-f2709b42-ece3-4a75-a9fd-9e3c32c2c261.png#averageHue=%23f9f9f9&clientId=u33b2d1f0-1f5a-4&from=paste&id=u1a3e085b&originHeight=484&originWidth=744&originalType=url&ratio=1&rotation=0&showTitle=false&size=26158&status=done&style=none&taskId=u8dcf0862-b119-437e-9858-275619514a0&title=" alt="image.png"></p></li></ol><ul><li>Webserver：管理界面，可以在其中管理任务、查看任务执行状态、配置任务等。</li><li>Scheduler：调度器，负责调度任务执行。</li><li>Workers：执行任务的节点，负责执行任务。</li><li>DAGs：任务流程，表示任务之间的依赖关系。</li><li>Operators：任务执行单元，封装了一组任务执行的逻辑。</li><li>Hooks：连接器，用于连接不同的任务或外部系统。</li><li>Sensors：传感器，用于监测外部系统的状态。</li><li>Variables：变量，存储一些全局变量，可以在任务流程中使用。</li><li>XComs：交互数据，可以在任务之间传递数据。</li><li>Connections：连接，用于连接不同的数据源。<br><a name="Djk1E"></a><h3 id="Q：airflow和dolphinsheduler的不同和优缺点"><a href="#Q：airflow和dolphinsheduler的不同和优缺点" class="headerlink" title="Q：airflow和dolphinsheduler的不同和优缺点"></a>Q：airflow和dolphinsheduler的不同和优缺点</h3>DolphinScheduler致力于可视化，通过页面完成一个DAG工作流。<br />Airflow则是通过编程的方式完成一个DAG工作量，定制化开发相对比较容易。</li></ul><p>相似点：</p><ul><li>两者都允许用户创建和管理复杂的工作流。</li><li>两者都有基于网页的用户界面，用于查看和管理作业。</li><li>两者都提供了一种自动调度和执行任务的方法。</li></ul><p>不同点：</p><ul><li>Airflow 是用 Python 编写的，具有庞大的活跃社区，而 DolphinScheduler 是用 Java 编写的，社区较小。</li><li>Airflow 有丰富的内置操作符，用于处理数据，例如在系统之间传输文件的能力，并且可以使用自定义插件轻松扩展，而 DolphinScheduler 提供了一组更基本的操作符，可能需要更多的自定义才能适合特定的用例。</li><li>Airflow 的监控和报警功能更强大，相比之下，DolphinScheduler 提供了基本的监控和报警功能。</li><li>Airflow 具有更灵活的执行模型，允许以顺序或并行的方式执行任务，而 DolphinScheduler 主要支持顺序执行。</li></ul><p>Airflow 的优点：</p><ul><li>功能丰富：Airflow 提供了诸如 DAG 编排，任务审核，任务监控等功能，并且具有很好的扩展性，可以使用第三方插件扩展其功能。</li><li>用户友好：Airflow 提供了一个简单易用的 Web 界面，方便用户进行任务管理和监控。</li><li>集成性强：Airflow 在整个 DevOps 生命周期中有良好的集成性，可以方便地与各种数据存储，数据分析，机器学习等工具集成。</li></ul><p>Airflow 的缺点：</p><ul><li>部署复杂：Airflow 的部署相对比较复杂，对于新手可能有一定的学习曲线。</li><li>资源消耗大：由于 Airflow 提供了大量的功能，因此对于资源的消耗也相对较大。</li></ul><p>DolphinScheduler 的优点：</p><ul><li>部署简单：DolphinScheduler 的部署相对比较简单，易于上手。</li><li>资源消耗小：DolphinScheduler 对于资源的消耗相对较小，适合在资源有限的情况下使用。</li><li>稳定性高：DolphinScheduler 具有较高的稳定性，可以保证任务的顺利执行。</li></ul><p>DolphinScheduler 的缺点：</p><ul><li>功能较弱：相对于 Airflow，DolphinScheduler 的功能相对较弱，可能无法满足复杂的任务管理需求。</li><li>可扩展性差：DolphinScheduler 可扩展性较差，可能不支持用户希望的一些特殊功能。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a name=&quot;I72P3&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Q：airflow介绍&quot;&gt;&lt;a href=&quot;#Q：airflow介绍&quot; class=&quot;headerlink&quot; title=&quot;Q：airflow介绍&quot;&gt;&lt;/a&gt;Q：airflow介绍&lt;/h3&gt;&lt;p&gt;是用于任务调</summary>
      
    
    
    
    <category term="python" scheme="https://zcej.github.io/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>go文件第一行build注释有什么作用？</title>
    <link href="https://zcej.github.io/2023/02/16/go/go%E6%96%87%E4%BB%B6%E7%AC%AC%E4%B8%80%E8%A1%8Cbuild%E6%B3%A8%E9%87%8A%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F/"/>
    <id>https://zcej.github.io/2023/02/16/go/go%E6%96%87%E4%BB%B6%E7%AC%AC%E4%B8%80%E8%A1%8Cbuild%E6%B3%A8%E9%87%8A%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F/</id>
    <published>2023-02-16T12:13:37.000Z</published>
    <updated>2023-05-04T10:36:37.820Z</updated>
    
    <content type="html"><![CDATA[<p>其专业术语为构建约束，其实不止是go文件，也可以运用在其他文件中。<strong>一句话总结其作用就是指定文件的编译场景，若满足条件则编译，反之就不会进行编译。</strong><br />下面进行一个简单的总结，详细内容可以看看官方的设计文档：<a href="https://go.googlesource.com/proposal/+/master/design/draft-gobuild.md">https://go.googlesource.com/proposal/+/master/design/draft-gobuild.md</a><br><a name="c0Ltm"></a></p><h2 id="什么是构建约束"><a href="#什么是构建约束" class="headerlink" title="什么是构建约束"></a>什么是构建约束</h2><p>构建约束（build constraint）， 也叫做构建标记（build tag），在源文件中通过注释的方式指定编译环境，若要为不同的编译环境编写不同的go代码，则需要使用构建约束，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// +build linux</span></span><br></pre></td></tr></table></figure><p>上述的注释行意思是只有在linux环境下才会编译该文件，否则会忽略。<br />其编写格式需要注意以下几点：</p><ul><li>可以在任何文件源文件中编写</li><li>必须在写在文件顶部附近，可以写多行</li><li>为了区别<code>package</code>的文档注释，在约束后必须有空行</li></ul><p>其支持类型比较广泛，有以下几种：</p><ul><li><p>指定编译的操作系统：如：windows，linux，darwin（对应runtime.GOOS）</p></li><li><p>指定架构：如：amd64、386（对应runtime.GOARCH）</p></li><li><p>指定使用的编译器，如：gccgo、gc</p></li><li><p>指定go版本，如：go1.17、go1.18</p></li><li><p>自定义tag，编译时通过指定<code>-tags</code>传入的值<br><a name="s6Bw9"></a></p><h2 id="老版本语法"><a href="#老版本语法" class="headerlink" title="老版本语法"></a>老版本语法</h2><p>在<code>go1.17</code>之前是使用的老版本语法，<code>1.17</code>之后的支持比较完善了。<br />老版本的构建语法为<code>// +build</code>这种形式，可以通过空格、逗号或多行进行组合，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// +build linux,386</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述构建约束表示的是: linux and 386</span></span><br><span class="line"><span class="comment">// 逗号表示and, 空格表示or</span></span><br></pre></td></tr></table></figure><p>比较复杂的写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// +build linux,386 darwin,!cgo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述构建约束表示的是: (linux and 386) or (darwin and (not cgo))</span></span><br></pre></td></tr></table></figure><p>也可以分成多行书写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// +build linux darwin</span></span><br><span class="line"><span class="comment">// +build amd64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于: (linux or darwin) and amd64</span></span><br></pre></td></tr></table></figure><p>通过上述可见老版本的写法比较复杂，非常容易出错<br><a name="reaEb"></a></p><h2 id="新版本语法"><a href="#新版本语法" class="headerlink" title="新版本语法"></a>新版本语法</h2><p>新版的构建约束使用<code>//go:</code>开头：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:build</span></span><br></pre></td></tr></table></figure><p>新版本语法有以下几点需要注意：</p></li><li><p><code>//</code>和<code>go:</code>之间不能有空格</p></li><li><p>使用的是布尔表达式，而不是逗号和空格等</p></li><li><p>一个文件只能有一行构建语句，而不是像老版那样支持多行</p></li></ul><p>例如<code>linux and 386</code>现在这样写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:build linux &amp;&amp; 386</span></span><br></pre></td></tr></table></figure><p>新的语法主体未Go spec的EBNF标记：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BuildLine      = <span class="string">&quot;//go:build&quot;</span> Expr</span><br><span class="line">Expr           = OrExpr</span><br><span class="line">OrExpr         = AndExpr   &#123; <span class="string">&quot;||&quot;</span> AndExpr &#125;</span><br><span class="line">AndExpr        = UnaryExpr &#123; <span class="string">&quot;&amp;&amp;&quot;</span> UnaryExpr &#125;</span><br><span class="line">UnaryExpr      = <span class="string">&quot;!&quot;</span> UnaryExpr | <span class="string">&quot;(&quot;</span> Expr <span class="string">&quot;)&quot;</span> | tag</span><br><span class="line">tag            = tag_letter &#123; tag_letter &#125;</span><br><span class="line">tag_letter     = unicode_letter | unicode_digit | <span class="string">&quot;_&quot;</span> | <span class="string">&quot;.&quot;</span></span><br></pre></td></tr></table></figure><p>也就是说，构建标记的语法与当前形式保持不变，但构建标记的组合现在使用Go的<code>||, &amp;&amp;, !</code>运算符和括号完成。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;其专业术语为构建约束，其实不止是go文件，也可以运用在其他文件中。&lt;strong&gt;一句话总结其作用就是指定文件的编译场景，若满足条件则编译，反之就不会进行编译。&lt;/strong&gt;&lt;br /&gt;下面进行一个简单的总结，详细内容可以看看官方的设计文档：&lt;a href=&quot;https</summary>
      
    
    
    
    <category term="go" scheme="https://zcej.github.io/categories/go/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL中的几类日志</title>
    <link href="https://zcej.github.io/2023/02/05/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E4%B8%AD%E5%87%A0%E7%B1%BB%E6%97%A5%E5%BF%97/"/>
    <id>https://zcej.github.io/2023/02/05/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E4%B8%AD%E5%87%A0%E7%B1%BB%E6%97%A5%E5%BF%97/</id>
    <published>2023-02-05T11:07:58.000Z</published>
    <updated>2023-05-04T10:33:29.385Z</updated>
    
    <content type="html"><![CDATA[<p>先简单对三大日志进行总结：</p><ul><li>mysql innodb引擎使用redo log(重做日志)保证事务的持久性，使用undo log(回滚日志)保证事务的原子性</li><li>mysql的数据备份，主备，主主，主从都离不开binlog，需要依靠binlog来同步数据，保证数据的一致性</li></ul><p>除三大日志外，还有relay log(中继日志)，slow query log(慢查询日志)，error log(错误日志等)<br><a name="gg8jJ"></a></p><h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><ul><li><p>作用：确保事务的持久性。redo日志记录事务执行后的状态，用来恢复未写入data file的已成功事务更新的数据。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。</p></li><li><p>内容：物理格式的日志，记录的是物理数据页面的修改信息，其redo log是顺序写入其物理文件中的。<br><a name="ywJ6j"></a></p><h4 id="Q：什么时候产生？"><a href="#Q：什么时候产生？" class="headerlink" title="Q：什么时候产生？"></a>Q：什么时候产生？</h4><p>在事务开始之后就产生redo log，redo log的落盘并不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入redo log文件中。<br><a name="tAnMk"></a></p><h4 id="Q：什么时候释放？"><a href="#Q：什么时候释放？" class="headerlink" title="Q：什么时候释放？"></a>Q：什么时候释放？</h4><p>当对应事务的脏页写入到磁盘之后，redo log的使命也就完成了，重做日志占用的空间就可以重用(被覆盖)。<br><a name="QijLw"></a></p><h4 id="Q：对应的物理文件？"><a href="#Q：对应的物理文件？" class="headerlink" title="Q：对应的物理文件？"></a>Q：对应的物理文件？</h4><p>默认情况下，对应的物理文件位于数据库的data目录下的ib_logfile1&amp;ib_logfile2<br /><code>innodb_log_group_home_dir</code>指定日志文件组所在的路径，默认为.&#x2F;<br /><code>innodb_log_files_in_group</code>指定重做日志文件组中文件的数量，默认为2<br />另外还有其他参数等<code>innodb_log_file_size</code>、<code>innodb_mirrored_log_groups</code><br><a name="H3VlT"></a></p><h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2></li><li><p>作用：保证数据的原子性，保证了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读(MVCC)，也即非锁定读。</p></li><li><p>内容：逻辑格式的日志，在执行undo的时候，仅仅是将数据从逻辑上恢复至事务之前的状态，而不是从物理页面上操作实现的，这一点是不同于redo log的。<br><a name="ARTe7"></a></p><h4 id="Q：什么时候产生"><a href="#Q：什么时候产生" class="headerlink" title="Q：什么时候产生?"></a>Q：什么时候产生?</h4><p>事务开始之前，将当前的版本生成undo log，undo也会产生redo来保证undo log的可靠性。<br><a name="lXJnO"></a></p><h4 id="Q：什么时候释放"><a href="#Q：什么时候释放" class="headerlink" title="Q：什么时候释放?"></a>Q：什么时候释放?</h4><p>当事务提交之后，undo log并不能立马被删除，而是放入待清理的链表，由purge线程判断是否由其他事务在使用undo段中表的上一个事务之前的版本信息，决定是否可以清理undo log的日志空间。<br><a name="hppiE"></a></p><h4 id="Q：对应的物理文件？-1"><a href="#Q：对应的物理文件？-1" class="headerlink" title="Q：对应的物理文件？"></a>Q：对应的物理文件？</h4><p>mysql5.6之前，undo表空间位于共享表空间的回滚段中，共享表空间的默认名称是ibdata，位于数据文件目录中。<br />mysql5.6之后，undo表空间可以配置成独立的文件，但是提前需要在配置文件中配置，完成数据库初始化后生效且不可改变undo log文件的个数。<br />如果初始化数据库之前没有进行相关配置，那么就无法配置成独立的表空间了。<br />mysql5.7之后的独立undo表空间配置参数如下：<br /><code>innodb_undo_directory=/data/undospace/</code>存放目录<br /><code>innodb_undo_logs=128</code>回滚段为128KB<br /><code>innodb_undo_tablespaces=4</code>指定有4个undo log文件<br />若是使用共享表空间，则由<code>innodb_data_file_path</code>配置<br><a name="Is34y"></a></p><h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2></li><li><p>作用：用于复制，在主从复制中，从库利用主库上的binlog进行重播，实现主从同步，保证数据的一致性。用于数据库的基于时间点的还原。</p></li><li><p>内容：逻辑格式的日志，可以简单认为就是执行过的事务中的sql语句。但又不完全是sql语句这么简单，而是包括了执行的sql语句反向的信息，意味着delete对应着delete本身和其反向的insert。可以使用mysqlbinlog解析binlog。<br><a name="Io3G0"></a></p><h4 id="Q：什么时候产生？-1"><a href="#Q：什么时候产生？-1" class="headerlink" title="Q：什么时候产生？"></a>Q：什么时候产生？</h4><p>事务提交的时候，一次性将事务中的sql语句(一个事务可能对应多个sql语句)按照一定的格式记录到binlog中。<br><a name="VwT9y"></a></p><h4 id="Q：什么时候释放？-1"><a href="#Q：什么时候释放？-1" class="headerlink" title="Q：什么时候释放？"></a>Q：什么时候释放？</h4><p>binlog默认保持时间由参数<code>expire_logs_day</code>配置，对于非活动的日志文件，在生成时间超过该配置的天数之后，会被自动删除。<br><a name="bXNjd"></a></p><h4 id="Q：对应的物理文件？-2"><a href="#Q：对应的物理文件？-2" class="headerlink" title="Q：对应的物理文件？"></a>Q：对应的物理文件？</h4><p>配置的文件的路径为<code>log_bin_basename</code>，binlog日志文件按照指定大小，当日志文件达到指定大小后进行滚动更新，生成新的日志文件。对于每个binlog日志文件，通过一个统一的index文件来组织。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;先简单对三大日志进行总结：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mysql innodb引擎使用redo log(重做日志)保证事务的持久性，使用undo log(回滚日志)保证事务的原子性&lt;/li&gt;
&lt;li&gt;mysql的数据备份，主备，主主，主从都离不开binlog，需要依靠bin</summary>
      
    
    
    
    <category term="数据库" scheme="https://zcej.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>使用Github Action自动化部署Hexo</title>
    <link href="https://zcej.github.io/2023/01/15/%E5%85%B6%E4%BB%96/%E4%BD%BF%E7%94%A8Github%20Action%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2Hexo/"/>
    <id>https://zcej.github.io/2023/01/15/%E5%85%B6%E4%BB%96/%E4%BD%BF%E7%94%A8Github%20Action%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2Hexo/</id>
    <published>2023-01-15T06:22:02.000Z</published>
    <updated>2023-05-04T10:29:11.854Z</updated>
    
    <content type="html"><![CDATA[<p>本文基于已经创建了hexo的基础，向github action自动化部署迈进。<br />出于长远考虑，还是应当将blog结合CI进行完善。避免存放hexo源码的电脑重装或者更换带来的不变。<br />下面将记录自己的部署过程。<br><a name="pM4V2"></a></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li><strong>创建Token</strong></li></ol><p>为了确保由<code>github action</code>持续部署时，其拥有足够的权限进行<code>hexo deploy</code>的相关操作，需提前创建好token。登录并访问<code>Github-&gt;头像(右上角)-&gt;Settings-&gt;Developer Settings-&gt;Persional access tokens-&gt;Tokens (classic)</code>，点击<code>generate new token</code>，token名和过期时间自定义，必须勾选repo和workflows。<br /><img src="/2023/01/15/%E5%85%B6%E4%BB%96/%E4%BD%BF%E7%94%A8Github%20Action%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2Hexo/1-1.png" class="" title="image.png"></p><blockquote><p><strong>注</strong>：创建完成的<code>access token</code>只会显示一次，切记先拷贝下来。忘了只能重新创建。</p></blockquote><ol start="2"><li><strong>创建项目</strong></li></ol><p>共需创建两个项目（当然也可存放与不同分支，修改workflow的配置即可）：<br />一个私有项目，用于存放hexo博客源码，以<code>**blog**</code>命名。<br />一个公有项目，用于存放静态页面，以<code>**test.github.io**</code>命名。</p><ol start="3"><li><strong>编写workflow的配置文件</strong></li></ol><p>在本地hexo博客项目路径的<code>.github</code>文件新建<code>workflows</code>文件夹，再在文件夹<code>workflows</code>文件夹内新建<code>autodeploy.yml</code>文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当有改动推送到master分支时，启动Action</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">Auto</span> <span class="string">Depoly</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span> <span class="comment">#2020年10月后github新建仓库默认分支改为main，注意更改</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">release:</span></span><br><span class="line">    <span class="attr">types:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">published</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">deploy:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">source</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">ref:</span> <span class="string">master</span> <span class="comment">#2020年10月后github新建仓库默认分支改为main，注意更改</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Node.js</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">node-version:</span> <span class="string">&quot;16.16&quot;</span> <span class="comment">#action使用的node版本，建议大版本和本地保持一致。可以在本地用node -v查询版本号。</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">hexo</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        export TZ=&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line"><span class="string">        npm install hexo-cli -g</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Cache</span> <span class="string">hexo</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/cache@v1</span></span><br><span class="line">      <span class="attr">id:</span> <span class="string">cache</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">node_modules</span></span><br><span class="line">        <span class="attr">key:</span> <span class="string">$&#123;&#123;runner.OS&#125;&#125;-$&#123;&#123;hashFiles(&#x27;**/package-lock.json&#x27;)&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span></span><br><span class="line">      <span class="attr">if:</span> <span class="string">steps.cache.outputs.cache-hit</span> <span class="type">!=</span> <span class="string">&#x27;true&#x27;</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        npm install hexo-wordcount hexo-generator-json-content hexo-generator-feed hexo-generator-sitemap hexo-generator-baidu-sitemap --save</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Generate</span> <span class="string">static</span> <span class="string">files</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        hexo clean</span></span><br><span class="line"><span class="string">        hexo generate</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Depoly</span> <span class="string">to</span> <span class="string">Github</span> <span class="string">Pages</span> <span class="comment">#此处master:master 指从本地的master分支提交到远程仓库的master分支，若远程仓库没有对应分支则新建一个。如有其他需要，可以根据自己的需求更改。</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="attr">GIT_NAME:</span> <span class="string">cezz-rm</span></span><br><span class="line">        <span class="attr">GIT_EMAIL:</span> <span class="string">$&#123;&#123;</span> <span class="string">vars.GITHUBS_EMAIL</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">GIT_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">vars.GITHUBS_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="comment">#        REPO: github.com/cezz-rm/$&#123;&#123; env.GITHUBS_PAGENAME &#125;&#125;.github.io.git</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        export TZ=&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line"><span class="string">        cd ./public</span></span><br><span class="line"><span class="string">        git init</span></span><br><span class="line"><span class="string">        git config --global user.name &#x27;$&#123;&#123; vars.GITHUBS_USERNAME &#125;&#125;&#x27;</span></span><br><span class="line"><span class="string">        git config --global user.email &#x27;$&#123;&#123; vars.GITHUBS_EMAIL &#125;&#125;&#x27;</span></span><br><span class="line"><span class="string">        git add .</span></span><br><span class="line"><span class="string">        git commit -m &quot;$&#123;&#123; github.event.head_commit.message &#125;&#125; $(date +&quot;%Z %Y-%m-%d %A %H:%M:%S&quot;) Updated By Github Actions&quot;</span></span><br><span class="line"><span class="string">        git push --force --quiet &quot;https://$&#123;&#123; vars.GITHUBS_USERNAME &#125;&#125;:$&#123;&#123; vars.GITHUBS_TOKEN &#125;&#125;@github.com/$&#123;&#123; vars.GITHUBS_USERNAME &#125;&#125;/$&#123;&#123; vars.GITHUBS_PAGENAME &#125;&#125;.github.io.git&quot; master:master</span></span><br><span class="line"><span class="string"></span><span class="comment">#        git push --force --quiet &quot;https://$&#123;&#123; env.TOKENUSER &#125;&#125;:$&#123;&#123; env.CODINGTOKEN &#125;&#125;@e.coding.net/$&#123;&#123; env.CODINGUSERNAME &#125;&#125;/$&#123;&#123;  env.CODINGBLOGREPO &#125;&#125;.git&quot; master:master #coding部署写法，需要的自行取消注释</span></span><br><span class="line"><span class="comment">#        git push --force --quiet &quot;https://$&#123;&#123; env.GITEEUSERNAME &#125;&#125;:$&#123;&#123; env.GITEETOKEN &#125;&#125;@gitee.com/$&#123;&#123; env.GITEEUSERNAME &#125;&#125;/$&#123;&#123; env.GITEEUSERNAME &#125;&#125;.git&quot; master:master #gitee部署写法，需要的自行取消注释</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注：</strong>配置文件中的分支需与实际情况相对应。</p></blockquote><p><a name="kZn9q"></a></p><h2 id="blog项目配置"><a href="#blog项目配置" class="headerlink" title="blog项目配置"></a>blog项目配置</h2><p>来到仓库下的<code>Settings-&gt;Secrets and variables-&gt;Actions</code>，切换到<code>Variables</code>， 点击<code>New repository variable</code>，新建以下四个变量：</p><ul><li><code>**GITHUBS_USERNAME**</code>：gihub的用户名。</li><li><code>**GITHUBS_EMAIL**</code>：电子邮箱，运行失败会有邮件推送。</li><li><code>**GITHUBS_PAGENAME**</code>：<code>test.github.io</code>中的<strong>test</strong>，按实际情况填写。</li><li><code>**GITHUBS_TOKEN**</code>：填写准备工作中创建的token。</li></ul><img src="/2023/01/15/%E5%85%B6%E4%BB%96/%E4%BD%BF%E7%94%A8Github%20Action%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2Hexo/1-2.png" class="" title="image.png"><p><a name="Rp6NE"></a></p><h2 id="test-github-io项目配置"><a href="#test-github-io项目配置" class="headerlink" title="test.github.io项目配置"></a>test.github.io项目配置</h2><p>来到仓库下的<code>Settings-&gt;Pages</code>下，进行如下相关配置，有域名可绑定域名。<br><a name="Jxkdb"></a></p><h2 id="测试验证"><a href="#测试验证" class="headerlink" title="测试验证"></a>测试验证</h2><p>来到本地存放<code>blog</code>源代码的路径，创建新的文章提交。参考命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;add new blog&quot;</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>去页面上点击该仓库的<code>Actions</code>，可以看到记录了每一次的过程，点击其中一条查看如下：<br /><img src="/2023/01/15/%E5%85%B6%E4%BB%96/%E4%BD%BF%E7%94%A8Github%20Action%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2Hexo/1-3.png" class="" title="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文基于已经创建了hexo的基础，向github action自动化部署迈进。&lt;br /&gt;出于长远考虑，还是应当将blog结合CI进行完善。避免存放hexo源码的电脑重装或者更换带来的不变。&lt;br /&gt;下面将记录自己的部署过程。&lt;br&gt;&lt;a name=&quot;pM4V2&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="其他" scheme="https://zcej.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>vim和echo修改文件的区别</title>
    <link href="https://zcej.github.io/2023/01/08/%E5%85%B6%E4%BB%96/vim%E5%92%8Cecho%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://zcej.github.io/2023/01/08/%E5%85%B6%E4%BB%96/vim%E5%92%8Cecho%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2023-01-08T02:39:11.000Z</published>
    <updated>2023-05-04T10:18:54.946Z</updated>
    
    <content type="html"><![CDATA[<p><a name="cwcUK"></a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近研究filebeat的时候，发现每次修改文件后输出的是文件的全量内容，与自己期望的不太一样，然后又翻看了相关的文章，快速过了下官方文档。得出一个结论，filebeat默认应该是输出的文件增量内容才对，经群里小伙伴的提示才反应过来，问题是不是出在修改文件的方式？果不其然，我个人调试的时候使用的是vim修改文件新增内容的，换成echo的方式后，达到了期望的结果。那么为什么vim不行呢？<br><a name="uExVV"></a></p><h2 id="什么是inode？"><a href="#什么是inode？" class="headerlink" title="什么是inode？"></a>什么是inode？</h2><p>每个文件有一个inode标识，操作系统通过inode的号码来识别不同的文件。unix&#x2F;linux系统内部不使用文件名来识别文件，文件名只是inode号码便于识别的别称。表面上，用户通过文件名打开文件，而实际系统内部将这个过程分为三步：</p><ol><li>首先找到这个文件名对应的inode号码</li><li>其次通过inode号码获取inode信息</li><li>最后根据inode信息，找到文件数据所在的block，读出数据</li></ol><p>查看文件的inode信息可以使用下述命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(venvStudy) [root@node1 filebeat-8.5.2-linux-x86_64]<span class="comment"># stat test.json</span></span><br><span class="line">  File: ‘test.json’</span><br><span class="line">  Size: 963             Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: fd01h/64769d    Inode: 1845136     Links: 1</span><br><span class="line">Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2022-11-14 21:28:48.542300958 +0800</span><br><span class="line">Modify: 2022-11-14 21:28:48.542300958 +0800</span><br><span class="line">Change: 2022-11-14 21:28:48.546301002 +0800</span><br><span class="line"> Birth: -</span><br></pre></td></tr></table></figure><p><strong>猜测使用vim应该是修改inode，而使用echo则不会。</strong><br><a name="nC6LZ"></a></p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>使用vim修改文件内容后，查看文件的inode如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(venvStudy) [root@node1 filebeat-8.5.2-linux-x86_64]<span class="comment"># vim test.json</span></span><br><span class="line">(venvStudy) [root@node1 filebeat-8.5.2-linux-x86_64]<span class="comment"># stat test.json</span></span><br><span class="line">  File: ‘test.json’</span><br><span class="line">  Size: 882             Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: fd01h/64769d    Inode: 1845742     Links: 1</span><br><span class="line">Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2022-11-14 21:35:14.155696874 +0800</span><br><span class="line">Modify: 2022-11-14 21:35:14.155696874 +0800</span><br><span class="line">Change: 2022-11-14 21:35:14.167697004 +0800</span><br><span class="line"> Birth: -</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而使用echo修改文件内容后，查看文件的inode如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(venvStudy) [root@node1 filebeat-8.5.2-linux-x86_64]<span class="comment"># echo &#x27;xxxxx&#x27; &gt;&gt; ./test.json</span></span><br><span class="line">(venvStudy) [root@node1 filebeat-8.5.2-linux-x86_64]<span class="comment"># stat test.json</span></span><br><span class="line">  File: ‘test.json’</span><br><span class="line">  Size: 963             Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: fd01h/64769d    Inode: 1845742     Links: 1</span><br><span class="line">Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2022-11-14 21:35:14.155696874 +0800</span><br><span class="line">Modify: 2022-11-14 21:37:20.004064506 +0800</span><br><span class="line">Change: 2022-11-14 21:37:20.004064506 +0800</span><br><span class="line"> Birth: -</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>确实发现使用vim的话，inode改变了。使用echo则inode保持不变。<br><a name="nSQUb"></a></p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>通过<code>inotifywait</code>监控一下文件的变化，该命令位于<code>inotify-tools</code>下，需要单独安装。<br />源码编译安装的涉及到的命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget http://github.com/downloads/rvoicilas/inotify-tools/inotify-tools-3.14.tar.gz</span><br><span class="line">tar zxvf inotify-tools-3.14.tar.gz</span><br><span class="line"><span class="built_in">cd</span> inotify-tools-3.14</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>其他安装方式见官方文档：<a href="https://github.com/rvoicilas/inotify-tools/wiki#wiki-getting">https://github.com/rvoicilas/inotify-tools/wiki#wiki-getting</a><br />参数说明：</p><ul><li>-m：持续监视变化</li><li>-r：使用递归形式监视目录</li><li>-q：减少冗余信息，只打印出需要的信息</li><li>-e：指定要监视的事件列表</li><li>–timefmt：指定时间的输出格式</li><li>–format：指定文件变化的详细信息</li></ul><p><strong>当使用vim修改文件内容时，inotifywait的输出如下：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 filebeat-8.5.2-linux-x86_64]<span class="comment"># inotifywait -rm ./test.json</span></span><br><span class="line">Setting up watches.  Beware: since -r was given, this may take a <span class="keyword">while</span>!</span><br><span class="line">Watches established.</span><br><span class="line">./test.json OPEN</span><br><span class="line">./test.json ACCESS</span><br><span class="line">./test.json CLOSE_NOWRITE,CLOSE</span><br><span class="line">./test.json MOVE_SELF</span><br><span class="line">./test.json ATTRIB</span><br><span class="line">./test.json DELETE_SELF</span><br></pre></td></tr></table></figure><p>发现最后有<code>DELETE_SELF</code>的操作，此时再修改文件内容时，已经无法监听到了，需要重新监听。<br /><strong>当使用echo修改文件内容时：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 filebeat-8.5.2-linux-x86_64]<span class="comment"># inotifywait -rm ./test.json</span></span><br><span class="line">Setting up watches.  Beware: since -r was given, this may take a <span class="keyword">while</span>!</span><br><span class="line">Watches established.</span><br><span class="line">./test.json OPEN</span><br><span class="line">./test.json MODIFY</span><br><span class="line">./test.json CLOSE_WRITE,CLOSE</span><br></pre></td></tr></table></figure><p>echo只是对文件进行了修改<br /><strong>另外可以监听整个目录的变化，能看到更多信息：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用vim修改发生的变化</span></span><br><span class="line">[root@node1 filebeat-8.5.2-linux-x86_64]<span class="comment"># inotifywait -rm ./</span></span><br><span class="line">Setting up watches.  Beware: since -r was given, this may take a <span class="keyword">while</span>!</span><br><span class="line">Watches established.</span><br><span class="line">./ OPEN test.json</span><br><span class="line">./ CREATE .test.json.swp</span><br><span class="line">./ OPEN .test.json.swp</span><br><span class="line">./ CREATE .test.json.swx</span><br><span class="line">./ OPEN .test.json.swx</span><br><span class="line">./ CLOSE_WRITE,CLOSE .test.json.swx</span><br><span class="line">./ DELETE .test.json.swx</span><br><span class="line">./ CLOSE_WRITE,CLOSE .test.json.swp</span><br><span class="line">./ DELETE .test.json.swp</span><br><span class="line">./ CREATE .test.json.swp</span><br><span class="line">./ OPEN .test.json.swp</span><br><span class="line">./ MODIFY .test.json.swp</span><br><span class="line">./ ATTRIB .test.json.swp</span><br><span class="line">./ CLOSE_NOWRITE,CLOSE test.json</span><br><span class="line">./ OPEN test.json</span><br><span class="line">./ ACCESS test.json</span><br><span class="line">./ CLOSE_NOWRITE,CLOSE test.json</span><br><span class="line">./ OPEN,ISDIR</span><br><span class="line">./ CLOSE_NOWRITE,CLOSE,ISDIR</span><br><span class="line">./ OPEN,ISDIR</span><br><span class="line">./ CLOSE_NOWRITE,CLOSE,ISDIR</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开文件会看到上述信息, 修改内容并保存时输出下面的内容</span></span><br><span class="line">./ CREATE 4913</span><br><span class="line">./ OPEN 4913</span><br><span class="line">./ ATTRIB 4913</span><br><span class="line">./ CLOSE_WRITE,CLOSE 4913</span><br><span class="line">./ DELETE 4913</span><br><span class="line">./ MOVED_FROM test.json</span><br><span class="line">./ MOVED_TO test.json~</span><br><span class="line">./ MODIFY .test.json.swp</span><br><span class="line">./ CREATE test.json</span><br><span class="line">./ OPEN test.json</span><br><span class="line">./ MODIFY test.json</span><br><span class="line">./ CLOSE_WRITE,CLOSE test.json</span><br><span class="line">./ ATTRIB test.json</span><br><span class="line">./ MODIFY .test.json.swp</span><br><span class="line">./ DELETE test.json~</span><br></pre></td></tr></table></figure><p>发现保存的时候执行了<code>MOVED_TO test.json~</code>，并新建了一个<code>test.json</code>文件。</p><p><strong>有没有什么方式使用vim但是也不会修改inode呢？</strong><br />有两种方式：</p><ul><li><p>和文件权限有关：<code>chmod o+w test.json</code> </p></li><li><p>修改vim设置，关闭其备份：<code>set nobackup nowritebackup</code>，关闭后保存时不会生成<code>test.json~</code>文件<br><a name="HWEgC"></a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></li><li><p>vim修改是产生了新的文件，inode发送了改变，而echo不会。</p></li><li><p>vim保存时会产生带~后缀的文件，这个文件是保存时生成，正常保存该文件会被立即删除</p></li><li><p>若文件其他用户有write权限(<code>chmod o+w xxx</code>)，vim编辑时inode不会发生改变</p></li><li><p>关闭vim备份时，inode信息也不会发生改变</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a name=&quot;cwcUK&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近研究filebeat的时候，发现每次修改文件后输出的是文件的全量内容，与自己期望</summary>
      
    
    
    
    <category term="其他" scheme="https://zcej.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>2022总结</title>
    <link href="https://zcej.github.io/2022/12/28/%E5%85%B6%E4%BB%96/2022%E6%80%BB%E7%BB%93/"/>
    <id>https://zcej.github.io/2022/12/28/%E5%85%B6%E4%BB%96/2022%E6%80%BB%E7%BB%93/</id>
    <published>2022-12-28T14:47:21.000Z</published>
    <updated>2023-05-04T10:08:54.621Z</updated>
    
    <content type="html"><![CDATA[<p><a name="LX8aK"></a></p><h3 id="工作与学习"><a href="#工作与学习" class="headerlink" title="工作与学习"></a>工作与学习</h3><p>这一年比较笼统，回头来感觉做了很多又很多都没做。不过值得庆幸的是坚持整理了自己的博客，也算是学习过程的记录，虽然质量数量都比较一般，不过对比前几年感觉好多了，前几年也有断断续续的写了些，但更像草稿般，只有自己看得懂的那种。到了年底翻一翻这一年来的博客，还是颇有感慨。未来的一年也必须得坚持下去！</p><p>工作上印象比较深的一件事是被拉去参加了护网行动，主要工作基于suricata写一些漏洞或工具特征的流量检测规则，还是有不小的收获，对抓包分析越来越熟了，还有初步学习了sqlmap，pocsuite3，冰蝎等之前自己没有用过的工具。不过还是要吐槽下工作那几天，当时正值夏天周末去加班的时候缺没有空调，真是热的不行。</p><p>感觉自己今年最大的学习成果不是说学会了什么什么，而是学习的思维上不一样了，能够更加看透一些本质问题，快速的掌握新的东西，但是不足的地方也很多，一个是还不够深入，另一个是不同知识点之间的整合，灵活性还不够。之和结合工作和私下的学习再加强吧。<br><a name="Q0pCG"></a></p><h3 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h3><p>今年的疫情也是断断续续，依旧是每隔三天都要做一次核酸，有一次北京的比较严重好几个区都居家办公了大概两周的时间(没记错的话是在5月的时候)，不过没想到到年底政策有所改变，已经放开了。真是来了个大转变让人猝不及防，自己也成了第一波中招的人，当时也挺无助的，没有退烧药、体温计和抗原，可以说什么都没准备好。第一时间还不知道是不是阳了，硬是顶着持续不断的头疼上了一天班，后续有舍友给了连花清瘟和抗原，真是雪中送炭，非常感谢。</p><p>另外在9月的时候房子也快到期了，还出去找了一段时间的房子，最终也没有选择公司附近的，还是太贵了三千多一间还只有10平左右。最终还是续租了，虽然算下来加上交通费一个月也没便宜多少，但是想着习惯了周边环境，加上自己的东西变得越来越多了，也就懒得搬了。另外还得提一句在前几天得知另外一个合租两年多的广东室友准备退租回老家了，自己内心也是十分感慨自己未来的出路，不过走一步看一步吧。</p><p>还有就是今年的世界杯印象比较深刻，在同事的带领下之前从来不看足球的我居然也完整的看了几场，或许是买了10块20块的原因，参与感十足，不过比赛确实非常精彩。</p><p>最后值得一提的自从去年慢慢的入了海贼手办的坑，目前已经买了十多套海贼王的wcf，谁能想到一个小小的手办居然还挺贵，放在一起倒挺壮观的，有时候从柜子里拿出来看看盒子还挺开心。比较可惜的由于租房的空间不是很大，我只零散的拆了一两个，以后整租的时候再每天拆上一个吧，泪目。另外由于摆放不下的原因，海贼手办界的天花板popmax也暂时放弃了，不知道未来我的第一个popmax是谁。慢慢的期待后续手办作品吧，不敢想象海贼完结的那一天！<br><a name="TwbOD"></a></p><h3 id="明年的计划"><a href="#明年的计划" class="headerlink" title="明年的计划"></a>明年的计划</h3><ol><li>学习某些新技术的时候坚持整理总结，输出文章，每月至少3篇吧！ </li><li>快速过下java，再把前端的技术点捡回来，页面上的是最直观的，便于我之后在写点什么页面吧 </li><li>时间充裕的话还想学下日语，海贼火影死神龙珠妖尾可都是青春 </li><li>有机会整租一个吧 </li><li>健身！健身！健身！ </li><li>如果允许的话我还想找个女朋友，哈哈 <blockquote><p>写这个总结感觉比较零碎，感觉加上时间线会好很多，这就得平常就开始积累，而不是年底写了，立个flag吧，23年的总结加上时间线！条件允许的话再上点照片。</p></blockquote></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a name=&quot;LX8aK&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;工作与学习&quot;&gt;&lt;a href=&quot;#工作与学习&quot; class=&quot;headerlink&quot; title=&quot;工作与学习&quot;&gt;&lt;/a&gt;工作与学习&lt;/h3&gt;&lt;p&gt;这一年比较笼统，回头来感觉做了很多又很多都没做。不过值得庆幸</summary>
      
    
    
    
    <category term="其他" scheme="https://zcej.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>Nginx配置basic-auth</title>
    <link href="https://zcej.github.io/2022/12/16/%E5%85%B6%E4%BB%96/Nginx%E9%85%8D%E7%BD%AEbasic-auth/"/>
    <id>https://zcej.github.io/2022/12/16/%E5%85%B6%E4%BB%96/Nginx%E9%85%8D%E7%BD%AEbasic-auth/</id>
    <published>2022-12-16T15:03:45.000Z</published>
    <updated>2023-05-04T10:05:51.070Z</updated>
    
    <content type="html"><![CDATA[<p>在部署web应用服务后，很多场景下需要进行身份认证和访问控制的相关配置，只有在访问者输入了正确的用户密码才允许访问web内容。在这里记录下nginx的简单配置，基于模块<code>ngx_http_auth_basic_module</code>通过使用HTTP基本认证协议验证用户名和密码来限制对资源的访问。<br><a name="sEHHo"></a></p><h3 id="Nginx认证配置实例"><a href="#Nginx认证配置实例" class="headerlink" title="Nginx认证配置实例"></a>Nginx认证配置实例</h3><p><a name="YQC2H"></a></p><h4 id="1-生成认证文件"><a href="#1-生成认证文件" class="headerlink" title="1. 生成认证文件"></a>1. 生成认证文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># printf &quot;test:$(openssl passwd -crypt 123456)\n&quot; &gt;&gt;/home/htpasswd</span></span><br><span class="line"><span class="comment"># cat /home/htpasswd </span></span><br><span class="line"><span class="built_in">test</span>:xyJkVhXGAZ8tM</span><br></pre></td></tr></table></figure><p><a name="Gi163"></a></p><h4 id="2-配置nignx-conf文件"><a href="#2-配置nignx-conf文件" class="headerlink" title="2. 配置nignx.conf文件"></a>2. 配置nignx.conf文件</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">38443</span>;       </span><br><span class="line">    <span class="section">location</span> /</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attribute">auth_basic</span> <span class="string">&quot;Please enter your username and password&quot;</span>;</span><br><span class="line">        <span class="attribute">auth_basic_user_file</span> /home/htpasswd; </span><br><span class="line">        <span class="attribute">autoindex</span> <span class="literal">on</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="V9exW"></a></p><h4 id="3-重启nginx并验证"><a href="#3-重启nginx并验证" class="headerlink" title="3. 重启nginx并验证"></a>3. 重启nginx并验证</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/nginx restart</span><br><span class="line"></span><br><span class="line">nginx -t # 测试配置是否有误</span><br><span class="line">nginx -s reload # 载入配置文件</span><br></pre></td></tr></table></figure><p><a name="rAWEm"></a></p><h3 id="指定目录设置访问认证"><a href="#指定目录设置访问认证" class="headerlink" title="指定目录设置访问认证"></a>指定目录设置访问认证</h3><p><a name="p54XV"></a></p><h4 id="1-创建类htpassswd文件"><a href="#1-创建类htpassswd文件" class="headerlink" title="1. 创建类htpassswd文件"></a>1. 创建类htpassswd文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -c https://www.moerats.com/usr/down/htpasswd.sh;bash htpasswd.sh</span><br></pre></td></tr></table></figure><p>按照提示输入用户名，密码及认证名。脚本会自动生成认证文件。<br><a name="Z99lF"></a></p><h4 id="2-配置nginx-conf文件"><a href="#2-配置nginx-conf文件" class="headerlink" title="2. 配置nginx.conf文件"></a>2. 配置nginx.conf文件</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span><span class="regexp"> ^~</span> /src/</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">auth_basic</span> <span class="string">&quot;Authorized users only&quot;</span>;</span><br><span class="line">    <span class="attribute">auth_basic_user_file</span> 这里写前面脚本返回的文件路径;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后再按照上述方式进行重启验证即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在部署web应用服务后，很多场景下需要进行身份认证和访问控制的相关配置，只有在访问者输入了正确的用户密码才允许访问web内容。在这里记录下nginx的简单配置，基于模块&lt;code&gt;ngx_http_auth_basic_module&lt;/code&gt;通过使用HTTP基本认证协议</summary>
      
    
    
    
    <category term="其他" scheme="https://zcej.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>(转)Docker网络回顾</title>
    <link href="https://zcej.github.io/2022/12/11/docker/(%E8%BD%AC)Docker%E7%BD%91%E7%BB%9C%E5%9B%9E%E9%A1%BE/"/>
    <id>https://zcej.github.io/2022/12/11/docker/(%E8%BD%AC)Docker%E7%BD%91%E7%BB%9C%E5%9B%9E%E9%A1%BE/</id>
    <published>2022-12-11T08:30:09.000Z</published>
    <updated>2023-05-04T10:01:57.963Z</updated>
    
    <content type="html"><![CDATA[<p>出自：<a href="https://juejin.cn/post/7041923410649153543">https://juejin.cn/post/7041923410649153543</a><br />个人感觉作者这块总结的不错，转载下以便之后个人回顾。<br><a name="Ta5Ub"></a></p><h2 id="Docker网络基础"><a href="#Docker网络基础" class="headerlink" title="Docker网络基础"></a>Docker网络基础</h2><ul><li>docker使用Linux桥接网卡，在宿主机虚拟一个docker容器网桥（docker0），docker启动一个容器时会根据docker网桥的网段分配给容器一个IP地址，称为Container-IP，同时Docker网桥是每个容器的默认网络网关。因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的Container-IP直接通信。</li><li>docker网桥是宿主机虚拟出来的，并不是真实存在的网络设备，外部网络是无法寻址到的，这也意味着外部网络无法通过直接Container-IP访问到容器。</li><li>如果容器希望外部访问能够访问到，可以通过映射容器端口到宿主主机(端口映射)，即docker run创建容器时候通过-p或-P参数来启用，访问容器的时候就通过宿主机IP:容器端口访问容器。<br><a name="cg9vl"></a><h2 id="Docker网络模式"><a href="#Docker网络模式" class="headerlink" title="Docker网络模式"></a>Docker网络模式</h2><table><thead><tr><th><strong>Docker网络模式</strong></th><th><strong>配置</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>host模式</td><td>-net&#x3D;host</td><td>容器和宿主机共享<code>Network namespace</code>，<br />容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。</td></tr><tr><td>container模式</td><td>-net&#x3D;container:Name_or_ID</td><td>容器和另外一个容器共享<code>Network namespace</code>。<br />kubernetes中的pod就是多个容器共享一个Network namespace。<br />创建的容器不会创建自己的网卡，配置自己的IP，而是和<code>一个指定的容器共享IP、端口范围</code>。</td></tr><tr><td>none模式</td><td>-net&#x3D;none</td><td>容器有独立的Network namespace，并没有对其进行任何网络设置，如分配veth pair和网桥连接，配置IP等。<code>该模式关闭了容器的网络功能</code>。</td></tr><tr><td>bridge模式</td><td>-net&#x3D;bridge</td><td>（默认模式）。此模式会为每一个容器分配、设置IP等，并将容器连接到一个<code>docker0虚拟网桥</code>，通过<code>docker0网桥</code>以及<code>Iptable nat</code>表配置与宿主机通信。</td></tr><tr><td>Macvlan network</td><td>无</td><td>容器具备Mac地址，使其显示为网络上的物理设备</td></tr><tr><td>Overlay</td><td>无</td><td>（覆盖网络）：利用VXLAN实现的bridge模式</td></tr></tbody></table></li></ul><p><a name="N9xKv"></a></p><h3 id="Bridge模式"><a href="#Bridge模式" class="headerlink" title="Bridge模式"></a>Bridge模式</h3><p>默认的网络模式。bridge模式下容器没有一个公有ip,只有宿主机可以直接访问,外部主机是不可见的,但容器通过宿主机的NAT规则后可以访问外网。<br><a name="dqVzg"></a></p><h4 id="Bridge桥接模式的实现步骤"><a href="#Bridge桥接模式的实现步骤" class="headerlink" title="Bridge桥接模式的实现步骤"></a>Bridge桥接模式的实现步骤</h4><ul><li>Docker Daemon利用veth pair技术，在宿主机上创建两个虚拟网络接口设备，假设为veth0 和veth1。而veth pair技术的特性可以保证无论哪一个veth接收到网络报文，都会将报文传输给另一方。</li><li>Docker Daemon将veth0附加到Docker Daemon创建的docker0网桥上。保证宿主机的网络报 文可以发往veth0;</li><li>Docker Daemon 将veth1添加到Docker Container所属的namespace下，并被改名为eth0。 如此一来，保证宿主机的网络报文若发往veth0则立即会被eth0接收，实现宿主机到Docker Container网络的联通性;同时也保证Docker Container单独使用eth0，实现容器网络环境的隔离性。<br><a name="pIwjt"></a><h4 id="Bridge桥接模式的缺陷"><a href="#Bridge桥接模式的缺陷" class="headerlink" title="Bridge桥接模式的缺陷"></a>Bridge桥接模式的缺陷</h4>Docker Container不具有一个公有IP，即和宿主机eth0不处于同一个网段。导致的结果是宿主机以外的世界不能直接和容器进行通信。<blockquote><p>注：eth设备是成双成对出现的，一端是容器内部命名为eth0，一端是加入到网桥并命名的veth(通常命名为veth)，它们组成了一个数据传输通道，一端进一端出，veth设备连接了两个网络设备并实现了数据通信。</p></blockquote></li></ul><p><a name="ak5bQ"></a></p><h3 id="Host网络模式"><a href="#Host网络模式" class="headerlink" title="Host网络模式"></a>Host网络模式</h3><ul><li><p>host模式相当于Vmware中的NAT模式，与宿主机在同一个网络中，但没有独立IP地址。</p></li><li><p>启动容器使用host模式，容器将不会获得一个独立的Network Namespace，而是和宿主机共用一个Network Namespace。</p></li><li><p>容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。除此之外容器的其他方面，比如文件系统、进程列表等还是和宿主机隔离。</p></li><li><p>使用host模式的容器可以直接使用宿主机的IP地址与外界通信，容器内部的服务端口也可以使用宿主机的端口，不需要进行NAT，host最大的优势就是网络性能比较好，docker host上已经使用的端口就不能再用了，网络的隔离性不好。</p></li><li><p>host网络模式需要在容器创建时指定–network&#x3D;host</p></li><li><p>host模式是bridge桥接模式很好的补充。采用host模式的Docker Container，可以直接使用宿主机的IP地址与外界进行通信，若宿主机的eth0是一个公有IP，那么容器也拥有这个公有IP。同时容器内服务的端口也可以使用宿主机的端口，无需额外进行NAT转换。</p></li><li><p>host模式可以让容器共享宿主机网络栈,这样的好处是外部主机与容器直接通信,但是容器的网络缺少隔离性。<br><a name="CfS3u"></a></p><h4 id="Host网络模式的缺陷"><a href="#Host网络模式的缺陷" class="headerlink" title="Host网络模式的缺陷"></a>Host网络模式的缺陷</h4><p>使用Host模式的容器不再拥有隔离、独立的网络环境。虽然可以让容器内部的服务和传统情况无差别、无改造的使用，但是由于网络隔离性的弱化，该容器会与宿主机共享竞争网络栈的使用; 另外，容器内部将不再拥有所有的端口资源，原因是部分端口资源已经被宿主机本身的服务占用，还有部分端口已经用以bridge网络模式容器的端口映射。<br><a name="Pbn8f"></a></p><h3 id="Container网络模式"><a href="#Container网络模式" class="headerlink" title="Container网络模式"></a>Container网络模式</h3><p>Container网络模式没有改善容器与宿主机以外世界通信的情况(和桥接模式一样，不能连接宿主机以外的其他设备)。<br />这个模式指定新创建的容器和已经存在的一个容器共享一个Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。 同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过lo网卡设备通信。<br><a name="wHvFY"></a></p><h3 id="None模式"><a href="#None模式" class="headerlink" title="None模式"></a>None模式</h3><p>使用none模式，Docker容器拥有自己的Network Namespace，但是，并不为Docker容器进行任何网络配置。Docker容器没有网卡、IP、路由等信息。需要我们自己为Docker容器添加网卡、配置IP等。<br />这种网络模式下容器只有lo回环网络，没有其他网卡。none模式可以在容器创建时通过– network&#x3D;none来指定。这种类型的网络没有办法联网，封闭的网络能很好的保证容器的安全性<br><a name="VNMC9"></a></p><h2 id="网络基本用法"><a href="#网络基本用法" class="headerlink" title="网络基本用法"></a>网络基本用法</h2><p>（这部分稍作改动）。<br><a name="kX6fn"></a></p><h4 id="镜像拉取与容器创建"><a href="#镜像拉取与容器创建" class="headerlink" title="镜像拉取与容器创建"></a>镜像拉取与容器创建</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拉取镜像</span></span><br><span class="line">docker pull nginx:1.19.3-alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行镜像</span></span><br><span class="line">docker run -itd -name nginx1 nginx:1.19.3-alpine</span><br></pre></td></tr></table></figure><p>其创建流程如下：</p></li><li><p>创建一对虚拟接口&#x2F;网卡，也就是veth pair，分别放到本地主机和新容器中;</p></li><li><p>本地主机一端桥接到默认的 docker0 或指定网桥上，并具有一个唯一的名字，如 vetha596da4;</p></li><li><p>容器一端放到新容器中，并修改名字作为 eth0，这个网卡&#x2F;接口只在容器的名字空间可见;</p></li><li><p>从网桥可用地址段中(也就是与该bridge对应的network)获取一个空闲地址分配给容器的 eth0，并配置默认路由到桥接网卡 vetha596da4。</p></li><li><p>容器就可以使用 eth0 虚拟网卡来连接其他容器和其他网络。 如果不指定–network，创建的容器默认都会挂到 docker0 上，使用本地主机上 docker0 接口的 IP 作为 所有容器的默认网关。<br><a name="oF1AX"></a></p><h4 id="多容器之间通讯"><a href="#多容器之间通讯" class="headerlink" title="多容器之间通讯"></a>多容器之间通讯</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd -name nginx1 nginx:1.19.3-alpine</span><br><span class="line"></span><br><span class="line">docker run -itd -name nginx2 nginx:1.19.3-alpine</span><br><span class="line"></span><br><span class="line">docker network inspect bridge</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建bridge网络, 并将一个运行中的容器连接到该网络</span></span><br><span class="line">docker network create -d bridge test-bridge</span><br><span class="line"></span><br><span class="line">docker run -itd -name nginx3 -network test-bridge nginx:1.19.3-alpine</span><br><span class="line"></span><br><span class="line">docker network inspect test-bridge</span><br><span class="line"></span><br><span class="line">docker network connect test-bridge nginx2</span><br></pre></td></tr></table></figure><p><a name="YHWjm"></a></p><h2 id="Docker网络命令汇总"><a href="#Docker网络命令汇总" class="headerlink" title="Docker网络命令汇总"></a>Docker网络命令汇总</h2><p>（这部分稍作改动）。<br />个人感觉这部分有哪些命令不知道的，直接<code>-h</code>看一下或者查阅官方文档是最好的。<br />如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]<span class="comment"># docker network -h</span></span><br><span class="line">Flag shorthand -h has been deprecated, please use --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">Usage:  docker network COMMAND</span><br><span class="line"></span><br><span class="line">Manage networks</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  connect     Connect a container to a network</span><br><span class="line">  create      Create a network</span><br><span class="line">  disconnect  Disconnect a container from a network</span><br><span class="line">  inspect     Display detailed information on one or more networks</span><br><span class="line">  <span class="built_in">ls</span>          List networks</span><br><span class="line">  prune       Remove all unused networks</span><br><span class="line">  <span class="built_in">rm</span>          Remove one or more networks</span><br><span class="line"></span><br><span class="line">Run <span class="string">&#x27;docker network COMMAND --help&#x27;</span> <span class="keyword">for</span> more information on a <span class="built_in">command</span>.</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;出自：&lt;a href=&quot;https://juejin.cn/post/7041923410649153543&quot;&gt;https://juejin.cn/post/7041923410649153543&lt;/a&gt;&lt;br /&gt;个人感觉作者这块总结的不错，转载下以便之后个人回顾。&lt;br</summary>
      
    
    
    
    <category term="docker" scheme="https://zcej.github.io/categories/docker/"/>
    
    
  </entry>
  
  <entry>
    <title>naabu源码分析</title>
    <link href="https://zcej.github.io/2022/11/18/go/naabu%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://zcej.github.io/2022/11/18/go/naabu%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2022-11-18T12:06:18.000Z</published>
    <updated>2023-05-04T09:58:02.052Z</updated>
    
    <content type="html"><![CDATA[<p><a name="F7ypG"></a></p><h2 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">使用方法:</span><br><span class="line">./naabu-2.1.1 [flags]</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">INPUT:</span><br><span class="line">-host string[]              扫描目标, 支持域名或IP地址</span><br><span class="line">-list, -l string            从文件读取扫描目标 (file)</span><br><span class="line">-exclude-hosts, -eh string  排除扫描目标, 以逗号分隔</span><br><span class="line">-exclude-file, -ef string   从文件读取要排除的扫描目标 (file)</span><br><span class="line"></span><br><span class="line">PORT:</span><br><span class="line">-port, -p string            指定扫描端口 (80,443, 100-200)</span><br><span class="line">-top-ports, -tp string      默认top100 (default 100)</span><br><span class="line">-exclude-ports, -ep string  需要排除的扫描端口, 以逗号分隔</span><br><span class="line">-ports-file, -pf string     从文件读取扫描端口 (file)</span><br><span class="line">-port-threshold, -pts int   跳过主机端口扫描的端口阈值 (暂不知道作用)</span><br><span class="line">-exclude-cdn, -ec           跳过 CDN 的完整端口扫描 (只检查 80,443)</span><br><span class="line">-display-cdn, -cdn          展示正在使用的cdn</span><br><span class="line"></span><br><span class="line">RATE-LIMIT:</span><br><span class="line">-c int     general internal worker threads (default 25)</span><br><span class="line">-rate int  packets to send per second (default 1000)</span><br><span class="line"></span><br><span class="line">OUTPUT:</span><br><span class="line">-o, -output string  指定结果输出文件 (可选参数)</span><br><span class="line">-json               以json格式输出结果</span><br><span class="line">-csv                以csv格式输出结果</span><br><span class="line"></span><br><span class="line">CONFIGURATION:</span><br><span class="line">-scan-all-ips, -sa                  扫描与dns记录的所有ip</span><br><span class="line">-ip-version, -iv string[]           指定ipv4还是ipv6 - (default 4)</span><br><span class="line">-scan-type, -s string               扫描类型, 默认syn半连接 (SYN/CONNECT)</span><br><span class="line">-source-ip string                   来源IP端口 (x.x.x.x:yyy)</span><br><span class="line">-interface-list, -il                列出可用网卡和公共IP</span><br><span class="line">-interface, -i string               指定用于端口扫描的网卡</span><br><span class="line">-nmap                               直接调用namp扫描, 需注意已标位弃用 (nmap must be installed) - Deprecated</span><br><span class="line">-nmap-cli string                    对找到的结果运行nmap命令 (example: -nmap-cli <span class="string">&#x27;nmap -sV&#x27;</span>)</span><br><span class="line">-r string                           自定义域名解析 (comma separated or from file)</span><br><span class="line">-proxy string                       socks5 代理 (ip[:port] / fqdn[:port]</span><br><span class="line">-proxy-auth string                  socks5 代理认证 (username:password)</span><br><span class="line">-resume                             通过resume.cfg恢复扫描</span><br><span class="line">-stream                             流模式 (disables resume, nmap, verify, retries, shuffling, etc)</span><br><span class="line">-passive                            使用shodan的数据接口显示被动开放端口</span><br><span class="line">-irt, -input-read-timeout duration  输入超时时间 (default 3m0s)</span><br><span class="line">-no-stdin                           禁用标准处理</span><br><span class="line"></span><br><span class="line">HOST-DISCOVERY:</span><br><span class="line">-sn, -host-discovery           仅执行主机探活</span><br><span class="line">-Pn, -skip-host-discovery      跳过主机探活</span><br><span class="line">-ps, -probe-tcp-syn string[]   TCP SYN Ping (host discovery needs to be enabled)</span><br><span class="line">-pa, -probe-tcp-ack string[]   TCP ACK Ping (host discovery needs to be enabled)</span><br><span class="line">-pe, -probe-icmp-echo          ICMP <span class="built_in">echo</span> request Ping (host discovery needs to be enabled)</span><br><span class="line">-pp, -probe-icmp-timestamp     ICMP timestamp request Ping (host discovery needs to be enabled)</span><br><span class="line">-pm, -probe-icmp-address-mask  ICMP address mask request Ping (host discovery needs to be enabled)</span><br><span class="line">-arp, -arp-ping                ARP ping (host discovery needs to be enabled)</span><br><span class="line">-nd, -nd-ping                  IPv6 Neighbor Discovery (host discovery needs to be enabled)</span><br><span class="line"></span><br><span class="line">OPTIMIZATION:</span><br><span class="line">-retries int       端口扫描重试次数 (default 3)</span><br><span class="line">-<span class="built_in">timeout</span> int       超时等待时间, 单位为毫秒 (default 1000)</span><br><span class="line">-warm-up-time int  扫描阶段之间的时间 (default 2)</span><br><span class="line">-ping              进行ping探活</span><br><span class="line">-verify            使用tcp再次验证端口</span><br><span class="line"></span><br><span class="line">DEBUG:</span><br><span class="line">-health-check, -hc        run diagnostic check up</span><br><span class="line">-debug                    显示调试信息</span><br><span class="line">-verbose, -v              展示详细输出</span><br><span class="line">-no-color, -nc            在cli输出禁用着色</span><br><span class="line">-silent                   在输出中仅展示结果</span><br><span class="line">-version                  显示naabu的版本</span><br><span class="line">-stats                    显示运行扫描的状态</span><br><span class="line">-si, -stats-interval int  显示统计信息更新之间等待的秒数 (default 5)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="RrwwR"></a></p><h2 id="目录文件说明"><a href="#目录文件说明" class="headerlink" title="目录文件说明"></a>目录文件说明</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">├─cmd</span><br><span class="line">    │  ├─functional-test</span><br><span class="line">    │  │  │  main.go</span><br><span class="line">    │  │  │  run.sh</span><br><span class="line">    │  │  │  testcases.txt</span><br><span class="line">    │  │  │</span><br><span class="line">    │  │  └─test-data</span><br><span class="line">    │  │      request.txt</span><br><span class="line">    │  │</span><br><span class="line">    │  ├─integration-test</span><br><span class="line">    │  │   integration-test.go</span><br><span class="line">    │  │   library.go</span><br><span class="line">    │  │</span><br><span class="line">    │  └─naabu</span><br><span class="line">    │      main.go</span><br><span class="line">    │</span><br><span class="line">    ├─internal</span><br><span class="line">    │  └─testutils</span><br><span class="line">    │      integration.go</span><br><span class="line">    │</span><br><span class="line">    └─pkg</span><br><span class="line">        ├─israce // 竞争检测</span><br><span class="line">        │   norace.go </span><br><span class="line">        │   race.go</span><br><span class="line">        │</span><br><span class="line">        ├─privileges  // 权限判定, 在windows, linux, darwin下是否具有相应的权限, syn扫描或全连接扫描</span><br><span class="line">        │   privileges.go</span><br><span class="line">        │   privileges_darwin.go</span><br><span class="line">        │   privileges_linux.go</span><br><span class="line">        │   privileges_win.go</span><br><span class="line">        │</span><br><span class="line">        ├─result</span><br><span class="line">        │   results.go  // 定义Result结构体</span><br><span class="line">        │   results_test.go</span><br><span class="line">        │</span><br><span class="line">        ├─routing  // 根据不同的操作系统选择不同的路由</span><br><span class="line">        │   router.go</span><br><span class="line">        │   router_darwin.go</span><br><span class="line">        │   router_linux.go</span><br><span class="line">        │   router_windows.go</span><br><span class="line">        │</span><br><span class="line">        ├─runner</span><br><span class="line">        │   banners.go      // 控制台输出运行信息, 网络环境, 扫描类型及网卡信息</span><br><span class="line">        │   banners_test.go</span><br><span class="line">        │   default.go      // 定义运行时的一些默认值, 如超时, 速率, 重试次数等</span><br><span class="line">        │   healthcheck.go  // 进行naabu锁依赖的环境运行检查</span><br><span class="line">        │   ips.go          // ip地址解析, 排除不在设置范围内的</span><br><span class="line">        │   ips_test.go</span><br><span class="line">        │   nmap.go         // 解析参数(nmap-cli), 并调用nmap </span><br><span class="line">        │   nmap_test.go</span><br><span class="line">        │   options.go      // 命令行参数解析到结构体对象Options</span><br><span class="line">        │   output.go       // 定义Result结构体及将结果写文件保存的相关方法</span><br><span class="line">        │   output_test.go</span><br><span class="line">        │   ports.go        // 定义常见端口, 以及解析端口的方法</span><br><span class="line">        │   ports_test.go </span><br><span class="line">        │   resume.go       // 定义结构体ResumeCfg, 以及保存/读取/删除恢复配置文件</span><br><span class="line">        │   runner.go       // 定义结构体Runner, 运行调度的核心, 还包括结果的处理等</span><br><span class="line">        │   targets.go      // 目标对象解析,添加处理等, 保存到runner结构体对象中</span><br><span class="line">        │   targets_test.go</span><br><span class="line">        │   util.go         // 主要包括host转ip方法, 以及判断os是否支持的函数</span><br><span class="line">        │   util_test.go</span><br><span class="line">        │   validate.go     // 参数校验认证</span><br><span class="line">        │   validate_test.go</span><br><span class="line">        │</span><br><span class="line">        ├─scan</span><br><span class="line">        │   arp.go          // arp报文组织发送</span><br><span class="line">        │   cdn.go          // 检查传入的IP是否为cdn</span><br><span class="line">        │   cdn_test.go</span><br><span class="line">        │   connect.go      // 建立完整的tcp连接, 用于判断端口是否开放</span><br><span class="line">        │   connect_test.go</span><br><span class="line">        │   externalip.go   // 通过公共api获取自己的ip出口地址</span><br><span class="line">        │   externalip_test.go</span><br><span class="line">        │   icmp.go         // 几种类型的icmp报文组织</span><br><span class="line">        │   ndp.go          // ndp报文类型组织</span><br><span class="line">        │   option.go       // 扫描的配置(超时时间,重试,速率,输出等配置)</span><br><span class="line">        │   ping.go         // ping报文组织及发送</span><br><span class="line">        │   ping_test.go</span><br><span class="line">        │   scan.go         // 定义scanner结构体, 另外包括各个扫描部分的调度</span><br><span class="line">        │   scan_unix.go    // 在linux下</span><br><span class="line">        │   tcpsequencer.go //  </span><br><span class="line">        │   tcpsequencer_test.go</span><br><span class="line">        │</span><br><span class="line">        └─utils</span><br><span class="line">            util.go</span><br></pre></td></tr></table></figure><p><a name="EpMbF"></a></p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>先看下项目依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">require (</span><br><span class="line">github.com/google/gopacket v1.1.19                                              // libpcap的go实现</span><br><span class="line">github.com/phayes/freeport v0.0.0-20180830031419-95f893ade6f2                   // 获取一个可用于tcp的端口</span><br><span class="line">github.com/projectdiscovery/blackrock v0.0.0-20220628111055-35616c71b2dc        // 伪随机的方式访问空间中的元素一次</span><br><span class="line">github.com/projectdiscovery/cdncheck v0.0.4-0.20220322144854-b2d8ce308abb       // 检查给定IP是否属于已知cnd范围内</span><br><span class="line">github.com/projectdiscovery/clistats v0.0.8                                     // 命令行统计信息展示</span><br><span class="line">github.com/projectdiscovery/fdmax v0.0.3                                        // 动态修改最大文件描述符</span><br><span class="line">github.com/projectdiscovery/fileutil v0.0.3                                     // 文件处理工具</span><br><span class="line">github.com/projectdiscovery/goflags v0.1.1                                      // 命令行参数解析</span><br><span class="line">github.com/projectdiscovery/gologger v1.1.4                                     // 日志处理</span><br><span class="line">github.com/projectdiscovery/iputil v0.0.0-20220712175312-b9406f31cdd8           // 用于处理ips和cidr</span><br><span class="line">github.com/projectdiscovery/networkpolicy v0.0.2-0.20220525172507-b844eafc878d  // 网络代理</span><br><span class="line">github.com/remeh/sizedwaitgroup v1.0.0                                          // 速率控制</span><br><span class="line">//go.uber.org/ratelimit v0.2.0 // indirect                                      // 速率控制</span><br><span class="line">golang.org/x/net v0.1.0                                                         // go网络库的补充</span><br><span class="line">golang.org/x/sys v0.1.0                                                         // 与操作系统低级别交互的go补充包</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><a name="LKEb4"></a></p><h3 id="程序入口"><a href="#程序入口" class="headerlink" title="程序入口"></a>程序入口</h3><p><code>cmd/naabu/main.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 1. 解析命令行参数或从配置文件读取</span></span><br><span class="line">options := runner.ParseOptions()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 新建runner</span></span><br><span class="line">naabuRunner, err := runner.NewRunner(options)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">gologger.Fatal().Msgf(<span class="string">&quot;Could not create runner: %s\n&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 3. 读取退出信号, 优雅退出</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">signal.Notify(c, os.Interrupt)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> c &#123;</span><br><span class="line">            <span class="comment">// 退出时打印结果</span></span><br><span class="line">naabuRunner.ShowScanResultOnExit()</span><br><span class="line">gologger.Info().Msgf(<span class="string">&quot;CTRL+C pressed: Exiting\n&quot;</span>)</span><br><span class="line">            <span class="comment">// 若是配置了恢复文件, 则进行恢复</span></span><br><span class="line"><span class="keyword">if</span> options.ResumeCfg.ShouldSaveResume() &#123;</span><br><span class="line">gologger.Info().Msgf(<span class="string">&quot;Creating resume file: %s\n&quot;</span>, runner.DefaultResumeFilePath())</span><br><span class="line">err := options.ResumeCfg.SaveResumeConfig()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">gologger.Error().Msgf(<span class="string">&quot;Couldn&#x27;t create resume file: %s\n&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">// 退出时关闭runner</span></span><br><span class="line">naabuRunner.Close()</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 扫描核心</span></span><br><span class="line">err = naabuRunner.RunEnumeration()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">gologger.Fatal().Msgf(<span class="string">&quot;Could not run enumeration: %s\n&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 完成后清除重启配置</span></span><br><span class="line"><span class="comment">// on successful execution remove the resume file in case it exists</span></span><br><span class="line">options.ResumeCfg.CleanupResumeConfig()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>pkg/runner/runner.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Runner)</span></span> RunEnumeration() <span class="type">error</span> &#123;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// 1.如果支持syn半连接扫描</span></span><br><span class="line">    <span class="keyword">if</span> privileges.IsPrivileged $$ r.options.ScanType == SynScan &#123;...&#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 2.设置了steam, 没太看懂这个有什么作用, 个人实际运行中添加了该参数会报错</span></span><br><span class="line">    <span class="keyword">if</span> r.options.Stream&#123;...&#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 3. 设置并发控制</span></span><br><span class="line">    r.wgscan = sizedwaitgroup.New(r.options.Rate)</span><br><span class="line">    r.limiter = ratelimit.New(context.Background(), <span class="type">int64</span>(r.options.Rate), time.Second)</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// 4. 若设置了主机探活检测及判断是否支持发送原始数据包</span></span><br><span class="line">    <span class="keyword">if</span> shouldDiscoverHosts &amp;&amp; shouldUseRawPackets &#123;...&#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 5. 选择是否为流模式和显示被动开放端口</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> r.options.Stream &amp;&amp; !r.options.Passive:</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">case</span> r.options.Stream &amp;&amp; r.options.Passive:</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 获取目标IP</span></span><br><span class="line">        targets, targetsV4, targetsv6, err := r.GetTargetIps(ipsCallback)</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 若设置了查看进度</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理核心</span></span><br><span class="line">        <span class="keyword">if</span> shouldUseRawPackets &#123;</span><br><span class="line">            r.RawSocketEnumeration(ip, port)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r.wgscan.Add()</span><br><span class="line">            <span class="keyword">go</span> r.handleHostPort(ip, port)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="rQqvJ"></a></p><h3 id="主机探活"><a href="#主机探活" class="headerlink" title="主机探活"></a>主机探活</h3><p>探活的顺序为：</p><ul><li><code>Icmp Echo Request</code></li><li><code>Tcmp Timestamp Reqeust</code></li><li><code>Icmp Netmask Request</code></li><li><code>ARP Scan</code></li><li><code>Syn Probes</code></li><li><code>Ack Probes</code></li><li><code>IPv6 NDP</code></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a name=&quot;F7ypG&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;参数解析&quot;&gt;&lt;a href=&quot;#参数解析&quot; class=&quot;headerlink&quot; title=&quot;参数解析&quot;&gt;&lt;/a&gt;参数解析&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table</summary>
      
    
    
    
    <category term="go" scheme="https://zcej.github.io/categories/go/"/>
    
    
  </entry>
  
  <entry>
    <title>katana源码分析</title>
    <link href="https://zcej.github.io/2022/11/09/go/katana%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://zcej.github.io/2022/11/09/go/katana%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2022-11-09T10:50:29.000Z</published>
    <updated>2023-05-04T09:52:49.400Z</updated>
    
    <content type="html"><![CDATA[<p>个人对该项目比较感兴趣，争取做到时刻保持关注。因为自己也用go实现了类似的爬虫功能，但是一对比就有点相形见绌，故可以从中学到很多东西。目前本文基于katana-0.0.1（2022-11.7）进行分析，同时会关注后续版本。<br><a name="WUepR"></a></p><h2 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h2><p>参数解析，常用&#x2F;必备参数已加粗</p><ul><li>input：<ul><li><strong>-u：</strong>指定爬取url，支持string，string[]</li></ul></li><li>configuration：基本配置<ul><li><strong>-d：</strong>指定爬取深度，从0开始，默认是2</li><li>-jc：解析js和css标签，经测试默认解析了</li><li>-ct：指定抓取时间，单位为s</li><li>-kf：指定是否抓取robots.txt或sitemap.xml文件中的链接</li><li>-mrs：解析的最大响应数据大小，默认为mb</li><li><strong>-timeout：</strong>超时时间</li><li>-aff：启用可选表单自动填写，暂不清楚有什么作用</li><li><strong>-retry：</strong>请求重试次数：默认为1</li><li><strong>-proxy：</strong>设置代理，支持http和socks5</li><li>-H：添加自定义请求头，格式为string[]</li><li>-config：指定配置文件</li><li>-fc：指定自定义表单配置文件</li></ul></li><li>headless：无头浏览器模式，linux暂时有点问题(Running as root without –no-sandbox is not supported.)<ul><li>-hl：</li><li>-sc：</li><li>sb</li></ul></li><li>scope：根据某种规则指定要爬取的url的范围<ul><li>-cs：根据正则匹配范围内的url</li><li>-cos：根据正则匹配范围外的url</li><li>-fs：预定义范围字段，默认为”rdn”，(dn,rdn,fqdn) </li><li>-ns：禁用基于主机的默认作用域(暂不不知道作用)</li><li>-do：显示作用域内爬取的外部端点</li></ul></li><li>filter：<ul><li>-f：定义在输出中展示的字段(url,path,fqdn,rdn,rurl,qurl,qpath,file,key,value,kv,dir,udir)</li><li>-sf：定义在存储是保存的字段(url,path,fqdn,rdn,rurl,qurl,qpath,file,key,value,kv,dir,udir)</li><li>-em：根据扩展名进行匹配，如php，html，js，<strong>理解为include</strong></li><li>-ef：根据扩展名过滤输出，如png， css，<strong>理解为exclude</strong></li></ul></li><li>rate-limit：<ul><li>-c：并发数，默认为10</li><li>-p：并行数，默认为10</li><li>-rd：每个请求之间的请求延迟</li><li>-rl：每秒最大请求数，默认为150</li><li>-rlm：每分钟发送的最大请求数</li></ul></li><li>output：<ul><li>-o：结果写入到指定文件</li><li>-j：以json格式写入</li><li>-nc：禁用输出内容着色</li><li>-silent：仅显示输出</li><li>-v：显示详细输出</li><li>-version：显示项目版本号<br><a name="j56nO"></a><h2 id="目录文件说明"><a href="#目录文件说明" class="headerlink" title="目录文件说明"></a>目录文件说明</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">├─cmd</span><br><span class="line">│  ├─katana</span><br><span class="line">│  │   main.go</span><br><span class="line">│  │</span><br><span class="line">│  └─tools</span><br><span class="line">│      └─crawl-maze-score</span><br><span class="line">│          main.go</span><br><span class="line">│</span><br><span class="line">├─internal</span><br><span class="line">│  └─runner</span><br><span class="line">│      banner.go   启动时展示的自定义信息</span><br><span class="line">│      executer.go 根据并行度(parallelism)调用核心crawl</span><br><span class="line">│      options.go  解析命令行参数，进行相应的配置</span><br><span class="line">│      runner.go   最外层运行结构体Runner，包含属性crawlerOptions, stdin, crawler(核心), options</span><br><span class="line">│</span><br><span class="line">└─pkg</span><br><span class="line">    ├─engine</span><br><span class="line">    │  │  engine.go</span><br><span class="line">    │  │</span><br><span class="line">    │  ├─common</span><br><span class="line">    │  │   http.go  封装httpclient，配置transport，<span class="built_in">timeout</span>，以及checkRedirect(如果绑定了回调，会执行该回调函数)</span><br><span class="line">    │  │</span><br><span class="line">    │  ├─hybrid       两种模式之一(headless)</span><br><span class="line">    │  │   crawl.go</span><br><span class="line">    │  │   doc.go</span><br><span class="line">    │  │   hijack.go</span><br><span class="line">    │  │   hybrid.go</span><br><span class="line">    │  │</span><br><span class="line">    │  ├─parser</span><br><span class="line">    │  │  │  parser.go</span><br><span class="line">    │  │  │  parser_test.go</span><br><span class="line">    │  │  │</span><br><span class="line">    │  │  └─files</span><br><span class="line">    │  │      request.go 抓取robots.txt或sitemap.xml的入口</span><br><span class="line">    │  │      robotstxt.go</span><br><span class="line">    │  │      robotstxt_test.go</span><br><span class="line">    │  │      sitemapxml.go</span><br><span class="line">    │  │      sitemapxml_test.go</span><br><span class="line">    │  │</span><br><span class="line">    │  └─standard    两种模式之一(standard)</span><br><span class="line">    │      crawl.go  实际发起请求调用httpclient.Do的地方</span><br><span class="line">    │      doc.go</span><br><span class="line">    │      standard.go  核心Crawl</span><br><span class="line">    │</span><br><span class="line">    ├─navigation</span><br><span class="line">    │   request.go   处理请求url</span><br><span class="line">    │   response.go  处理响应</span><br><span class="line">    │</span><br><span class="line">    ├─output</span><br><span class="line">    │   fields.go         输出字段格式处理</span><br><span class="line">    │   fields_test.go  </span><br><span class="line">    │   file_writer.go    写文件</span><br><span class="line">    │   format_json.go    处理成json格式</span><br><span class="line">    │   format_screen.go  终端输出格式整理</span><br><span class="line">    │   output.go         write核心，定义了Writer接口</span><br><span class="line">    │</span><br><span class="line">    ├─types</span><br><span class="line">    │   crawler_options.go  定义crawler的一些配置，包括公用options</span><br><span class="line">    │   options.go          定义公用options</span><br><span class="line">    │</span><br><span class="line">    └─utils  工具<span class="string">&#x27;类&#x27;</span></span><br><span class="line">        │  formfill.go</span><br><span class="line">        │  formfill_test.go</span><br><span class="line">        │  regex.go</span><br><span class="line">        │  utils.go</span><br><span class="line">        │  utils_test.go</span><br><span class="line">        │</span><br><span class="line">        ├─extensions</span><br><span class="line">        │   extensions.go</span><br><span class="line">        │   extensions_test.go</span><br><span class="line">        │</span><br><span class="line">        ├─filters</span><br><span class="line">        │   filters.go</span><br><span class="line">        │   filters_test.go</span><br><span class="line">        │   simple.go</span><br><span class="line">        │</span><br><span class="line">        ├─queue 广度优先(优先级队列[最小堆])和深度优先(栈[双向链表])，对应两种模式</span><br><span class="line">        │   priority_queue.go       优先级队列实现 <span class="string">&quot;container/heap&quot;</span></span><br><span class="line">        │   priority_queue_test.go</span><br><span class="line">        │   queue.go                封装了两种模式，统一对外接口<span class="string">&quot;VarietyQueue&quot;</span></span><br><span class="line">        │   stack.go                栈实现 <span class="string">&quot;container/list&quot;</span></span><br><span class="line">        │   stack_test.go</span><br><span class="line">        │</span><br><span class="line">        └─scope</span><br><span class="line">            scope.go</span><br><span class="line">            scope_test.go</span><br></pre></td></tr></table></figure><a name="FDrOK"></a><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2>首先看下项目的依赖：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">require (</span><br><span class="line">    github.com/PuerkitoBio/goquery v1.8.0                          // 页面解析库</span><br><span class="line">    github.com/go-rod/rod v0.112.0                                 // 操作浏览器的工具</span><br><span class="line">    github.com/json-iterator/go v1.1.12                            // json解析器</span><br><span class="line">    github.com/logrusorgru/aurora v2.0.3+incompatible              // 终端输出着色</span><br><span class="line">    github.com/lukasbob/srcset v0.0.0-20190730101422-86b742e617f3  // 解析HTML5 srcset</span><br><span class="line">    github.com/pkg/errors v0.9.1                                   // 第三方异常处理包</span><br><span class="line">    github.com/projectdiscovery/fastdialer v0.0.17                 // 快速发起请求</span><br><span class="line">    github.com/projectdiscovery/fileutil v0.0.3                    // 文件处理工具</span><br><span class="line">    github.com/projectdiscovery/goflags v0.1.3                     // 命令行参数解决</span><br><span class="line">    github.com/projectdiscovery/gologger v1.1.4                    // 日志处理</span><br><span class="line">    github.com/projectdiscovery/hmap v0.0.2-0.20210917080408-0fd7bd286bfa</span><br><span class="line">    github.com/projectdiscovery/ratelimit v0.0.1                   // 并发控制(时间间隔)</span><br><span class="line">    github.com/projectdiscovery/retryablehttp-go v1.0.2            // 可自动重试的http client</span><br><span class="line">    github.com/projectdiscovery/stringsutil v0.0.2                 // 字符串处理</span><br><span class="line">    github.com/remeh/sizedwaitgroup v1.0.0                         // 并发控制(同一时间)</span><br><span class="line">    github.com/rs/xid v1.4.0                                       // 生成唯一id</span><br><span class="line">    github.com/shirou/gopsutil/v3 v3.22.10                         // 跨平台进程和系统监控</span><br><span class="line">    github.com/stretchr/testify v1.8.1                             // 测试框架</span><br><span class="line">    go.uber.org/multierr v1.8.0                                    // 多错误处理</span><br><span class="line">    golang.org/x/net v0.1.0                                        // 补充go网络库</span><br><span class="line">    gopkg.in/yaml.v3 v3.0.1                                        // 解析生成yaml数据</span><br><span class="line">)</span><br></pre></td></tr></table></figure>从最简单的命令<code>./katana -u https://tesla.com -d 1</code>开始入手，分析代码的运行流程。<br><a name="tdbOL"></a><h3 id="程序入口"><a href="#程序入口" class="headerlink" title="程序入口"></a>程序入口</h3><code>cmd/katana/main.go</code><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">cfgFile <span class="type">string</span>  <span class="comment">// 配置文件</span></span><br><span class="line">options = &amp;types.Options&#123;&#125;  <span class="comment">// 基本的设置</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1. 读取命令行参数</span></span><br><span class="line"><span class="keyword">if</span> err := readFlags(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">gologger.Fatal().Msgf(<span class="string">&quot;Could not read flags: %s\n&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 新建一个runner对象, 包含爬虫配置, 基本配置, 输入, 及爬虫核心</span></span><br><span class="line">runner, err := runner.New(options)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> || runner == <span class="literal">nil</span> &#123;</span><br><span class="line">gologger.Fatal().Msgf(<span class="string">&quot;could not create runner: %s\n&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> runner.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 接收退出信号关闭整个channel</span></span><br><span class="line"><span class="comment">// close handler</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">signal.Notify(c, os.Interrupt, syscall.SIGTERM)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">&lt;-c</span><br><span class="line">gologger.DefaultLogger.Info().Msg(<span class="string">&quot;- Ctrl+C pressed in Terminal&quot;</span>)</span><br><span class="line">runner.Close()</span><br><span class="line">os.Exit(<span class="number">0</span>)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 爬虫执行ExecuteCrawling</span></span><br><span class="line"><span class="keyword">if</span> err := runner.ExecuteCrawling(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">gologger.Fatal().Msgf(<span class="string">&quot;could not execute crawling: %s&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>接下来看看<code>runner</code>的<code>New</code>和<code>Close</code>做了什么，在<code>internal/runner/runner.go</code>下：<blockquote><p>注：之后只会贴出核心逻辑，其他代码将会省去。</p></blockquote></li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先熟悉Runner结构体</span></span><br><span class="line"><span class="keyword">type</span> Runner <span class="keyword">struct</span> &#123;</span><br><span class="line">crawlerOptions *types.CrawlerOptions  <span class="comment">// 爬虫的相关设置, 如输出, 限速等</span></span><br><span class="line">stdin          <span class="type">bool</span>                   <span class="comment">// 是否有输入(具体作用待定)</span></span><br><span class="line">crawler        engine.Engine          <span class="comment">// 爬虫核心, 实现了Crawl(string) error和Close() error接口</span></span><br><span class="line">options        *types.Options         <span class="comment">// 基本的设置, 从命令行读取的参数都保存在该结构体对象中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(options *types.Options)</span></span> (*Runner, <span class="type">error</span>) &#123; </span><br><span class="line">...</span><br><span class="line">    <span class="comment">// 1. 创建爬虫的相关设置对象</span></span><br><span class="line">    crawlerOptions, err := types.NewCrawlerOptions(options)</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 2. 选择不同的模式, 一种是Headless, 一种是standard标准模式</span></span><br><span class="line">    carwler, err = hybrid.New(crawlerOptions)</span><br><span class="line">    ...</span><br><span class="line">    crawler, err = standard.New(crawlerOptions)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Runner)</span></span> Close() <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 这里用到了多错误处理模块multierr, 之后在进一步学学</span></span><br><span class="line"><span class="keyword">return</span> multierr.Combine(</span><br><span class="line">r.crawler.Close(),</span><br><span class="line">r.crawlerOptions.Close(),</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="euyNG"></a></p><h3 id="爬虫核心"><a href="#爬虫核心" class="headerlink" title="爬虫核心"></a>爬虫核心</h3><p>接下来就到了核心部分，只要实现了文件<code>pkg/engine/engine.go</code>中的接口<code>Engine</code>就可以嵌入自己的爬虫，之后主要分析标准模式下的实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Engine的实现如下, 所处文件位于pkg/engine/engine.go</span></span><br><span class="line"><span class="keyword">type</span> Engine <span class="keyword">interface</span> &#123;</span><br><span class="line">Crawl(<span class="type">string</span>) <span class="type">error</span></span><br><span class="line">Close() <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统一外部调用的方法ExecuteCrawling实现如下, 所处文件位于internal/runner/executer.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Runner)</span></span> ExecuteCrawling() <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 解析输入的url列表, 返回的数据类型为[]string</span></span><br><span class="line">    inputs := r.parseInputs()</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// 2. 这里使用了并行参数Parallelism(-p)创建了几个调用Crawl方法的goroutine</span></span><br><span class="line">    wg := sizedwaitgroup.New(r.options.Parallelism)</span><br><span class="line">    <span class="keyword">for</span> _, input := <span class="keyword">range</span> inputs &#123;</span><br><span class="line">        wg.Add()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(input <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            <span class="comment">// 3. 调用具体的Crawl方法</span></span><br><span class="line">        r.crawler.Crawl(input)</span><br><span class="line">        &#125;(input)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.wait()</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在来看看标准模式下的<code>Crawl</code>的具体实现，位于文件<code>pkg/engine/standard/standard.go</code>下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Crawler)</span></span> Crawl(rootURL <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 解析根url</span></span><br><span class="line">    parsed, err := url.Parse(rootURL) </span><br><span class="line">...</span><br><span class="line">    <span class="comment">// 2. 创建队列, 这里根据配置文件中的设置广度优先还是深度优先</span></span><br><span class="line">    <span class="comment">// 广度优先使用的优先级队列, 深度优先使用的是栈</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里返回的结构体VarietyQueue对象的指针</span></span><br><span class="line">    queue := queue.New(c.options.Options.Strategy)</span><br><span class="line">    <span class="comment">// 将进一步封装的请求结构体navigation.Request放入到队列中</span></span><br><span class="line">    queue.Push(navigation.Request&#123;Method: http.MethodGet, URL: rootURL, Depth: <span class="number">0</span>&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 解析响应的回调函数, 会将新的url封装成navigation.Request后放入到队列</span></span><br><span class="line">    parseResponseCallback := c.makeParseResponseCallback(queue)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 3. 若是指定了参数knownFiles(-kf), 会调用该方法</span></span><br><span class="line">    parseResponseCallback(nr)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 使用retryablehttp新建httpclient, 这里需注意的是传进去的参数func绑定到了httpclient的属性CheckRedirect下</span></span><br><span class="line">    <span class="comment">// httpclient.Do会调用标准库下httpclient的Do方法, 进而调用CheckRedirect</span></span><br><span class="line">    httpclient, _, err := common.BuildClient(c.options.Dialer, c.options.Options, <span class="function"><span class="keyword">func</span><span class="params">(resp *http.Response, depth <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        body, _ := io.ReadAll(resp.Body)</span><br><span class="line">        reader, _ := goquery.NewDocumentFromReader(bytes.NewReader(body))</span><br><span class="line">        <span class="comment">// 解析响应, 这里分为三大类, 主要是响应头解析, 响应体解析及js的一些解析</span></span><br><span class="line">        <span class="comment">// 然后将回调函数parseResponseCallback传进去, 这里深度+1</span></span><br><span class="line">        <span class="comment">// 整体而言这部分设计较为巧妙, 之后可深入研究下</span></span><br><span class="line">        parser.ParseResponse(navigation.Response&#123;Depth: depth + <span class="number">1</span>, Options: c.options, RootHostname: hostname, Resp: resp, Body: body, Reader: reader&#125;, parseResponseCallback)</span><br><span class="line">    &#125;)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 消费队列里构造的消息(navigation.Request)</span></span><br><span class="line">    <span class="comment">// 使用了sizedwaitgroup限制并发数, 具体值来自参数Concurrency(-c)</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 注意这里还使用了atomic来标识任务的执行状态，之后再看看</span></span><br><span class="line">    wg := sizedwaitgroup.New(c.options.Options.Concurrency)</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 出队消息</span></span><br><span class="line">        item := queue.Pop()</span><br><span class="line">        req, ok := item.(navigation.Request)</span><br><span class="line">        ...</span><br><span class="line">        wg.Add()</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 控制每秒最大并发数</span></span><br><span class="line">            c.options.RateLimit.Take()</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 实际发起http request的方法, 返回的是navigation.Response结构体对象</span></span><br><span class="line">            resp, err := c.makeRequest(ctx, req, hostname, req.Depth, httpclient)</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 对响应进行解析</span></span><br><span class="line">            parser.ParseResponse(resp, parseResponseCallback)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后再来看看发起请求<code>makeRequest</code>与解析响应<code>ParseResponse</code>都做了哪些事吧。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// makeRequest 位于文件pkg/engine/standard/crawl.go下</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Crawler)</span></span> makeRequest(ctx context.Context, request navigation.Request, rootHostname <span class="type">string</span>, depth <span class="type">int</span>, httpclient *retryablehttp.Client) (navigation.Response, <span class="type">error</span>) &#123;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// 1. 将当前深度传入到上下文中, 并封装request请求</span></span><br><span class="line">    ctx = context.WithValue(ctx, navigation.Depth&#123;&#125;, depth)</span><br><span class="line">    httpReq, err := http.NewRequestWithContext(ctx, request.Method, request.URL, <span class="literal">nil</span>)</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 2. 发起请求, 最终会调用标准库的Do方法</span></span><br><span class="line">    resp, err := httpclient.Do(req)</span><br><span class="line">    ... </span><br><span class="line">    <span class="comment">// 3. 读取响应得限制大小, 也可通过参数设置(-mrs)</span></span><br><span class="line">    limitReader := io.LimitReader(resp.Body, <span class="type">int64</span>(c.options.Options.BodyReadSize))</span><br><span class="line">    data, err := io.ReadAll(limitReader)</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> response, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ParseResponse 位于文件pkg/engine/parser/parser.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseResponse</span><span class="params">(resp navigation.Response, callback <span class="keyword">func</span>(navigation.Request)</span></span>) &#123;</span><br><span class="line">    <span class="comment">// responseParsers存的是结构体responseParser, 包含两个属性</span></span><br><span class="line">    <span class="comment">// 一个是解析类型parserType, 一个是解析函数parserFunc</span></span><br><span class="line">    <span class="comment">// 注: 一开始注册的响应回调函数是在具体的parserFunc中执行的</span></span><br><span class="line"><span class="keyword">for</span> _, parser := <span class="keyword">range</span> responseParsers &#123;</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> parser.parserType == headerParser &amp;&amp; resp.Resp != <span class="literal">nil</span>:</span><br><span class="line">parser.parserFunc(resp, callback)</span><br><span class="line"><span class="keyword">case</span> parser.parserType == bodyParser &amp;&amp; resp.Reader != <span class="literal">nil</span>:</span><br><span class="line">parser.parserFunc(resp, callback)</span><br><span class="line"><span class="keyword">case</span> parser.parserType == contentParser &amp;&amp; <span class="built_in">len</span>(resp.Body) &gt; <span class="number">0</span>:</span><br><span class="line">parser.parserFunc(resp, callback)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="H7BHi"></a></p><h3 id="结果输出"><a href="#结果输出" class="headerlink" title="结果输出"></a>结果输出</h3><p>写结果是在<code>makeParseResponseCallback</code>中调用的，正好上面只是一笔带过，下面详细分析下，该方法位于文件<code>pkg/engine/standard/standard.go</code>下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Crawler)</span></span> makeParseResponseCallback(queue *queue.VarietyQueue) <span class="function"><span class="keyword">func</span><span class="params">(nr navigation.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(nr navigation.Request)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 1. 如果是空url或者重复的url直接return</span></span><br><span class="line"><span class="keyword">if</span> !c.options.UniqueFilter.UniqueURL(nr.RequestURL()) &#123;<span class="keyword">return</span>&#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 2. 对结果url进行验证过滤后写入到输出中, result为output.Result结构体对象</span></span><br><span class="line">        c.options.OutputWriter.Write(result)</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 3. 如果当前深度大于设置的最大深度或没在范围内则直接返回, 否则将其放入队列中</span></span><br><span class="line">        <span class="keyword">if</span> nr.Depth &gt;= c.options.Options.MaxDepth || !scopeValidated &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">queue.Push(nr, nr.Depth)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="YAvfW"></a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>目前只是过了一下standard模式下程序的运行流程，之后再分析下headless下所做的工作，初次之外项目里还做了很多其他的操作，比如选择url范围，过滤，解析等等，要深入了解可以自己参照着实现一个，也是学习效率最快的方式了吧。顺便一提我个人运行headless模式时，报了个<code>Running as root without --no-sandbox is not supported</code>的错误，当时想着之后有时间再折腾折腾，没想到官方发布了<code>0.0.2</code>版本把这个问题修复了，不得不感叹效率之高。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;个人对该项目比较感兴趣，争取做到时刻保持关注。因为自己也用go实现了类似的爬虫功能，但是一对比就有点相形见绌，故可以从中学到很多东西。目前本文基于katana-0.0.1（2022-11.7）进行分析，同时会关注后续版本。&lt;br&gt;&lt;a name=&quot;WUepR&quot;&gt;&lt;/a&gt;&lt;/</summary>
      
    
    
    
    <category term="go" scheme="https://zcej.github.io/categories/go/"/>
    
    
  </entry>
  
  <entry>
    <title>记一次oracle数据备份还原的操作</title>
    <link href="https://zcej.github.io/2022/10/20/%E5%85%B6%E4%BB%96/%E8%AE%B0%E4%B8%80%E6%AC%A1oracle%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%E8%BF%98%E5%8E%9F%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    <id>https://zcej.github.io/2022/10/20/%E5%85%B6%E4%BB%96/%E8%AE%B0%E4%B8%80%E6%AC%A1oracle%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%E8%BF%98%E5%8E%9F%E7%9A%84%E6%93%8D%E4%BD%9C/</id>
    <published>2022-10-20T15:01:43.000Z</published>
    <updated>2023-02-05T16:53:01.597Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul><li>oracle版本：12.2.0</li><li>目的：将一个用户的表结构和数据复制到另一个用户下(全量备份)</li><li>当前环境为虚拟机，已提前做好快照，避免中途出现问题</li><li>如果对oracle不熟，最好还是了解下用户，表空间和表之间的关系</li><li>数据备份和数据还原下仅列出主要命令，调试用到的命令见其他<h2 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h2><h4 id="1-管理员登录"><a href="#1-管理员登录" class="headerlink" title="1. 管理员登录"></a>1. 管理员登录</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlplus sys<span class="operator">/</span><span class="number">123456</span><span class="variable">@orcl</span> <span class="keyword">as</span> sysdba;</span><br></pre></td></tr></table></figure><h4 id="2-创建备份目录"><a href="#2-创建备份目录" class="headerlink" title="2. 创建备份目录"></a>2. 创建备份目录</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dba_directories;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> directory backup <span class="keyword">as</span> <span class="string">&#x27;d:\backup&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="3-赋于要导出数据表所属用户权限"><a href="#3-赋于要导出数据表所属用户权限" class="headerlink" title="3. 赋于要导出数据表所属用户权限"></a>3. 赋于要导出数据表所属用户权限</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> read,write <span class="keyword">on</span> directory backup <span class="keyword">to</span> C##USER1;</span><br></pre></td></tr></table></figure><h4 id="4-数据备份"><a href="#4-数据备份" class="headerlink" title="4. 数据备份"></a>4. 数据备份</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expdp C##USER1<span class="operator">/</span><span class="number">123456</span><span class="variable">@orcl</span> directory<span class="operator">=</span>backup dumpfile<span class="operator">=</span>backup.dmp logfile<span class="operator">=</span>export.log</span><br></pre></td></tr></table></figure>数据备份并没有遇到多大的阻碍，一路执行就成功了，这里贴出导出成功的日志文件：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">;;; </span><br><span class="line">Export: Release 12.2.0.1.0 - Production on 星期一 10月 31 10:54:38 2022</span><br><span class="line"></span><br><span class="line">Copyright (c) 1982, 2017, Oracle and/or its affiliates.  All rights reserved.</span><br><span class="line">;;; </span><br><span class="line">连接到: Oracle Database 12c Enterprise Edition Release 12.2.0.1.0 - 64bit Production</span><br><span class="line">启动 &quot;C##LEGACY&quot;.&quot;SYS_EXPORT_SCHEMA_01&quot;:  C##LEGACY/********@orcl directory=bpdata1 dumpfile=backup.dmp logfile=export.log </span><br><span class="line">处理对象类型 SCHEMA_EXPORT/TABLE/TABLE_DATA</span><br><span class="line">处理对象类型 SCHEMA_EXPORT/TABLE/INDEX/STATISTICS/INDEX_STATISTICS</span><br><span class="line">处理对象类型 SCHEMA_EXPORT/TABLE/STATISTICS/TABLE_STATISTICS</span><br><span class="line">处理对象类型 SCHEMA_EXPORT/STATISTICS/MARKER</span><br><span class="line">处理对象类型 SCHEMA_EXPORT/SYSTEM_GRANT</span><br><span class="line">处理对象类型 SCHEMA_EXPORT/ROLE_GRANT</span><br><span class="line">处理对象类型 SCHEMA_EXPORT/DEFAULT_ROLE</span><br><span class="line">处理对象类型 SCHEMA_EXPORT/PRE_SCHEMA/PROCACT_SCHEMA</span><br><span class="line">处理对象类型 SCHEMA_EXPORT/TABLE/TABLE</span><br><span class="line">处理对象类型 SCHEMA_EXPORT/TABLE/COMMENT</span><br><span class="line">处理对象类型 SCHEMA_EXPORT/TABLE/IDENTITY_COLUMN</span><br><span class="line">处理对象类型 SCHEMA_EXPORT/TABLE/INDEX/INDEX</span><br><span class="line">处理对象类型 SCHEMA_EXPORT/TABLE/CONSTRAINT/CONSTRAINT</span><br><span class="line">处理对象类型 SCHEMA_EXPORT/TABLE/CONSTRAINT/REF_CONSTRAINT</span><br><span class="line">. . 导出了 &quot;C##LEGACY&quot;.&quot;MSC_HUA_HISTORY&quot;               14.58 GB 71276923 行</span><br><span class="line">. . 导出了 &quot;C##LEGACY&quot;.&quot;ROSHAN_CUSTOMERS_ARCHIVE&quot;      2.877 GB 20218000 行</span><br><span class="line">. . 导出了 &quot;C##LEGACY&quot;.&quot;CELL_TOWERS&quot;                   1.080 GB 16865669 行</span><br><span class="line">. . 导出了 &quot;C##LEGACY&quot;.&quot;NEW_CELL_IDS&quot;                  2.318 MB   14745 行</span><br><span class="line">. . 导出了 &quot;C##LEGACY&quot;.&quot;MSC_DATA&quot;                      124.4 KB     246 行</span><br><span class="line">. . 导出了 &quot;C##LEGACY&quot;.&quot;MCC_MNC_OPERATOR&quot;              158.0 KB    1511 行</span><br><span class="line">. . 导出了 &quot;C##LEGACY&quot;.&quot;DJANGO_ADMIN_LOG&quot;              41.49 KB     145 行</span><br><span class="line">. . 导出了 &quot;C##LEGACY&quot;.&quot;DJANGO_SESSION&quot;                21.28 KB      14 行</span><br><span class="line">. . 导出了 &quot;C##LEGACY&quot;.&quot;AUTH_USER&quot;                     10.00 KB       2 行</span><br><span class="line">. . 导出了 &quot;C##LEGACY&quot;.&quot;QUERY_TASK&quot;                    9.156 KB       1 行</span><br><span class="line">. . 导出了 &quot;C##LEGACY&quot;.&quot;AUTH_PERMISSION&quot;               8.781 KB      32 行</span><br><span class="line">. . 导出了 &quot;C##LEGACY&quot;.&quot;DJANGO_MIGRATIONS&quot;             8.437 KB      25 行</span><br><span class="line">. . 导出了 &quot;C##LEGACY&quot;.&quot;DJANGO_CONTENT_TYPE&quot;           6.257 KB       8 行</span><br><span class="line">. . 导出了 &quot;C##LEGACY&quot;.&quot;AUTH_GROUP&quot;                        0 KB       0 行</span><br><span class="line">. . 导出了 &quot;C##LEGACY&quot;.&quot;AUTH_GROUP_PERMISSIONS&quot;            0 KB       0 行</span><br><span class="line">. . 导出了 &quot;C##LEGACY&quot;.&quot;AUTH_USER_GROUPS&quot;                  0 KB       0 行</span><br><span class="line">. . 导出了 &quot;C##LEGACY&quot;.&quot;AUTH_USER_USER_PERMISSIONS&quot;        0 KB       0 行</span><br><span class="line">已成功加载/卸载了主表 &quot;C##LEGACY&quot;.&quot;SYS_EXPORT_SCHEMA_01&quot; </span><br><span class="line">******************************************************************************</span><br><span class="line">C##LEGACY.SYS_EXPORT_SCHEMA_01 的转储文件集为:</span><br><span class="line">  C:\BACKUP\BACKUP.DMP</span><br><span class="line">作业 &quot;C##LEGACY&quot;.&quot;SYS_EXPORT_SCHEMA_01&quot; 已于 星期一 10月 31 10:56:19 2022 elapsed 0 00:01:38 成功完成</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="数据还原"><a href="#数据还原" class="headerlink" title="数据还原"></a>数据还原</h2><blockquote><p>注：下述sql命令均在sys账号下执行</p></blockquote></li></ul><h4 id="1-新建表空间"><a href="#1-新建表空间" class="headerlink" title="1. 新建表空间"></a>1. 新建表空间</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span>space bp</span><br><span class="line">datafile <span class="string">&#x27;C:/backup/bp.DBF&#x27;</span></span><br><span class="line">size <span class="number">100</span>M autoextend <span class="keyword">on</span> next <span class="number">50</span>M maxsize unlimited;</span><br></pre></td></tr></table></figure><h4 id="2-创建用户并赋权"><a href="#2-创建用户并赋权" class="headerlink" title="2. 创建用户并赋权"></a>2. 创建用户并赋权</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> C##USER2 </span><br><span class="line">identified <span class="keyword">by</span> &quot;123456&quot;</span><br><span class="line"><span class="keyword">default</span> tablespace bp</span><br><span class="line">profile <span class="keyword">DEFAULT</span></span><br><span class="line">ACCOUNT UNLOCK;</span><br><span class="line"></span><br><span class="line"><span class="keyword">grant</span> dba <span class="keyword">to</span> C##USER2;</span><br><span class="line"><span class="keyword">grant</span> resource <span class="keyword">to</span> C##USER2;</span><br></pre></td></tr></table></figure><h4 id="3-数据还原"><a href="#3-数据还原" class="headerlink" title="3.数据还原"></a>3.数据还原</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">impdp C##USER2<span class="operator">/</span><span class="number">123456</span><span class="variable">@orcl</span> directory<span class="operator">=</span>backup dumpfile<span class="operator">=</span>backup.dmp remap_schema<span class="operator">=</span>C##LEGACY:C##WYX logfile<span class="operator">=</span>import.log</span><br></pre></td></tr></table></figure><p>若已有相同的数据表(此时会报ORA-39151错误)，则添加下述参数：<br><code>table_exists_action=replace</code></p><ul><li>skip：跳过并处理下一个对象</li><li>append：为表增加数据</li><li>truncate：清空表，然后为其增加数据</li><li>replace：删除已存在表，重新建表并追加数据</li></ul><p>本以为到此应该能够成功进行还原了，没想到报了一个数据文件无法扩展的问题，找了下资料发现oracle里一个数据文件最大为32G，故根据提示在对应的表空间新增数据文件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span>space &quot;USERS&quot; <span class="keyword">add</span> datafile <span class="string">&#x27;C:\APP\ORACLE\ORADATA\ORCL\USERS02.DBF&#x27;</span> size <span class="number">100</span>m autoextend <span class="keyword">on</span> next <span class="number">100</span>m maxsize unlimited;</span><br></pre></td></tr></table></figure><p>至此，已经能成功导入还原了：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">;;; </span><br><span class="line">Import: <span class="keyword">Release</span> <span class="number">12.2</span><span class="number">.0</span><span class="number">.1</span><span class="number">.0</span> <span class="operator">-</span> Production <span class="keyword">on</span> 星期一 <span class="number">10</span>月 <span class="number">31</span> <span class="number">18</span>:<span class="number">51</span>:<span class="number">06</span> <span class="number">2022</span></span><br><span class="line"></span><br><span class="line">Copyright (c) <span class="number">1982</span>, <span class="number">2017</span>, Oracle <span class="keyword">and</span><span class="operator">/</span><span class="keyword">or</span> its affiliates.  <span class="keyword">All</span> rights reserved.</span><br><span class="line">;;; </span><br><span class="line">连接到: Oracle Database <span class="number">12</span>c Enterprise Edition <span class="keyword">Release</span> <span class="number">12.2</span><span class="number">.0</span><span class="number">.1</span><span class="number">.0</span> <span class="operator">-</span> <span class="number">64</span>bit Production</span><br><span class="line">已成功加载<span class="operator">/</span>卸载了主表 &quot;C##LEGACY&quot;.&quot;SYS_IMPORT_FULL_01&quot; </span><br><span class="line">ORA<span class="number">-39146</span>: 方案 &quot;C##WYX2&quot; 不存在</span><br><span class="line">启动 &quot;C##LEGACY&quot;.&quot;SYS_IMPORT_FULL_01&quot;:  C##WYX<span class="comment">/********@orcl directory=bpdata1 dumpfile=backup.dmp remap_schema=C##WYX2:C##LEGACY logfile=import.log </span></span><br><span class="line"><span class="comment">处理对象类型 SCHEMA_EXPORT/SYSTEM_GRANT</span></span><br><span class="line"><span class="comment">处理对象类型 SCHEMA_EXPORT/ROLE_GRANT</span></span><br><span class="line"><span class="comment">处理对象类型 SCHEMA_EXPORT/DEFAULT_ROLE</span></span><br><span class="line"><span class="comment">处理对象类型 SCHEMA_EXPORT/PRE_SCHEMA/PROCACT_SCHEMA</span></span><br><span class="line"><span class="comment">处理对象类型 SCHEMA_EXPORT/TABLE/TABLE</span></span><br><span class="line"><span class="comment">处理对象类型 SCHEMA_EXPORT/TABLE/TABLE_DATA</span></span><br><span class="line"><span class="comment">. . 导入了 &quot;C##WYX&quot;.&quot;MSC_HUA_HISTORY&quot;               14.58 GB 71276923 行</span></span><br><span class="line"><span class="comment">. . 导入了 &quot;C##WYX&quot;.&quot;ROSHAN_CUSTOMERS_ARCHIVE&quot;      2.877 GB 20218000 行</span></span><br><span class="line"><span class="comment">. . 导入了 &quot;C##WYX&quot;.&quot;CELL_TOWERS&quot;                   1.080 GB 16865669 行</span></span><br><span class="line"><span class="comment">. . 导入了 &quot;C##WYX&quot;.&quot;NEW_CELL_IDS&quot;                  2.318 MB   14745 行</span></span><br><span class="line"><span class="comment">. . 导入了 &quot;C##WYX&quot;.&quot;MSC_DATA&quot;                      124.4 KB     246 行</span></span><br><span class="line"><span class="comment">. . 导入了 &quot;C##WYX&quot;.&quot;MCC_MNC_OPERATOR&quot;              158.0 KB    1511 行</span></span><br><span class="line"><span class="comment">. . 导入了 &quot;C##WYX&quot;.&quot;DJANGO_ADMIN_LOG&quot;              41.49 KB     145 行</span></span><br><span class="line"><span class="comment">. . 导入了 &quot;C##WYX&quot;.&quot;DJANGO_SESSION&quot;                21.28 KB      14 行</span></span><br><span class="line"><span class="comment">. . 导入了 &quot;C##WYX&quot;.&quot;AUTH_USER&quot;                     10.00 KB       2 行</span></span><br><span class="line"><span class="comment">. . 导入了 &quot;C##WYX&quot;.&quot;QUERY_TASK&quot;                    9.156 KB       1 行</span></span><br><span class="line"><span class="comment">. . 导入了 &quot;C##WYX&quot;.&quot;AUTH_PERMISSION&quot;               8.781 KB      32 行</span></span><br><span class="line"><span class="comment">. . 导入了 &quot;C##WYX&quot;.&quot;DJANGO_MIGRATIONS&quot;             8.437 KB      25 行</span></span><br><span class="line"><span class="comment">. . 导入了 &quot;C##WYX&quot;.&quot;DJANGO_CONTENT_TYPE&quot;           6.257 KB       8 行</span></span><br><span class="line"><span class="comment">. . 导入了 &quot;C##WYX&quot;.&quot;AUTH_GROUP&quot;                        0 KB       0 行</span></span><br><span class="line"><span class="comment">. . 导入了 &quot;C##WYX&quot;.&quot;AUTH_GROUP_PERMISSIONS&quot;            0 KB       0 行</span></span><br><span class="line"><span class="comment">. . 导入了 &quot;C##WYX&quot;.&quot;AUTH_USER_GROUPS&quot;                  0 KB       0 行</span></span><br><span class="line"><span class="comment">. . 导入了 &quot;C##WYX&quot;.&quot;AUTH_USER_USER_PERMISSIONS&quot;        0 KB       0 行</span></span><br><span class="line"><span class="comment">处理对象类型 SCHEMA_EXPORT/TABLE/COMMENT</span></span><br><span class="line"><span class="comment">处理对象类型 SCHEMA_EXPORT/TABLE/IDENTITY_COLUMN</span></span><br><span class="line"><span class="comment">处理对象类型 SCHEMA_EXPORT/TABLE/INDEX/INDEX</span></span><br><span class="line"><span class="comment">处理对象类型 SCHEMA_EXPORT/TABLE/CONSTRAINT/CONSTRAINT</span></span><br><span class="line"><span class="comment">处理对象类型 SCHEMA_EXPORT/TABLE/INDEX/STATISTICS/INDEX_STATISTICS</span></span><br><span class="line"><span class="comment">处理对象类型 SCHEMA_EXPORT/TABLE/CONSTRAINT/REF_CONSTRAINT</span></span><br><span class="line"><span class="comment">处理对象类型 SCHEMA_EXPORT/TABLE/STATISTICS/TABLE_STATISTICS</span></span><br><span class="line"><span class="comment">处理对象类型 SCHEMA_EXPORT/STATISTICS/MARKER</span></span><br><span class="line"><span class="comment">作业 &quot;C##LEGACY&quot;.&quot;SYS_IMPORT_FULL_01&quot; 已于 星期一 10月 31 19:00:59 2022 elapsed 0 00:09:49 成功完成</span></span><br><span class="line"><span class="comment"></span></span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dba_directories;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dba_tablespaces;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dba_data_files;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dba_users;</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span>space &quot;USERS&quot; <span class="keyword">drop</span> datafile <span class="number">23</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> T.TABLESPACE_NAME,D.FILE_NAME,D.AUTOEXTENSIBLE,D.BYTES,D.MAXBYTES,D.STATUS</span><br><span class="line"><span class="keyword">FROM</span> DBA_TABLESPACES T,DBA_DATA_FILES D</span><br><span class="line"><span class="keyword">WHERE</span> T.TABLESPACE_NAME <span class="operator">=</span>D.TABLESPACE_NAME</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> TABLESPACE_NAME,FILE_NAME;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> a.tablespace_name &quot;表空间名&quot;, </span><br><span class="line">total &quot;表空间大小&quot;, </span><br><span class="line"><span class="keyword">free</span> &quot;表空间剩余大小&quot;, </span><br><span class="line">(total <span class="operator">-</span> <span class="keyword">free</span>) &quot;表空间使用大小&quot;, </span><br><span class="line">total <span class="operator">/</span> (<span class="number">1024</span> <span class="operator">*</span> <span class="number">1024</span> <span class="operator">*</span> <span class="number">1024</span>) &quot;表空间大小(G)&quot;, </span><br><span class="line"><span class="keyword">free</span> <span class="operator">/</span> (<span class="number">1024</span> <span class="operator">*</span> <span class="number">1024</span> <span class="operator">*</span> <span class="number">1024</span>) &quot;表空间剩余大小(G)&quot;, </span><br><span class="line">(total <span class="operator">-</span> <span class="keyword">free</span>) <span class="operator">/</span> (<span class="number">1024</span> <span class="operator">*</span> <span class="number">1024</span> <span class="operator">*</span> <span class="number">1024</span>) &quot;表空间使用大小(G)&quot;, </span><br><span class="line">round((total <span class="operator">-</span> <span class="keyword">free</span>) <span class="operator">/</span> total, <span class="number">4</span>) <span class="operator">*</span> <span class="number">100</span> &quot;使用率 %&quot; </span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> tablespace_name, <span class="built_in">SUM</span>(bytes) <span class="keyword">free</span> </span><br><span class="line"><span class="keyword">FROM</span> dba_free_space </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> tablespace_name) a, </span><br><span class="line">(<span class="keyword">SELECT</span> tablespace_name, <span class="built_in">SUM</span>(bytes) total </span><br><span class="line"><span class="keyword">FROM</span> dba_data_files </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> tablespace_name) b </span><br><span class="line"><span class="keyword">WHERE</span> a.tablespace_name <span class="operator">=</span> b.tablespace_name;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;oracle版本：12.2.0&lt;/li&gt;
&lt;li&gt;目的：将一个用户的表结构和数据复制到另一个用户下(全量备份)&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    <category term="其他" scheme="https://zcej.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>如何控制并发速率2.0</title>
    <link href="https://zcej.github.io/2022/10/06/go/%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91%E9%80%9F%E7%8E%872.0/"/>
    <id>https://zcej.github.io/2022/10/06/go/%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91%E9%80%9F%E7%8E%872.0/</id>
    <published>2022-10-06T05:11:03.000Z</published>
    <updated>2023-02-05T16:54:32.191Z</updated>
    
    <content type="html"><![CDATA[<p>之前有记录过在go中如何控制并发速率，要么就是通过带缓冲的channel，要么就是通过协程池。不论是通过什么方式，选择最适合在当前场景使用的即可，下面记录下学习过程中发现的开源项目中不同的实现方式。</p><h2 id="ratelimit"><a href="#ratelimit" class="headerlink" title="ratelimit"></a>ratelimit</h2><ul><li><p>来自<code>projectdiscovery/ratelimit</code></p></li><li><p>个人理解该项目的特点是能控制的是每隔一段时间(自己定义)，起多少个并发，之前起的goroutine还在执行的话也没有影响，故如果goroutine执行的若是比较耗时的操作，那么会不会存在goroutine的数量一直在增加，消耗完所有内存，导致程序崩溃的情况。</p></li><li><p>不过这主要还是和使用方式有关，排除上述疑问的话，这个实现速率控制的方式也非常值得学习</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Limiter <span class="keyword">struct</span> &#123;</span><br><span class="line">maxCount <span class="type">int64</span>            <span class="comment">// 定义的最大并发数</span></span><br><span class="line">count    <span class="type">int64</span>            <span class="comment">// 当前剩余的令牌数(token)</span></span><br><span class="line">ticker   *time.Ticker     <span class="comment">// 定时器，执行定时任务(标准库)</span></span><br><span class="line">tokens   <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;    <span class="comment">// 无缓冲channel，用于获取令牌</span></span><br><span class="line">ctx      context.Context  <span class="comment">// 上下文，终止定时器及创建的子协程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(limiter *Limiter)</span></span> run() &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 当剩余的令牌数小于等于零时，等待设置的时间间隔后，重置剩余令牌数</span></span><br><span class="line"><span class="keyword">if</span> limiter.count &lt;= <span class="number">0</span> &#123;</span><br><span class="line">&lt;-limiter.ticker.C</span><br><span class="line">limiter.count = limiter.maxCount</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="comment">// 接收退出信号，关闭定时器并返回</span></span><br><span class="line"><span class="keyword">case</span> &lt;-limiter.ctx.Done():</span><br><span class="line">limiter.ticker.Stop()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">        <span class="comment">// 获取</span></span><br><span class="line"><span class="keyword">case</span> limiter.tokens &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line">limiter.count--</span><br><span class="line">        <span class="comment">// 每过一段时间(设置的时间间隔)，重置剩余令牌数</span></span><br><span class="line">        <span class="comment">// 与其他case是否执行无关，当其他case执行的时间小于该间隔，则其他case不会被执行</span></span><br><span class="line"><span class="keyword">case</span> &lt;-limiter.ticker.C:</span><br><span class="line">limiter.count = limiter.maxCount</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Take one token from the bucket</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rateLimiter *Limiter)</span></span> Take() &#123;</span><br><span class="line">&lt;-rateLimiter.tokens</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>官方示例中还有两个新建<code>Limiter</code>的方法，一个是控制并发速率和时间间隔的<code>New</code>，一个是不做任何控制的<code>NewUnlimited</code>，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// New creates a new limiter instance with the tokens amount and the interval</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(ctx context.Context, max <span class="type">int64</span>, duration time.Duration)</span></span> *Limiter &#123;</span><br><span class="line">limiter := &amp;Limiter&#123;</span><br><span class="line">maxCount: max,</span><br><span class="line">count:    max,</span><br><span class="line">ticker:   time.NewTicker(duration),</span><br><span class="line">tokens:   <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">ctx:      ctx,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> limiter.run()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> limiter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewUnlimited create a bucket with approximated unlimited tokens</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUnlimited</span><span class="params">(ctx context.Context)</span></span> *Limiter &#123;</span><br><span class="line">limiter := &amp;Limiter&#123;</span><br><span class="line">maxCount: math.MaxInt64,</span><br><span class="line">count:    math.MaxInt64,</span><br><span class="line">ticker:   time.NewTicker(time.Millisecond),</span><br><span class="line">tokens:   <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">ctx:      ctx,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> limiter.run()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> limiter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人写的一个使用案例如下，还是得多思考程序的一个运行流程：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">expected := <span class="number">5</span> * time.Second</span><br><span class="line">limiter := New(context.Background(), <span class="number">5</span>, expected)</span><br><span class="line">start := time.Now()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">limiter.Take()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(_i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(_i, <span class="string">&quot;+++&quot;</span>, time.Since(start))</span><br><span class="line">time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">fmt.Println(_i, <span class="string">&quot;---&quot;</span>, time.Since(start))</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">took := time.Since(start)</span><br><span class="line">fmt.Println(took)</span><br><span class="line"></span><br><span class="line">limiter.Take()</span><br><span class="line">took = time.Since(start)</span><br><span class="line">fmt.Println(took)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 部分输出结果如下：</span></span><br><span class="line"><span class="comment">// 1 +++ 0s</span></span><br><span class="line"><span class="comment">// 0 +++ 0s</span></span><br><span class="line"><span class="comment">// 3 +++ 0s</span></span><br><span class="line"><span class="comment">// 2 +++ 0s</span></span><br><span class="line"><span class="comment">// 4 +++ 0s</span></span><br><span class="line"><span class="comment">// 6 +++ 5.0139749s</span></span><br><span class="line"><span class="comment">// 5 +++ 5.0139749s</span></span><br><span class="line"><span class="comment">// 8 +++ 5.0139749s</span></span><br><span class="line"><span class="comment">// 7 +++ 5.0139749s</span></span><br><span class="line"><span class="comment">// 9 +++ 5.0139749s</span></span><br><span class="line"><span class="comment">// 4 --- 10.0149828s</span></span><br><span class="line"><span class="comment">// 10 +++ 10.0149828s</span></span><br><span class="line"><span class="comment">// 11 +++ 10.0149828s</span></span><br><span class="line"><span class="comment">// 1 --- 10.0149828s</span></span><br><span class="line"><span class="comment">// 2 --- 10.0149828s</span></span><br><span class="line"><span class="comment">// 3 --- 10.0149828s</span></span><br><span class="line"><span class="comment">// 0 --- 10.0149828s</span></span><br><span class="line"><span class="comment">// 13 +++ 10.0149828s</span></span><br><span class="line"><span class="comment">// 12 +++ 10.0149828s</span></span><br><span class="line"><span class="comment">// 14 +++ 10.0149828s</span></span><br></pre></td></tr></table></figure><h2 id="sizedwaitgroup"><a href="#sizedwaitgroup" class="headerlink" title="sizedwaitgroup"></a>sizedwaitgroup</h2></li><li><p>来自<code>remeh/sizedwaitgroup</code></p></li><li><p>这个项目是对标准库<code>sync.WaitGroup</code>进行了进一步的封装，定义了一个大小和控制并发的channel，从实现上来看还是非常简单易懂，就不做注释了</p></li><li><p>对比<code>ratelimit</code>，个人理解这个是严格控制了同一时刻goroutine的并发数</p><h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SizedWaitGroup has the same role and close to the</span></span><br><span class="line"><span class="comment">// same API as the Golang sync.WaitGroup but adds a limit of</span></span><br><span class="line"><span class="comment">// the amount of goroutines started concurrently.</span></span><br><span class="line"><span class="keyword">type</span> SizedWaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">Size <span class="type">int</span></span><br><span class="line"></span><br><span class="line">current <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">wg      sync.WaitGroup</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New creates a SizedWaitGroup.</span></span><br><span class="line"><span class="comment">// The limit parameter is the maximum amount of</span></span><br><span class="line"><span class="comment">// goroutines which can be started concurrently.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(limit <span class="type">int</span>)</span></span> SizedWaitGroup &#123;</span><br><span class="line">size := math.MaxInt32 <span class="comment">// 2^31 - 1</span></span><br><span class="line"><span class="keyword">if</span> limit &gt; <span class="number">0</span> &#123;</span><br><span class="line">size = limit</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> SizedWaitGroup&#123;</span><br><span class="line">Size: size,</span><br><span class="line"></span><br><span class="line">current: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, size),</span><br><span class="line">wg:      sync.WaitGroup&#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add increments the internal WaitGroup counter.</span></span><br><span class="line"><span class="comment">// It can be blocking if the limit of spawned goroutines</span></span><br><span class="line"><span class="comment">// has been reached. It will stop blocking when Done is</span></span><br><span class="line"><span class="comment">// been called.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// See sync.WaitGroup documentation for more information.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SizedWaitGroup)</span></span> Add() &#123;</span><br><span class="line">s.AddWithContext(context.Background())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AddWithContext increments the internal WaitGroup counter.</span></span><br><span class="line"><span class="comment">// It can be blocking if the limit of spawned goroutines</span></span><br><span class="line"><span class="comment">// has been reached. It will stop blocking when Done is</span></span><br><span class="line"><span class="comment">// been called, or when the context is canceled. Returns nil on</span></span><br><span class="line"><span class="comment">// success or an error if the context is canceled before the lock</span></span><br><span class="line"><span class="comment">// is acquired.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// See sync.WaitGroup documentation for more information.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SizedWaitGroup)</span></span> AddWithContext(ctx context.Context) <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">return</span> ctx.Err()</span><br><span class="line"><span class="keyword">case</span> s.current &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">s.wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Done decrements the SizedWaitGroup counter.</span></span><br><span class="line"><span class="comment">// See sync.WaitGroup documentation for more information.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SizedWaitGroup)</span></span> Done() &#123;</span><br><span class="line">&lt;-s.current</span><br><span class="line">s.wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait blocks until the SizedWaitGroup counter is zero.</span></span><br><span class="line"><span class="comment">// See sync.WaitGroup documentation for more information.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SizedWaitGroup)</span></span> Wait() &#123;</span><br><span class="line">s.wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用方式-1"><a href="#使用方式-1" class="headerlink" title="使用方式"></a>使用方式</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">query</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">swg := New(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">50</span>; i++ &#123;</span><br><span class="line">swg.Add()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> swg.Done()</span><br><span class="line">query(i)</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 部分输出如下</span></span><br><span class="line"><span class="comment">// 0 5.0046797s</span></span><br><span class="line"><span class="comment">// 1 5.0046797s</span></span><br><span class="line"><span class="comment">// 2 5.0048117s</span></span><br><span class="line"><span class="comment">// 3 5.0046797s</span></span><br><span class="line"><span class="comment">// 4 5.0048117s</span></span><br><span class="line"><span class="comment">// 6 10.020529s</span></span><br><span class="line"><span class="comment">// 8 10.020529s</span></span><br><span class="line"><span class="comment">// 9 10.020529s</span></span><br><span class="line"><span class="comment">// 7 10.020529s</span></span><br><span class="line"><span class="comment">// 5 10.020529s</span></span><br><span class="line"><span class="comment">// 14 15.0282816s</span></span><br><span class="line"><span class="comment">// 12 15.0283974s</span></span><br><span class="line"><span class="comment">// 11 15.0283974s</span></span><br><span class="line"><span class="comment">// 10 15.0283974s</span></span><br><span class="line"><span class="comment">// 13 15.0283974s</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上述案例可以发现，不论是通过哪种方式去控制并发速率，它们都是通过channel去进行控制的，区别在于<code>ratelimit</code>是使用的无缓冲的channel，而<code>sizedwaitgroup</code>使用的是有缓冲的channel。故回归到本质，熟练掌握基础，深刻理解底层实现才是后期不断进阶的基石。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前有记录过在go中如何控制并发速率，要么就是通过带缓冲的channel，要么就是通过协程池。不论是通过什么方式，选择最适合在当前场景使用的即可，下面记录下学习过程中发现的开源项目中不同的实现方式。&lt;/p&gt;
&lt;h2 id=&quot;ratelimit&quot;&gt;&lt;a href=&quot;#rate</summary>
      
    
    
    
    <category term="go" scheme="https://zcej.github.io/categories/go/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux常用命令之--ldd</title>
    <link href="https://zcej.github.io/2022/10/02/%E5%85%B6%E4%BB%96/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B9%8B%E2%80%94%E2%80%94ldd/"/>
    <id>https://zcej.github.io/2022/10/02/%E5%85%B6%E4%BB%96/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B9%8B%E2%80%94%E2%80%94ldd/</id>
    <published>2022-10-02T03:08:31.000Z</published>
    <updated>2023-02-05T16:51:23.520Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>ldd是用于查看可执行文件的动态链接库依赖。(也可使用pmap进行查看)<br>Q：什么是动态链接呢？</p><ul><li>有动态链接就有静态链接。静态链接是把依赖的第三方库函数打包到一起，其最后生成的可执行文件非常大。动态链接并不将那些库文件直接拿过来，而是在运行时，发现用到某些库中的某些函数时，再从第三方库中读取自己所需的方法。</li><li>动态链接库，linux下的后缀为so(Shared Object)，windows下的后缀为dll(Dynamic Link Libaray)。<blockquote><p>注：更多动态链接相关内容可参考下述文章：<br><a href="https://zhuanlan.zhihu.com/p/235551437">https://zhuanlan.zhihu.com/p/235551437</a></p></blockquote></li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>可以使用<code>ldd</code>查看文件的动态链接依赖，如查看ls依赖的结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(venvStudy) [root@node1 build_so]<span class="comment"># ldd /bin/ls</span></span><br><span class="line">        linux-vdso.so.1 =&gt;  (0x00007ffef8adb000)</span><br><span class="line">        libselinux.so.1 =&gt; /lib64/libselinux.so.1 (0x00007f3809d7d000)</span><br><span class="line">        libcap.so.2 =&gt; /lib64/libcap.so.2 (0x00007f3809b78000)</span><br><span class="line">        libacl.so.1 =&gt; /lib64/libacl.so.1 (0x00007f380996f000)</span><br><span class="line">        libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f38095a1000)</span><br><span class="line">        libpcre.so.1 =&gt; /lib64/libpcre.so.1 (0x00007f380933f000)</span><br><span class="line">        libdl.so.2 =&gt; /lib64/libdl.so.2 (0x00007f380913b000)</span><br><span class="line">        /lib64/ld-linux-x86-64.so.2 (0x00007f3809fa4000)</span><br><span class="line">        libattr.so.1 =&gt; /lib64/libattr.so.1 (0x00007f3808f36000)</span><br><span class="line">        libpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x00007f3808d1a000)</span><br></pre></td></tr></table></figure><p>通常安装某软件若是报错缺失某个依赖文件时，再结合<code>apt-file</code>查看文件所在包，然后使用<code>apt</code>进行安装。</p><blockquote><p>注：Ubuntu下使用<code>apt-file</code>涉及到的命令如下：</p><ul><li><code>apt install apt-file</code></li><li><code>apt-file update</code></li><li><code>apt-file search libpthread.so.0</code></li></ul></blockquote><p>CentOS下使用命令<code>yum provides libpthread.so.0</code></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>在技术交流群看到其他人为了防止python代码泄露，有把python代码打包成动态链接库so的，自己不知道还可以这样操作，在此进行记录下。需要先安装<code>Cython</code>，该库是通过类似python的语法去编写c扩展并可以被python调用。其即具备了python快速开发的特点，又可以让代码运行起来像c一样快，同时还可以方便的调用c library。安装命令如下：<br><code>pip install Cython -i [https://pypi.mirrors.ustc.edu.cn/simple](https://pypi.mirrors.ustc.edu.cn/simple)</code></p><h3 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h3><p>新建文件<code>hello.py</code>，该文件为被打包的目标文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;hello, <span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>新建文件<code>setup.py</code>，该文件是调用<code>Cython</code>进行打包的文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> setup</span><br><span class="line"><span class="keyword">from</span> Cython.Build <span class="keyword">import</span> cythonize</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    file_name = <span class="string">&#x27;hello.py&#x27;</span>  <span class="comment"># 文件名</span></span><br><span class="line">    build_dir = <span class="string">&#x27;&#x27;</span>  <span class="comment"># 文件目录</span></span><br><span class="line">    build_tmp_dir = <span class="string">&#x27;temp&#x27;</span>  <span class="comment"># 编译的临时文件目录</span></span><br><span class="line">    setup(ext_modules=cythonize(file_name), script_args=[<span class="string">&quot;build_ext&quot;</span>, <span class="string">&quot;-b&quot;</span>, build_dir, <span class="string">&quot;-t&quot;</span>, build_tmp_dir])</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来直接执行<code>python setup.py</code>，可以看到打包编译的过程，如果没有报错的话结果输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(venvStudy) [root@node1 build_so]<span class="comment"># ll</span></span><br><span class="line">total 284</span><br><span class="line">drwxr-xr-x 3 root root   4096 Oct 2 11:53 build</span><br><span class="line">-rw-r--r-- 1 root root 140877 Oct 2 11:53 hello.c</span><br><span class="line">-rwxr-xr-x 1 root root 130968 Oct 2 11:53 hello.cpython-37m-x86_64-linux-gnu.so</span><br><span class="line">-rw-r--r-- 1 root root     46 Oct 2 11:40 hello.py</span><br><span class="line">-rw-r--r-- 1 root root    428 Oct 2 11:53 setup.py</span><br><span class="line">-rw-r--r-- 1 root root     37 Oct 2 11:38 test.py</span><br></pre></td></tr></table></figure><p>此时已经生成了动态链接库so文件，可以将<code>hello.py</code>删除，也可以正常调用hello，<code>build</code>目录下是生成的临时文件。到这里只是大概了解了如何将python代码打包为so文件，想要更好的工程实践见下一部分内容。</p><h3 id="工程实践"><a href="#工程实践" class="headerlink" title="工程实践"></a>工程实践</h3><p>可使用下述代码进行打包，来自<code>[https://github.com/ArvinMei/py2so/blob/master/py2so.py](https://github.com/ArvinMei/py2so/blob/master/py2so.py)</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys, os, shutil, time</span><br><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> setup</span><br><span class="line"><span class="keyword">from</span> Cython.Build <span class="keyword">import</span> cythonize</span><br><span class="line"></span><br><span class="line">starttime = time.time()</span><br><span class="line">setupfile= os.path.join(os.path.abspath(<span class="string">&#x27;.&#x27;</span>), __file__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getpy</span>(<span class="params">basepath=os.path.abspath(<span class="params"><span class="string">&#x27;.&#x27;</span></span>), parentpath=<span class="string">&#x27;&#x27;</span>, name=<span class="string">&#x27;&#x27;</span>, build_dir=<span class="string">&quot;build&quot;</span>, </span></span><br><span class="line"><span class="params">          excepts=(<span class="params"></span>), copyOther=<span class="literal">False</span>, delC=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    获取py文件的路径</span></span><br><span class="line"><span class="string">    :param basepath: 根路径</span></span><br><span class="line"><span class="string">    :param parentpath: 父路径</span></span><br><span class="line"><span class="string">    :param name: 文件/夹</span></span><br><span class="line"><span class="string">    :param excepts: 排除文件</span></span><br><span class="line"><span class="string">    :param copy: 是否copy其他文件</span></span><br><span class="line"><span class="string">    :return: py文件的迭代器</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    fullpath = os.path.join(basepath, parentpath, name)</span><br><span class="line">    <span class="keyword">for</span> fname <span class="keyword">in</span> os.listdir(fullpath):</span><br><span class="line">        ffile = os.path.join(fullpath, fname)</span><br><span class="line">        <span class="keyword">if</span> os.path.isdir(ffile) <span class="keyword">and</span> ffile != os.path.join(basepath, build_dir) <span class="keyword">and</span> <span class="keyword">not</span> fname.startswith(<span class="string">&#x27;.&#x27;</span>):</span><br><span class="line">            <span class="keyword">for</span> f <span class="keyword">in</span> getpy(basepath, os.path.join(parentpath, name), fname, build_dir, excepts, copyOther, delC):</span><br><span class="line">                <span class="keyword">yield</span> f</span><br><span class="line">        <span class="keyword">elif</span> os.path.isfile(ffile):</span><br><span class="line">            <span class="comment"># print(&quot;\t&quot;, basepath, parentpath, name, ffile)</span></span><br><span class="line">            ext = os.path.splitext(fname)[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> ext == <span class="string">&quot;.c&quot;</span>:</span><br><span class="line">                <span class="keyword">if</span> delC <span class="keyword">and</span> os.stat(ffile).st_mtime &gt; starttime:</span><br><span class="line">                    os.remove(ffile)</span><br><span class="line">            <span class="keyword">elif</span> ffile <span class="keyword">not</span> <span class="keyword">in</span> excepts <span class="keyword">and</span> ext <span class="keyword">not</span> <span class="keyword">in</span>(<span class="string">&#x27;.pyc&#x27;</span>, <span class="string">&#x27;.pyx&#x27;</span>):</span><br><span class="line">                <span class="comment"># print(&quot;\t\t&quot;, basepath, parentpath, name, ffile)</span></span><br><span class="line">                <span class="keyword">if</span> ext <span class="keyword">in</span>(<span class="string">&#x27;.py&#x27;</span>, <span class="string">&#x27;.pyx&#x27;</span>) <span class="keyword">and</span> <span class="keyword">not</span> fname.startswith(<span class="string">&#x27;__&#x27;</span>):</span><br><span class="line">                    <span class="keyword">yield</span> os.path.join(parentpath, name, fname)</span><br><span class="line">                <span class="keyword">elif</span> copyOther:</span><br><span class="line">                        dstdir = os.path.join(basepath, build_dir, parentpath, name)</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(dstdir): os.makedirs(dstdir)</span><br><span class="line">                        shutil.copyfile(ffile, os.path.join(dstdir, fname))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    currdir = os.path.abspath(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    parentpath = sys.argv[<span class="number">1</span>] <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv)&gt;<span class="number">1</span> <span class="keyword">else</span> <span class="string">&quot;.&quot;</span></span><br><span class="line"></span><br><span class="line">    currdir, parentpath = os.path.split(currdir <span class="keyword">if</span> parentpath == <span class="string">&quot;.&quot;</span> <span class="keyword">else</span> os.path.abspath(parentpath))</span><br><span class="line">    build_dir = os.path.join(parentpath, <span class="string">&quot;build&quot;</span>)</span><br><span class="line">    build_tmp_dir = os.path.join(build_dir, <span class="string">&quot;temp&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;start:&quot;</span>, currdir, parentpath, build_dir)</span><br><span class="line">    os.chdir(currdir)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment">#获取py列表</span></span><br><span class="line">        module_list = <span class="built_in">list</span>(getpy(basepath=currdir,parentpath=parentpath, build_dir=build_dir, excepts=(setupfile)))</span><br><span class="line">        <span class="built_in">print</span>(module_list)</span><br><span class="line">        setup(ext_modules = cythonize(module_list),script_args=[<span class="string">&quot;build_ext&quot;</span>, <span class="string">&quot;-b&quot;</span>, build_dir, <span class="string">&quot;-t&quot;</span>, build_tmp_dir])</span><br><span class="line">        module_list = <span class="built_in">list</span>(getpy(basepath=currdir, parentpath=parentpath, build_dir=build_dir, excepts=(setupfile), copyOther=<span class="literal">True</span>))</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> ex:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;error! &quot;</span>, ex)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;cleaning...&quot;</span>)</span><br><span class="line">        module_list = <span class="built_in">list</span>(getpy(basepath=currdir, parentpath=parentpath, build_dir=build_dir, excepts=(setupfile), delC=<span class="literal">True</span>))</span><br><span class="line">        <span class="keyword">if</span> os.path.exists(build_tmp_dir): shutil.rmtree(build_tmp_dir)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;complate! time:&quot;</span>, time.time()-starttime, <span class="string">&#x27;s&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;ldd是用于查看可执行文件的动态链接库依赖。(也可使用pmap进行查看)&lt;br&gt;Q：什么是动态链接呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有动态链接</summary>
      
    
    
    
    <category term="其他" scheme="https://zcej.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux常用命令之--sar</title>
    <link href="https://zcej.github.io/2022/09/28/%E5%85%B6%E4%BB%96/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B9%8B%E2%80%94%E2%80%94sar/"/>
    <id>https://zcej.github.io/2022/09/28/%E5%85%B6%E4%BB%96/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B9%8B%E2%80%94%E2%80%94sar/</id>
    <published>2022-09-28T11:53:13.000Z</published>
    <updated>2023-02-05T16:50:05.252Z</updated>
    
    <content type="html"><![CDATA[<p>sar(system activity reporter 系统活动情况报告)，用于提取在一段时间内系统的性能分析报告，包括：文件的读写情况，系统调用的使用情况，磁盘I&#x2F;O，CPU效率，内存使用状况，进程活动及IPC有关的活动。</p><h3 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h3><ol><li><code>yum install sysstat</code>&#x2F;<code>apt-get install sysstat</code></li><li>修改文件<code>/etc/default/sysstat</code>中的内容为<code>ENANBLED=&quot;true&quot;</code></li><li>重启服务<code>systemctl restart sysstat</code><h3 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h3><code>sar -h</code>的输出见下，使用方式及参数说明都挺直观。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">Usage: sar [ options ] [ &lt;interval&gt; [ &lt;count&gt; ] ]</span><br><span class="line">Main options and reports:</span><br><span class="line">        -b      I/O and transfer rate statistics</span><br><span class="line">        -B      Paging statistics</span><br><span class="line">        -d      Block device statistics</span><br><span class="line">        -F [ MOUNT ]</span><br><span class="line">                Filesystems statistics</span><br><span class="line">        -H      Hugepages utilization statistics</span><br><span class="line">        -I &#123; &lt;int&gt; | SUM | ALL | XALL &#125;</span><br><span class="line">                Interrupts statistics</span><br><span class="line">        -m &#123; &lt;keyword&gt; [,...] | ALL &#125;</span><br><span class="line">                Power management statistics</span><br><span class="line">                Keywords are:</span><br><span class="line">                CPU     CPU instantaneous clock frequency</span><br><span class="line">                FAN     Fans speed</span><br><span class="line">                FREQ    CPU average clock frequency</span><br><span class="line">                IN      Voltage inputs</span><br><span class="line">                TEMP    Devices temperature</span><br><span class="line">                USB     USB devices plugged into the system</span><br><span class="line">        -n &#123; &lt;keyword&gt; [,...] | ALL &#125;</span><br><span class="line">                Network statistics</span><br><span class="line">                Keywords are:</span><br><span class="line">                DEV     Network interfaces</span><br><span class="line">                EDEV    Network interfaces (errors)</span><br><span class="line">                NFS     NFS client</span><br><span class="line">                NFSD    NFS server</span><br><span class="line">                SOCK    Sockets (v4)</span><br><span class="line">                IP      IP traffic      (v4)</span><br><span class="line">                EIP     IP traffic      (v4) (errors)</span><br><span class="line">                ICMP    ICMP traffic    (v4)</span><br><span class="line">                EICMP   ICMP traffic    (v4) (errors)</span><br><span class="line">                TCP     TCP traffic     (v4)</span><br><span class="line">                ETCP    TCP traffic     (v4) (errors)</span><br><span class="line">                UDP     UDP traffic     (v4)</span><br><span class="line">                SOCK6   Sockets (v6)</span><br><span class="line">                IP6     IP traffic      (v6)</span><br><span class="line">                EIP6    IP traffic      (v6) (errors)</span><br><span class="line">                ICMP6   ICMP traffic    (v6)</span><br><span class="line">                EICMP6  ICMP traffic    (v6) (errors)</span><br><span class="line">                UDP6    UDP traffic     (v6)</span><br><span class="line">        -q      Queue length and load average statistics</span><br><span class="line">        -r      Memory utilization statistics</span><br><span class="line">        -R      Memory statistics</span><br><span class="line">        -S      Swap space utilization statistics</span><br><span class="line">        -u [ ALL ]</span><br><span class="line">                CPU utilization statistics</span><br><span class="line">        -v      Kernel table statistics</span><br><span class="line">        -w      Task creation and system switching statistics</span><br><span class="line">        -W      Swapping statistics</span><br><span class="line">        -y      TTY device statistics</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="查看CPU使用率"><a href="#查看CPU使用率" class="headerlink" title="查看CPU使用率"></a>查看CPU使用率</h4><code>sar 1 3</code>默认显示的是cpu使用率信息，等同于<code>sar -u 1 3</code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Linux 4.15.0-173-generic (zw)   10/03/2022      _x86_64_        (16 CPU)</span><br><span class="line"></span><br><span class="line">08:07:19 AM     CPU     %user     %<span class="built_in">nice</span>   %system   %iowait    %steal     %idle</span><br><span class="line">08:07:20 AM     all     17.87      0.00      2.05      0.00      0.00     80.07</span><br><span class="line">08:07:21 AM     all     15.10      0.00      0.94      0.00      0.00     83.96</span><br><span class="line">08:07:22 AM     all     16.56      0.00      1.69      0.00      0.00     81.74</span><br><span class="line">Average:        all     16.51      0.00      1.56      0.00      0.00     81.92</span><br></pre></td></tr></table></figure></li></ol><ul><li>%user：用户模式下消耗的CPU时间比例</li><li>%nice：通过nice改变了进程调度优先级的进程，在用户模式下消耗的CPU时间比例</li><li>%system：系统模式下消耗的CPU时间比例</li><li>%iowait：CPU等待磁盘I&#x2F;O导致空闲状态消耗的时间比例</li><li>%steal：利用xen等操作系统虚拟化技术，等待其他虚拟CPU计算占用的时间比例</li><li>%idle：CPU空闲时间比例<blockquote><ol><li>若%iowait的值过高，表示磁盘存在I&#x2F;O瓶颈</li><li>若%idle的值高但系统响应慢时，可能是CPU等待分配内存，此时应加大内存容量</li><li>若%idle的值持续低于1，则系统CPU的处理能力相对较低，考虑CPU的资源</li></ol></blockquote></li></ul><h4 id="I-x2F-O和传输速率统计"><a href="#I-x2F-O和传输速率统计" class="headerlink" title="I&#x2F;O和传输速率统计"></a>I&#x2F;O和传输速率统计</h4><p><code>sar -b 1 3</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Linux 4.15.0-173-generic (zw)   10/03/2022      _x86_64_        (16 CPU)</span><br><span class="line"></span><br><span class="line">08:20:24 AM       tps      rtps      wtps   bread/s   bwrtn/s</span><br><span class="line">08:20:25 AM      6.00      0.00      6.00      0.00     80.00</span><br><span class="line">08:20:26 AM      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">08:20:27 AM      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">Average:         2.00      0.00      2.00      0.00     26.67</span><br></pre></td></tr></table></figure><ul><li><p>tps：每秒钟物理设备的I&#x2F;O传输总量</p></li><li><p>rtps：每秒钟从物理设备读入的数据总量</p></li><li><p>wtps：每秒钟向物理设备写入的数据总量</p></li><li><p>bread&#x2F;s：每秒钟从物理设备读入的数据量，单位为：块&#x2F;s</p></li><li><p>bwrtn&#x2F;s：每秒钟向物理设备写入的数据量，单位为：块&#x2F;s</p><h4 id="内存利用率"><a href="#内存利用率" class="headerlink" title="内存利用率"></a>内存利用率</h4><p><code>sar -r 1 3</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Linux 4.15.0-173-generic (zw)   10/03/2022      _x86_64_        (16 CPU)</span><br><span class="line"></span><br><span class="line">08:27:46 AM kbmemfree   kbavail kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty</span><br><span class="line">08:27:47 AM   3897560  65082240  94987480     96.06  11224640  47914160 120160988    120.74  40025904  50646580      1808</span><br><span class="line">08:27:48 AM   3404600  64589496  95480440     96.56  11224640  47914440 120226200    120.81  40517296  50646796      2084</span><br><span class="line">08:27:49 AM   3465888  64650784  95419152     96.50  11224640  47914440 120163888    120.74  40456772  50646796      2084</span><br><span class="line">Average:      3589349  64774173  95295691     96.37  11224640  47914347 120183692    120.76  40333324  50646724      1992</span><br></pre></td></tr></table></figure></li><li><p>kbmemfree：基本等同于<code>free</code>中的值free，不包括buffer和cache的空间</p></li><li><p>kbmemused：基本等同于<code>free</code>中的值used，包括buffer和cache的空间</p></li><li><p>%memused：物理内存总量，是kbmemused和内存总量的(不包括swap)的百分比</p></li><li><p>kbbuffers和kbcached：就是<code>free</code>中的buffer和cache</p></li><li><p>kbcommit：保证当前系统所需的内存，即为了确保不溢出而需要的内存(RAM + swap)</p></li><li><p>%commit：是kbcommit与内存总量(包括swap)的百分比</p><h3 id="排查技巧"><a href="#排查技巧" class="headerlink" title="排查技巧"></a>排查技巧</h3></li><li><p>怀疑CPU存在瓶颈，可用<code>sar -u</code>和<code>sar -q</code>等查看</p></li><li><p>怀疑内存存在瓶颈，可用<code>sar -B</code>、<code>sar -r</code>和<code>sar -W</code>等查看</p></li><li><p>怀疑I&#x2F;O存在瓶颈，可用<code>sar -b</code>、<code>sar -u</code>和<code>sar -d</code>等查看</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;sar(system activity reporter 系统活动情况报告)，用于提取在一段时间内系统的性能分析报告，包括：文件的读写情况，系统调用的使用情况，磁盘I&amp;#x2F;O，CPU效率，内存使用状况，进程活动及IPC有关的活动。&lt;/p&gt;
&lt;h3 id=&quot;安装使用&quot;&gt;</summary>
      
    
    
    
    <category term="其他" scheme="https://zcej.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>Django Admin自定义按钮取消强制选择对象</title>
    <link href="https://zcej.github.io/2022/09/11/django/Django%20Admin%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%89%E9%92%AE%E5%8F%96%E6%B6%88%E5%BC%BA%E5%88%B6%E9%80%89%E6%8B%A9%E5%AF%B9%E8%B1%A1/"/>
    <id>https://zcej.github.io/2022/09/11/django/Django%20Admin%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%89%E9%92%AE%E5%8F%96%E6%B6%88%E5%BC%BA%E5%88%B6%E9%80%89%E6%8B%A9%E5%AF%B9%E8%B1%A1/</id>
    <published>2022-09-11T14:03:11.000Z</published>
    <updated>2023-02-05T16:12:28.224Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>当创建自定义按钮，点击时默认至少需要选择一个选项。若要取消该选择，当只使用django原生admin的时候只需要重写<code>changelist_view</code>即可，而若使用了其他组件如simpleui时，则还需要修改其他东西。本文记录在使用了simpleui的情况下，如何取消点击自定义按钮时的强制选择。</p></blockquote><h2 id="1-默认情况下创建自定义按钮如下"><a href="#1-默认情况下创建自定义按钮如下" class="headerlink" title="1. 默认情况下创建自定义按钮如下"></a>1. 默认情况下创建自定义按钮如下</h2><img src="/2022/09/11/django/Django%20Admin%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%89%E9%92%AE%E5%8F%96%E6%B6%88%E5%BC%BA%E5%88%B6%E9%80%89%E6%8B%A9%E5%AF%B9%E8%B1%A1/django_admin.png" class="" title="django_admin"><h2 id="2-修改simpleui的actions-html"><a href="#2-修改simpleui的actions-html" class="headerlink" title="2. 修改simpleui的actions.html"></a>2. 修改simpleui的<code>actions.html</code></h2><p>路径如下：<br><code>\venv\Lib\site-packages\simpleui\templates\admin\actions.html</code><br>来到第413行，可能因simpleui版本不同而具体行数不一样，添加修改后如下：</p><blockquote><p>这里只是加了一个判断，自定义按钮的名字以<code>fc_</code>开头的话则直接调用点击事件</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TODO 需要做国际化</span></span><br><span class="line"><span class="keyword">if</span> (data_name.<span class="title function_">substr</span>(<span class="number">0</span>, <span class="number">3</span>) == <span class="string">&quot;fc_&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 强制运行，不用选择数据，按钮名data_name必须以&quot;fc_&quot;开头</span></span><br><span class="line">    done.<span class="title function_">call</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (checkbox_checked == <span class="number">0</span> &amp;&amp; data_name != <span class="string">&quot;add_item&quot;</span> &amp;&amp; !_action.<span class="property">customButton</span>[data_name].<span class="property">action_url</span>) &#123;</span><br><span class="line">    _vue.$alert(<span class="title function_">getLanuage</span>(<span class="string">&quot;Please select at least one option!&quot;</span>), <span class="string">&#x27;&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;warning&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (confirm) &#123;</span><br><span class="line">    _vue.$confirm(confirm, <span class="string">&#x27;提示&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">confirmButtonText</span>: <span class="string">&#x27;确定&#x27;</span>,</span><br><span class="line">        <span class="attr">cancelButtonText</span>: <span class="string">&#x27;取消&#x27;</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;warning&#x27;</span></span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> done.<span class="title function_">call</span>(<span class="variable language_">this</span>));</span><br><span class="line">  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    done.<span class="title function_">call</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-重写changelist-view方法"><a href="#3-重写changelist-view方法" class="headerlink" title="3. 重写changelist_view方法"></a>3. 重写<code>changelist_view</code>方法</h2><p>首先按钮定义如下，为一个简单的跳转操作，需要注意新增了一个动态属性<code>acts_on_all</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fc_prev</span>(<span class="params">self, request, queryset</span>):</span><br><span class="line">    <span class="keyword">return</span> HttpResponseRedirect(<span class="string">&quot;/admin/data/querytask/&quot;</span>)</span><br><span class="line">fc_prev.short_description = <span class="string">&quot;返回查询任务页&quot;</span></span><br><span class="line">fc_prev.<span class="built_in">type</span> = <span class="string">&quot;primary&quot;</span></span><br><span class="line">fc_prev.acts_on_all = <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>然后重写<code>changelist_view</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">changelist_view</span>(<span class="params">self, request, extra_context=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        action = self.get_actions(request)[request.POST[<span class="string">&quot;action&quot;</span>]][<span class="number">0</span>]</span><br><span class="line">        action_acts_on_all = action.acts_on_all</span><br><span class="line">    <span class="keyword">except</span> (KeyError, AttributeError):</span><br><span class="line">        action_acts_on_all = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> action_acts_on_all:</span><br><span class="line">        post = request.POST.copy()</span><br><span class="line">        post.setlist(ACTION_CHECKBOX_NAME, self.model.objects.<span class="built_in">all</span>()[:<span class="number">1</span>].values_list(<span class="string">&quot;id&quot;</span>, flat=<span class="literal">True</span>))</span><br><span class="line">        request.POST = post</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>(MscHuaHistoryAdmin, self).changelist_view(request, extra_context)</span><br></pre></td></tr></table></figure><p>到此，已经实现了取消自定义按钮强制选择对象的情况了，代码比较简单，主要也是参考了Stack Overflow上的回答，链接如下。</p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2><p><a href="https://stackoverflow.com/questions/4500924/django-admin-action-without-selecting-objects">https://stackoverflow.com/questions/4500924/django-admin-action-without-selecting-objects</a><br><a href="https://blog.csdn.net/qq_42761569/article/details/121495074">https://blog.csdn.net/qq_42761569&#x2F;article&#x2F;details&#x2F;121495074</a><br><a href="https://gitee.com/bode135/bddjango/blob/master/bddjango/adminclass">https://gitee.com/bode135/bddjango/blob/master/bddjango/adminclass</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;当创建自定义按钮，点击时默认至少需要选择一个选项。若要取消该选择，当只使用django原生admin的时候只需要重写&lt;code&gt;changelist_view&lt;/code&gt;即可，而若使用了其他组件如simpleui时，则还需要修改其他东西。本文记录</summary>
      
    
    
    
    <category term="django" scheme="https://zcej.github.io/categories/django/"/>
    
    
  </entry>
  
  <entry>
    <title>Django静态文件404</title>
    <link href="https://zcej.github.io/2022/09/03/django/Django%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6404/"/>
    <id>https://zcej.github.io/2022/09/03/django/Django%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6404/</id>
    <published>2022-09-03T05:46:51.000Z</published>
    <updated>2023-01-30T15:40:16.969Z</updated>
    
    <content type="html"><![CDATA[<p>首先明白一点，在django中把<code>debug</code>改为<code>false</code>的话，django将不再为我们处理静态文件，我们需要使用web服务器进行代理静态资源，这时就需要去设置静态文件的路径，下面介绍如何设置</p><blockquote><p>注：可以参考Stack Overflow上的回答<br><a href="https://stackoverflow.com/questions/5836674/why-does-debug-false-setting-make-my-django-static-files-access-fail">https://stackoverflow.com/questions/5836674/why-does-debug-false-setting-make-my-django-static-files-access-fail</a></p></blockquote><h3 id="1-settings修改"><a href="#1-settings修改" class="headerlink" title="1. settings修改"></a>1. settings修改</h3><p>新增静态文件目录配置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STATIC_ROOT = os.path.join(BASE_DIR, <span class="string">&#x27;static&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="2-静态文件收集"><a href="#2-静态文件收集" class="headerlink" title="2. 静态文件收集"></a>2. 静态文件收集</h3><p>执行下述命令，将静态文件会收集到第一步设置的目录中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py collectstatic</span><br></pre></td></tr></table></figure><h3 id="3-配置路由url"><a href="#3-配置路由url" class="headerlink" title="3. 配置路由url"></a>3. 配置路由url</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.views <span class="keyword">import</span> static</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> re_path</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    re_path(<span class="string">&#x27;^static/(?P&lt;path&gt;.*)&#x27;</span>, static.serve, &#123;<span class="string">&#x27;document_root&#x27;</span>: settings.STATIC_ROOT&#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="4-web服务器配置"><a href="#4-web服务器配置" class="headerlink" title="4. web服务器配置"></a>4. web服务器配置</h3><p>下面简单给出nginx的配置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /static &#123;</span><br><span class="line">  <span class="attribute">alias</span> /data/wwwroot/project/static;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先明白一点，在django中把&lt;code&gt;debug&lt;/code&gt;改为&lt;code&gt;false&lt;/code&gt;的话，django将不再为我们处理静态文件，我们需要使用web服务器进行代理静态资源，这时就需要去设置静态文件的路径，下面介绍如何设置&lt;/p&gt;
&lt;blockquote</summary>
      
    
    
    
    <category term="django" scheme="https://zcej.github.io/categories/django/"/>
    
    
  </entry>
  
  <entry>
    <title>Django中QuerySet的两大特性</title>
    <link href="https://zcej.github.io/2022/08/30/django/Django%E4%B8%ADQuerySet%E7%9A%84%E4%B8%A4%E5%A4%A7%E7%89%B9%E6%80%A7/"/>
    <id>https://zcej.github.io/2022/08/30/django/Django%E4%B8%ADQuerySet%E7%9A%84%E4%B8%A4%E5%A4%A7%E7%89%B9%E6%80%A7/</id>
    <published>2022-08-30T12:08:33.000Z</published>
    <updated>2023-01-30T15:36:51.880Z</updated>
    
    <content type="html"><![CDATA[<h2 id="查询集"><a href="#查询集" class="headerlink" title="查询集"></a>查询集</h2><p>查询集也称查询结果集，QuerySet，表示从数据库中获取的对象集合，在管理器上调用某些过滤器方法会返回查询集，查询集可以含有零个，一个或多个过滤器。<br>当调用如下过滤器方法时，Django会返回查询集(而不是简单的列表)：</p><ul><li>all()：返回所有数据</li><li>filter()：返回满足条件的数据</li><li>exclude()：返回满足条件之外的数据</li><li>order_by()：对结果进行排序</li></ul><p>返回单个值的过滤器如下：</p><ul><li>get()：返回单个满足条件的对象<ul><li>若未找到会抛出<code>DoesNotExist</code>异常</li><li>若找到多条会抛出<code>MultipleObjectsReturned</code>异常</li></ul></li><li>count()：返回当前查询结果的总条数</li><li>aggregate()：聚合，返回一个字典</li></ul><blockquote><p>注：判断某一个查询集中是否有数据可以使用<code>exists()</code>方法，有则返回True，反之返回False</p></blockquote><h2 id="两大特性"><a href="#两大特性" class="headerlink" title="两大特性"></a>两大特性</h2><ul><li><p>惰性执行：创建查询集不会访问数据库，直到用数据时，才会访问数据库，调用数据的情况包括迭代、序列化、与if合用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行下面的语句数据库并不会进行查询</span></span><br><span class="line">books = BookInfo.objects.<span class="built_in">all</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只有当真正使用时，才会真正去数据库进行查询</span></span><br><span class="line"><span class="keyword">for</span> b <span class="keyword">in</span> books:</span><br><span class="line">    <span class="built_in">print</span>(b)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>缓存：使用同一个查询集，第一次使用时会发生数据库的查询，然后把结果缓存下来，再次使用查询集时会使用缓存的数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进行数据库实际查询遍历，保存结果到books，会进行数据库实际交互</span></span><br><span class="line">books = [b.<span class="built_in">id</span> <span class="keyword">for</span> b <span class="keyword">in</span> BookInfo.objects.<span class="built_in">all</span>()]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次调用books，不再进行数据库查询，而是使用缓存结果</span></span><br><span class="line"><span class="built_in">print</span>(books)</span><br></pre></td></tr></table></figure><blockquote><p>注：对查询集进行取下标或切片操作，等同于sql中的limit和offset</p></blockquote></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;查询集&quot;&gt;&lt;a href=&quot;#查询集&quot; class=&quot;headerlink&quot; title=&quot;查询集&quot;&gt;&lt;/a&gt;查询集&lt;/h2&gt;&lt;p&gt;查询集也称查询结果集，QuerySet，表示从数据库中获取的对象集合，在管理器上调用某些过滤器方法会返回查询集，查询集可以含有零个，</summary>
      
    
    
    
    <category term="django" scheme="https://zcej.github.io/categories/django/"/>
    
    
  </entry>
  
  <entry>
    <title>SSL_TLS相关内容梳理</title>
    <link href="https://zcej.github.io/2022/08/14/%E5%85%B6%E4%BB%96/SSL_TLS%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%E6%A2%B3%E7%90%86/"/>
    <id>https://zcej.github.io/2022/08/14/%E5%85%B6%E4%BB%96/SSL_TLS%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%E6%A2%B3%E7%90%86/</id>
    <published>2022-08-14T02:21:02.000Z</published>
    <updated>2023-01-29T12:51:56.522Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>证书文件格式说明：</p><ul><li>.key：私钥文件，通常使用rsa算法，私钥需要自己保存，无需提交给ca机构</li><li>.crt：证书文件，certificate的缩写</li><li>.csr：证书签名请求(证书请求文件)，含有公钥信息</li><li>.crl：证书吊销列表</li><li>.pem：用于导出，导入证书时候的证书格式，是.key和.crt的合体</li></ul></blockquote><h3 id="Q：什么是数字签名，有什么作用？"><a href="#Q：什么是数字签名，有什么作用？" class="headerlink" title="Q：什么是数字签名，有什么作用？"></a>Q：什么是数字签名，有什么作用？</h3><p>作用：验证消息的来源，以及证明消息是否被篡改</p><p>签名：用私钥对消息的哈希值进行加密称为签名，<strong>只有拥有私钥的用户可以生成签名</strong></p><blockquote><p><strong>生成签名的步骤：</strong></p><ol><li>对消息进行哈希计算，得到哈希值</li><li>利用私钥对哈希值进行加密，生成签名</li><li>将签名附加在消息后面，一起发送过去</li></ol></blockquote><p>验证签名：用公钥解密签名这一步称为验证签名，所有用户都可以验证签名（因为公钥是公开的）</p><blockquote><p><strong>验证签名的步骤：</strong></p><ol><li>收到消息后，提取消息中的签名</li><li>用公钥对签名进行解密，得到哈希值1</li><li>对消息中的正文进行哈希计算，得到哈希值2</li><li>比较哈希值1和哈希值2，如果相同，则验证成功</li></ol></blockquote><h3 id="Q：什么是证书，如何验证证书？"><a href="#Q：什么是证书，如何验证证书？" class="headerlink" title="Q：什么是证书，如何验证证书？"></a>Q：什么是证书，如何验证证书？</h3><p>证书：实际上就是公钥的数字签名，是对公钥合法性提供证明的技术。它包括公钥本身，公钥的数字签名，公钥拥有者的信息等等。</p><blockquote><p><strong>生成证书的步骤：</strong></p><ol><li>服务器将公钥A给CA（公钥是服务器的）</li><li>CA用自己的私钥B给公钥A加密，生成数字签名A</li><li>CA把公钥A，数字签名A，附加一些服务器信息整合在一起，生成证书，发回给服务器</li></ol></blockquote><p>注：私钥B是用于加密公钥A的，私钥B和公钥A并不是配对的</p><p>验证证书的数字签名需要另一个公钥，保证这个公钥的合法性则需要第三方认证机构，即CA。CA能够认定公钥确实属于此人，并能生成公钥的数字签名。CA有国际性组织和政府设立的组织，也有通过提供认证服务来盈利的组织。</p><blockquote><p><strong>验证证书的步骤：</strong></p><ol><li>客户端得到证书</li><li>客户端得到证书的公钥B（通过CA或其他途径）</li><li>客户端用公钥B对证书中的数字签名解密，得到哈希值</li><li>客户端对公钥进行哈希计算</li><li>两个哈希值对比，如果相同，则证书合法</li></ol></blockquote><p>注：公钥B和上述的私钥B是配对的，分别用于对证书的验证（解密）和生成（加密）</p><p>另外，当用户私钥丢失，被盗时，认证机构需要对证书进行作废。要作废证书，认证机构需要制作一张证书作废清单（Certificate Revocation List），检查CRL。我们在验证证书的合法性时，除了验证其是否在有效期内，还需要查询其CRL，确认证书是否有效。</p><h3 id="Q：单向认证-amp-双向认证-amp-不认证"><a href="#Q：单向认证-amp-双向认证-amp-不认证" class="headerlink" title="Q：单向认证 &amp; 双向认证 &amp; 不认证"></a>Q：单向认证 &amp; 双向认证 &amp; 不认证</h3><ul><li>单向认证：指的是只有一个对象校验对端的整数合法性，通常是客户端来校验服务器的合法性。那么client需要一个ca.crt，服务端需要server.crt、server.key，当然也可以是服务端校验客户端。</li><li>双向认证：指的是相互校验，服务器需要校验每个client证书，client也需要校验服务器证书</li><li>不认证：指的是不相互校验证书，但仍然使用TLS连接<h3 id="Q：单向认证流程？"><a href="#Q：单向认证流程？" class="headerlink" title="Q：单向认证流程？"></a>Q：单向认证流程？</h3></li></ul><ol><li>client_hello：客户端发起请求，以明文传输请求信息，包含版本信息，加密套件候选列表，压缩算法候选列表，随机数，扩展字段等信息</li><li>server_hello + server_certificate + server_hello_done<ol><li>server_hello，服务端返回协商的信息结果，包括选择使用的协议版本version，选择的加密套件cipher suite，选择的压缩算法compression method、随机数random_S等，其中随机数用于后续的密钥协商</li><li>server_certificates，服务端配置对应的证书链，用于身份验证与密钥交换</li><li>server_hello_done，通知客户端server_hello信息发送结束</li></ol></li><li>证书校验<ol><li>证书&#x2F;证书链的可信性</li><li>证书是否吊销revocation，有两类方式离线CRL与在线OCSP，不同客户端行为不同</li><li>有效期expire date，证书是否在有效时间范围</li><li>域名damain，检查证书域名是否与当前的访问域名匹配(CN字段)</li></ol></li><li>client_key_exchange + change_cipher_spec + encrypted_handshake_message<ol><li>client_key_exchange：合法性验证通过之后，客户端计算产生随机数字pre-master，并用证书公钥加密，发送给服务器</li><li>此时客户端已经获取全部的计算协商密钥需要的信息：两个明文随机数random_C和random_S与自己计算产生的pre-master，计算得到协商密钥<code>enc_key=Func(...)</code></li><li>change_cipher_spec：客户端通知服务器后续的通信都采用协商的通信密钥和加密算法进行加密通信</li><li>encrypted_handshake_message：结合之前所有通信参数的hash值与其他相关信息生成一段数据，采用协商密钥session secret与算法进行加密，然后发送给服务器用于数据与握手验证</li></ol></li><li>change_cipher_spec + encrypted_handshake_message<ol><li>服务器用私钥解密加密的pre-master数据，基于之前交换的两个明文随机数random_C和random_S，计算得到协商密钥<code>enc_key=Func(...)</code></li><li>计算之前所有接收信息的哈希值，然后解密客户端发送的change_cipher_spec以告知客户端后续的通信都采用协商的密钥与算法进行加密通信</li><li>change_cipher_spec，验证通过之后，服务器同样发送change_cipher_spec以告知客户端后续的通信都采用协商的密钥与算法进行加密通信</li><li>encrypted_handshake_message，服务器也结合所有当前的通信参数信息生成一段数据并采用协商密钥session secret与算法加密并发送到客户端</li></ol></li><li>握手结束：客户端计算所有接收信息的哈希值，并采用协商密钥解密encrypted_handshake_message，验证服务器发送的数据和密钥，验证通过则握手完成</li><li>加密通信：开始使用协商密钥与算法进行加密通信</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;证书文件格式说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;.key：私钥文件，通常使用rsa算法，私钥需要自己保存，无需提交给ca机构&lt;/li&gt;
&lt;li&gt;.crt：证书文件，certificate的缩写&lt;/li&gt;
&lt;li&gt;.csr：证书签名请求(证书请求文件)</summary>
      
    
    
    
    <category term="其他" scheme="https://zcej.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>gRPC如何做身份认证？</title>
    <link href="https://zcej.github.io/2022/08/10/grpc/gRPC%E5%A6%82%E4%BD%95%E5%81%9A%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%EF%BC%9F/"/>
    <id>https://zcej.github.io/2022/08/10/grpc/gRPC%E5%A6%82%E4%BD%95%E5%81%9A%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%EF%BC%9F/</id>
    <published>2022-08-10T14:05:51.000Z</published>
    <updated>2022-10-10T14:07:46.851Z</updated>
    
    <content type="html"><![CDATA[<p>当上线gRPC服务到生产环境的时候，首先需要考虑的就是数据的安全，那么如何保证呢，下面以python为例，进行简单介绍。</p><h2 id="RPC的认证方式"><a href="#RPC的认证方式" class="headerlink" title="RPC的认证方式"></a>RPC的认证方式</h2><p>RPC服务一般在服务内网使用，不过也有存在于外网的情况，不论是哪种RPC服务，走http2.0或是其他基于TCP实现socket的协议，在部署到生产环境的时候还是需要考虑身份认证加密的，以此来保证数据的安全。</p><h3 id="基于SSL-x2F-TLS的通道加密"><a href="#基于SSL-x2F-TLS的通道加密" class="headerlink" title="基于SSL&#x2F;TLS的通道加密"></a>基于SSL&#x2F;TLS的通道加密</h3><p>通常身份认证机制是通过SSL&#x2F;TLS对传输通道加密，以防止请求和响应消息中的敏感数据泄露。使用的场景主要有三种：</p><ul><li>后端微服务直接开放给端侧，例如手机app、tv、多屏等，没有统一的API Gateway&#x2F;SLB做安全接入和认证</li><li>后端微服务直接开放给DMZ部署的管理或者运维类Portal</li><li>后端微服务直接开放给第三方合作伙伴&#x2F;渠道</li></ul><p>除了上述常用的跨网络场景之外，对于一些安全等级要求比较高的业务场景，即便是内网通信，只要跨主机&#x2F;VM&#x2F;容器等，都强制要求对传输通道进行加密。在该场景下，即便只存在内网各模块的RPC调用，仍然需要进行加密。<br>针对敏感数据的单独加密<br>有些RPC调用并不涉及敏感数据的传输，或者敏感字段占比较低，为了最大程度的提升吞吐量，降低调用时延，通常会采用HTTP&#x2F;TCP+敏感字段单独加密的方式。既保证了敏感信息的传输安全，同时也降低了采用SSL&#x2F;TLS加密通道带来的性能损耗，对于JDK原生的SSL类库，这种性能提升尤为明显。</p><h3 id="采用该方案主要有两个缺点："><a href="#采用该方案主要有两个缺点：" class="headerlink" title="采用该方案主要有两个缺点："></a>采用该方案主要有两个缺点：</h3><ul><li>对敏感信息的识别可能存在偏差，容易遗漏或者过度保护，需要解读数据和隐私保护方面的法律法规，而且不同国家对敏感数据的定义也不同，这会为识别带来很多困难。</li><li>接口升级时容易遗漏，例如开发新增字段，忘记识别是否未敏感数据。</li></ul><h2 id="gRPC认证的的具体流程"><a href="#gRPC认证的的具体流程" class="headerlink" title="gRPC认证的的具体流程"></a>gRPC认证的的具体流程</h2><p>对于gRPC，SSL&#x2F;TLS协议也是基本的身份加密认证方法，SSL&#x2F;TLS协议采用公钥加密，客户端向服务端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。<br>SSL&#x2F;TLS分为单向认证和双向认证，在实际业务中，单向认证使用较多，即客户端认证服务端，服务端不认证客户端，认证流程如下：</p><ul><li>客户端向服务端传送客户端SSL协议的版本号，支持的加密算法种类，产生的随机数，以及其他可选信息</li><li>服务端返回握手应答，向客户端传送确认SSL协议的版本号、加密算法的种类、随机数以及其他相关信息</li><li>服务端向客户端发送自己的公钥</li><li>客户端对服务端的证书进行认证，服务端的合法性校验包括：证书是否过期、发行服务器证书的CA是否可靠、发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”、服务器证书上的域名是否和服务器的实际域名相匹配等</li><li>客户端随机生成一个用于后面通讯的“对称密码”，然后用服务端的公钥对其加密，将加密后的“预主密码”传给服务端</li><li>服务端用自己的私钥解开加密的“预主密码”，然后执行一系列步骤来产生主密码</li><li>客户端向服务端发出信息，指明后面的数据通讯将使用主密码为对称密钥，同时通知服务器客户端的握手过程结束</li><li>服务端向客户端发出信息，指明后面的数据通讯将使用主密码为对称密钥，同时通知客户端服务端的握手过程结束</li><li>SSL的握手部分结束，SSL安全通道简历，客户端和服务端开始使用相同的对称密钥对数据进行加密，然后通过socket进行传输</li></ul><h2 id="具体示例"><a href="#具体示例" class="headerlink" title="具体示例"></a>具体示例</h2><h3 id="生成证书"><a href="#生成证书" class="headerlink" title="生成证书"></a>生成证书</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -newkey rsa:2048 -nodes -keyout server.key -x509 -days 3650 -out server.crt</span><br></pre></td></tr></table></figure><p>在执行生成证书的过程中，需要填入<code>Country Name</code>、<code>State or Province Name</code>、<code>Locality Name</code>、<code>Organization Name</code>、<code>Organization Unit Name</code>、<code>Common Name</code>、<code>Email Address</code>等等，这些可以按需填入，或者留空也行。</p><blockquote><p>注：其中的<code>Common Name</code>支持在客户端连接的时候指定连接的名字，可以自己定义之后填上，否则留空的话可能自动获取不到</p></blockquote><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>下面模拟一个任务的grpc调用，服务端将流式响应任务的进度信息<br><code>proto</code>定义如下：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">service </span><span class="title class_">Task</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> StartScan(TaskInfoRequest) <span class="keyword">returns</span>(stream CommonResponse)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">TaskInfoRequest</span> &#123;</span><br><span class="line">    <span class="type">string</span> task_id = <span class="number">1</span>;</span><br><span class="line">    <span class="type">string</span> data = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">CommonResponse</span> &#123;</span><br><span class="line">    <span class="type">int32</span> code = <span class="number">1</span>;</span><br><span class="line">    <span class="type">string</span> msg = <span class="number">2</span>;</span><br><span class="line">    <span class="type">string</span> progress = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：执行下述命令生成python的proto序列化协议源代码<br><code>python -m grpc_tools.protoc --python_out=. --grpc_python_out=. -I. task.proto</code></p></blockquote><p>服务端代码<code>server.py</code>如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> grpc</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> proto <span class="keyword">import</span> task_pb2, task_pb2_grpc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskServicer</span>(task_pb2_grpc.TaskServicer):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">StartScan</span>(<span class="params">self, request, context</span>):</span><br><span class="line">        progress = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> progress &lt; <span class="number">100</span>:</span><br><span class="line">            resp = &#123;</span><br><span class="line">                <span class="string">&quot;code&quot;</span>: <span class="number">200</span>,</span><br><span class="line">                <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;succeed&quot;</span>,</span><br><span class="line">                <span class="string">&quot;progress&quot;</span>: <span class="built_in">str</span>(progress)</span><br><span class="line">            &#125;</span><br><span class="line">            feature = task_pb2.CommonResponse(**resp)</span><br><span class="line">            tmp = random.randint(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">            progress += tmp</span><br><span class="line">            time.sleep(<span class="number">5</span>)</span><br><span class="line">            <span class="keyword">yield</span> feature</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">serve</span>():</span><br><span class="line">    server = grpc.server(futures.ThreadPoolExecutor(max_workers=<span class="number">10</span>), options=[</span><br><span class="line">        <span class="comment"># (&quot;grpc.max_send_message_length&quot;, 100 * 1024 * 1024),</span></span><br><span class="line">        <span class="comment"># (&quot;grpc.max_receive_message_length&quot;, 100 * 1024 * 1024)</span></span><br><span class="line">    ])</span><br><span class="line">    task_pb2_grpc.add_TaskServicer_to_server(TaskServicer(), server)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./server.key&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        private_key = f.read()</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./server.crt&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        certificate_chain = f.read()</span><br><span class="line"></span><br><span class="line">    server_credentials = grpc.ssl_server_credentials(((private_key, certificate_chain), ))</span><br><span class="line">    server.add_secure_port(<span class="string">&quot;[::]:50051&quot;</span>, server_credentials)</span><br><span class="line"></span><br><span class="line">    server.start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;gRPC服务端已开启，端口为50051...&quot;</span>)</span><br><span class="line">    server.wait_for_termination()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    serve()</span><br></pre></td></tr></table></figure><p>客户端代码<code>client.py</code>如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> grpc</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> proto <span class="keyword">import</span> task_pb2, task_pb2_grpc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_progress</span>(<span class="params">*host</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;server.crt&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        trusted_certs = f.read()</span><br><span class="line">    credentials = grpc.ssl_channel_credentials(root_certificates=trusted_certs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> grpc.secure_channel(<span class="string">&quot;localhost:50001&quot;</span>, credentials) <span class="keyword">as</span> channel:</span><br><span class="line">        stub = task_pb2_grpc.TaskStub(channel)</span><br><span class="line">        req = &#123;</span><br><span class="line">            <span class="string">&quot;task_id&quot;</span>: <span class="string">&quot;24dsad&quot;</span>,</span><br><span class="line">            <span class="string">&quot;data&quot;</span>: <span class="string">&quot;12&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        features = stub.StartScan(task_pb2.TaskInfoRequest(**req))</span><br><span class="line">        <span class="keyword">for</span> feature <span class="keyword">in</span> features:</span><br><span class="line">            <span class="built_in">print</span>(feature.progress)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>():</span><br><span class="line">    <span class="keyword">with</span> grpc.insecure_channel(<span class="string">&quot;localhost:50001&quot;</span>) <span class="keyword">as</span> channel:</span><br><span class="line">        stub = task_pb2_grpc.TaskStub(channel)</span><br><span class="line">        req = &#123;</span><br><span class="line">            <span class="string">&quot;task_id&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">            <span class="string">&quot;data&quot;</span>: <span class="string">&quot;my test&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        features = stub.StartScan(task_pb2.TaskInfoRequest(**req))</span><br><span class="line">        <span class="keyword">for</span> feature <span class="keyword">in</span> features:</span><br><span class="line">            <span class="built_in">print</span>(feature.progress)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    run()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>按照上述实现，即完成了gRPC的认证加密。</p><h3 id="抓包分析"><a href="#抓包分析" class="headerlink" title="抓包分析"></a>抓包分析</h3><p>运行上述的代码，进行抓包如下，确认gRPC通信已通过SSL&#x2F;TLS加密认证。</p><img src="/2022/08/10/grpc/gRPC%E5%A6%82%E4%BD%95%E5%81%9A%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%EF%BC%9F/grpc-ssl.png" class="" title="grpc-ssl">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当上线gRPC服务到生产环境的时候，首先需要考虑的就是数据的安全，那么如何保证呢，下面以python为例，进行简单介绍。&lt;/p&gt;
&lt;h2 id=&quot;RPC的认证方式&quot;&gt;&lt;a href=&quot;#RPC的认证方式&quot; class=&quot;headerlink&quot; title=&quot;RPC的认证方式</summary>
      
    
    
    
    <category term="grpc" scheme="https://zcej.github.io/categories/grpc/"/>
    
    
  </entry>
  
</feed>
